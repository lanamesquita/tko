#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import annotations


from typing import List, Dict, Tuple, Optional, Any, Callable, Union, Set
import argparse
import sys
import os
import yaml # type: ignore
import datetime
import enum
import hashlib
from urllib.request import urlopen
import json
import urllib
import csv
import curses
from diff_match_patch import diff_match_patch # type: ignore
import random
from uniplot import plot_to_string # type: ignore
import tempfile
import subprocess
import urllib.request
import urllib.error
import shutil
import re
import math
import yaml #type: ignore
import io
import configparser
from subprocess import PIPE
import unicodedata
import chardet # type: ignore
__version__ = "2.8.4"


class LogAction:
    class Type(enum.Enum):
        NONE = 'NONE'
        OPEN = 'OPEN' # Open program
        QUIT = 'QUIT' # Quit program
        DOWN = 'DOWN' # Down problem
        FREE = 'FREE' # Free Compile and RUN
        FAIL = 'FAIL' # Compile error or Execution error
        TEST = 'TEST' # run test and Coverage %
        SELF = 'SELF' # {c:{coverage}, a:{autonomy}, s:{skill}}
        PICK = 'PICK' # Enter problem
        BACK = 'BACK' # Leave problem
        PROG = 'PROG' # deprecated

    def __init__(self, action_value: str, task: str = "", payload: str = ""):
        self.hash = ""
        self.timestamp = ""
        self.type_value: str = action_value
        self.task_key = task
        self.payload = payload

    def set_hash(self, hash: str):
        self.hash = hash
        return self

    def set_timestamp(self, timestamp: str):
        self.timestamp = timestamp
        return self

    def __str__(self):
        return "{" + f'time:{self.timestamp}, type:{self.type_value}, key:{self.task_key}, payload:{self.payload}' + "}"

    @staticmethod
    def generate_hash(action_data: LogAction, last_hash: str):
        length = 6
        input_str = str(action_data) + last_hash
        full_hash = hashlib.sha256(input_str.encode()).hexdigest()
        return full_hash[:length]  # Retorna os primeiros 'comprimento' caracteres do hash
class TaskBasic:
    def __init__(self, key: str = ""):
        self.key = key
        self.coverage = 0
        self.autonomy = 0
        self.skill = 0
        self.timestamp: str = ""

    def set_coverage(self, value: int):
        if value >= 0:
            self.coverage = value
        return self

    def set_autonomy(self, value: int):
        if value >= 0:
            self.autonomy = value
        return self
    
    def set_skill(self, value: int):
        if value >= 0:
            self.skill = value
        return self

    def set_timestamp(self, timestamp: str):
        self.timestamp = timestamp
        return self

    def __eq__(self, other):
        if not isinstance(other, TaskBasic):
            return False
        dr: TaskBasic = other
        return self.coverage == dr.coverage and self.autonomy == dr.autonomy and self.skill == dr.skill

    def __str__(self):
        return "{" + f'k:{self.key}, c:{self.coverage}, a:{self.autonomy}, s:{self.skill}' + "}"
class Colors:
    def __init__(self):
        self.focused_item = "B"
        self.task_text_done = "g"
        self.task_text_todo = "y"
        self.button_flag_on = "G"
        self.button_flag_off = "Y"
        self.progress_skill_done = "C"
        self.progress_skill_todo = "M"
        self.main_bar_done = "G"
        self.main_bar_todo = "R"
        self.task_skills = "c"
        self.task_new = "g"
        self.mark_nothing = "m"
        self.mark_started = "r"
        self.mark_required = "y"
        self.mark_complete = "g"
    
    def to_dict(self):
        return self.__dict__
    
    def from_dict(self, attr_dict):
        for key, value in attr_dict.items():
            if hasattr(self, key):
                setattr(self, key, value)
        return self


class PatchVersion:
    def __init__(self, label: str, content: str):
        self.label: str = label
        self.content: str = content
    
    def __str__(self):
        return "{}:{}".format(self.label, self.content)


class PatchHistory:
    def __init__(self):
        # the last element is the integral last version
        # all the other elements are patches to be applied
        self.patches: list[PatchVersion] = [] 
        self.json_file: str | None = None

    def set_json_file(self, path: str):
        self.json_file = path

    def load_json(self):
        if not self.json_file:
            return
        if os.path.exists(self.json_file):
            try:
                with open(self.json_file, 'r') as file:
                    data = json.load(file)
                    for patch in data["patches"]:
                        self.patches.append(PatchVersion(patch["label"], patch["content"]))
            except:
                pass

    # save patches, label and content to json file
    def save_json(self):
        if not self.json_file:
            return
        with open(self.json_file, 'w') as file:
            json.dump(self.to_json(), file, indent=4)

    # store a new version of the file in json
    # return the label of the last version stored
    def store_version(self, label: str, new_content: str) -> str:
        if not self.patches:
            self.patches.append(PatchVersion(label, new_content))
            return label
        
        dmp = diff_match_patch()
        last = self.patches[-1]
        del self.patches[-1]

        patch = dmp.patch_make(new_content, last.content)
        if not patch: # não houve mudança
            return last.label
        
        patch_text = dmp.patch_toText(patch)
        self.patches.append(PatchVersion(last.label, patch_text))
        self.patches.append(PatchVersion(label, new_content))
        return label

    def restore_all(self) -> list[PatchVersion]:
        output: list[PatchVersion] = []
        if not self.patches:
            return output
        last = self.patches[-1]
        output.append(PatchVersion(last.label, last.content))
        index = len(self.patches) -2
        dmp = diff_match_patch()
        while index >= 0:
            label = self.patches[index].label
            patch = dmp.patch_fromText(self.patches[index].content)
            original = output[-1].content
            new_content = dmp.patch_apply(patch, original)[0]
            output.append(PatchVersion(label, new_content))
            index -= 1
        output.reverse()
        return output

    def to_json(self):
        data: dict = {}
        data["patches"] = []
        for patch in self.patches:
            data["patches"].append({"label": patch.label, "content": patch.content})
        return data
    
    def __str__(self):
        return str(self.to_json())

def random_get(dic: dict, str_key: str, mode:str = "static"):
    if mode == "static":
        count = sum([ord(c) for c in str_key])
        keys = list(dic.keys())
        return dic[keys[count % len(keys)]]
    else:
        keys = list(dic.keys())
        return dic[random.choice(keys)]

opening: Dict[str, str] = {}

# opening["parrot"] = r"""
#                            .    
#                           | \/| 
#                           ) )|/|
#                     _----. /.'.'
# .-._________..      .' @ _\  .' 
# '.._______.   '.   /    (_| .') 
#   '._____.  /   '-/      | _.'  
#    '.______ (         ) ) \     
#      '..____ '._       )  )     
#         .' __.--\  , ,  // ((   
#         '.'     |  \/   (_.'(   
#                 '   \ .'        
#                  \   (          
#                   \   '.        
#                    \ \ '.)      
#                     '-'-'       
# """

opening["estuda"] = r"""
------- O modelo de avaliação utiliza 3 critérios --------

- Cobertura: quanto da atividade foi entregue\?
  - Se houver testes, isso será calculado automaticamente
- Abordagem: como foi a última execução da atividade\?
  - Copiar, ChatGpt, Copilot, Aula, Monitoria, Sozinho
- Autonomia: se refizer a atividade sozinho e SEM CONSULTA, 
    quanto dela você se sente confiante para fazer\?

Cobertura: (  fiz nada ) 0 1 ... 9 ✓ (entreguei tudo)
Abordagem: (muita ajuda) x E D C B A (nenhum suporte)
Autonomia: (não aprendi) x ▁ ▂ ▃ ▅ █ (refaço sozinho)

 ,`````.          __||||___       
' Estuda`,       /_  ___   \      
'miserável`.    /@ \/@  \   \     
 ` , . , '  `.. \__/\___/   /     
                 \_\/______/      
                 /     /\\\\\     
                |     |\\\\\\     
                 \      \\\\\\    
                  \______/\\\\    
            _______ ||_||_______  
           (______(((_(((______(@)
"""[1:]

# opening["alien4"] = r"""
#             ______              ______
#            /___   \___\ || /___/   ___\
#           //\]/\ ___  \\||//  ___ /\[/\\
#           \\/[\//  _)   \/   (_  \\/]\//
#            \___/ _/   o    o   \_ \___/
#                _/                \_
#               //'VvvvvvvvvvvvvvvV'\\
#              ( \.'^^^^^^^^^^^^^^'./ )
#               \____   . .. .   ____/
#    ________        \ . .''. . /        ________
#   /______  \________)________(________/ _______\
#  /|       \ \  Estuda seu miserável  / /       |\
# (\|____   / /                        \ \   ____|/)
# """

# opening["alien5"] = r"""
#                    ⢀⡀⠤⠤⠤⠄ ⠒⠢⣄    
#                 ⡠⠐⢈⠄        ⢸⠓⠄  
#               ⠐⠈⠠⠊         ⡠⠊ ⠈⢂ 
#             ⢀⠊ ⡐⠁        ⢠⢊⠔⠈   ⠆
#            ⣠⡃ ⢰    ⢀⡠⠄⠐⠒ ⢸⢜⠄     
#           ⡐⣁⡑ ⠘  ⢀⠔⢁⣀⣤⣤⣤⣒⣤ ⠈    ⡄
#           ⢫⣿⢧ ⢸  ⣡⣶⣯⠭⢄⣀⣼⡏⠁⢀⡤   ⢐⠁
#           ⢠⢿⣾⣧⠈ ⢠⣿⣿⣗⢢⣤⣿⡿⢋ ⡏    ⡌ 
#    Gosto  ⠘⠳⠙⠻  ⠰⠿⠟⠛⠻⢍⠫⠒⠁⡰   ⢀⠜  
#     de    ⠘⢄          ⢀⠠⢊ ⡇⢠⠒⠁   
#    comer    ⠈⢦⠂    ⢠⠊⠁ ⢀⠄ ⡇⢸     
#  cérebros    ⠘⢄⡄⢤⢄ ⠘⡄  ⡀⠄⢊⡅⡆⢆    
#     de         ⢊   ⠈⢁⠴⠅⣀⣀⠘⢣⠠⠈⠢⢀  
#   alunos       ⠈⠢⢄⣀⡠⠊  ⠈⢣ ⠈⠃⠡  ⠉⠐
# preguiçosos             ⠰⠇  ⠐⡑⠤⢀ 
# """

intro: Dict[str, str] = {}

intro["elephant"] = r"""
        ⣀⣀                                                                      
      ⣰⣿⣿⣿⣿⣦⣀⣀⣀           ↲ -> avalia usando os testes cadastrados no cases.tio 
      ⢿⣿⠟⠋⠉    ⠉⠑⠢⣄⡀      r -> compila e (r)oda fazendo entrada de dados manual 
     ⢠⠞⠁           ⠙⢿⣿⣿⣦⡀                                                       
 ⣀  ⢀⡏ ⢀⣴⣶⣶⡄         ⢻⣿⣿⠇ TAB -> Muda o arquivo PRINCIPAL se múltiplos arquivos 
⣾⣿⣿⣦⣼⡀ ⢺⣿⣿⡿⠃    ⣠⣤⣄  ⠈⡿⠋                                                        
⢿⣿⣿⣿⣿⣇ ⠤⠌⠁ ⡀⢲⡶⠄⢸⣏⣿⣿   ⡇   d -> muda o modo (d)iff de vertical para horizontal   
⠈⢿⣿⣿⣿⣿⣷⣄⡀  ⠈⠉⠓⠂ ⠙⠛⠛⠠ ⡸⠁   u -> trava a avaliação em (u)m único caso de teste    
  ⠻⣿⣿⣿⣿⣿⣿⣷⣦⣄⣀    ⠑ ⣠⠞⠁    t -> define o limite de (t)empo para execução         
   ⢸⡏⠉⠛⠛⠛⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⡄                                                            
   ⠸        ⠈⠉⠛⢿⣿⣿⣿⣿⡄     esquerda direita -> muda o teste apresentado          
"""

compilling: Dict[str, str] = {}

# compilling["bloody"] = r"""
#  ▄████▄   ▒█████   ███▄ ▄███▓ ██▓███   ██▓ ██▓    ▄▄▄       ███▄    █ ▓█████▄  ▒█████  
# ▒██▀ ▀█  ▒██▒  ██▒▓██▒▀█▀ ██▒▓██░  ██▒▓██▒▓██▒   ▒████▄     ██ ▀█   █ ▒██▀ ██▌▒██▒  ██▒
# ▒▓█    ▄ ▒██░  ██▒▓██    ▓██░▓██░ ██▓▒▒██▒▒██░   ▒██  ▀█▄  ▓██  ▀█ ██▒░██   █▌▒██░  ██▒
# ▒▓▓▄ ▄██▒▒██   ██░▒██    ▒██ ▒██▄█▓▒ ▒░██░▒██░   ░██▄▄▄▄██ ▓██▒  ▐▌██▒░▓█▄   ▌▒██   ██░
# ▒ ▓███▀ ░░ ████▓▒░▒██▒   ░██▒▒██▒ ░  ░░██░░██████▒▓█   ▓██▒▒██░   ▓██░░▒████▓ ░ ████▓▒░
# ░ ░▒ ▒  ░░ ▒░▒░▒░ ░ ▒░   ░  ░▒▓▒░ ░  ░░▓  ░ ▒░▓  ░▒▒   ▓▒█░░ ▒░   ▒ ▒  ▒▒▓  ▒ ░ ▒░▒░▒░ 
#   ░  ▒     ░ ▒ ▒░ ░  ░      ░░▒ ░      ▒ ░░ ░ ▒  ░ ▒   ▒▒ ░░ ░░   ░ ▒░ ░ ▒  ▒   ░ ▒ ▒░ 
# ░        ░ ░ ░ ▒  ░      ░   ░░        ▒ ░  ░ ░    ░   ▒      ░   ░ ░  ░ ░  ░ ░ ░ ░ ▒  
# ░ ░          ░ ░         ░             ░      ░  ░     ░  ░         ░    ░        ░ ░  
# ░                                                                      ░               
# """


executing: str = r"""
███████╗██╗  ██╗███████╗ ██████╗██╗   ██╗████████╗ █████╗ ███╗   ██╗██████╗  ██████╗ 
██╔════╝╚██╗██╔╝██╔════╝██╔════╝██║   ██║╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗██╔═══██╗
█████╗   ╚███╔╝ █████╗  ██║     ██║   ██║   ██║   ███████║██╔██╗ ██║██║  ██║██║   ██║
██╔══╝   ██╔██╗ ██╔══╝  ██║     ██║   ██║   ██║   ██╔══██║██║╚██╗██║██║  ██║██║   ██║
███████╗██╔╝ ██╗███████╗╚██████╗╚██████╔╝   ██║   ██║  ██║██║ ╚████║██████╔╝╚██████╔╝
╚══════╝╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ 
"""

compilling["computer"] = r"""
 ██████╗ ██████╗ ███╗   ███╗██████╗ ██╗██╗      █████╗ ███╗   ██╗██████╗  ██████╗ 
██╔════╝██╔═══██╗████╗ ████║██╔══██╗██║██║     ██╔══██╗████╗  ██║██╔══██╗██╔═══██╗
██║     ██║   ██║██╔████╔██║██████╔╝██║██║     ███████║██╔██╗ ██║██║  ██║██║   ██║
██║     ██║   ██║██║╚██╔╝██║██╔═══╝ ██║██║     ██╔══██║██║╚██╗██║██║  ██║██║   ██║
╚██████╗╚██████╔╝██║ ╚═╝ ██║██║     ██║███████╗██║  ██║██║ ╚████║██████╔╝╚██████╔╝
 ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ 
"""

success: Dict[str, str] = {}


success["success"] = r"""
███████╗██╗   ██╗ ██████╗███████╗███████╗███████╗ ██████╗ 
██╔════╝██║   ██║██╔════╝██╔════╝██╔════╝██╔════╝██╔═══██╗
███████╗██║   ██║██║     █████╗  ███████╗███████╗██║   ██║
╚════██║██║   ██║██║     ██╔══╝  ╚════██║╚════██║██║   ██║
███████║╚██████╔╝╚██████╗███████╗███████║███████║╚██████╔╝
╚══════╝ ╚═════╝  ╚═════╝╚══════╝╚══════╝╚══════╝ ╚═════╝ 
"""

images: Dict[str, str] = {}

images["pink"] = r"""
Programando assim, você vai dominar o mundo!
                 /`.    /`.                       
                f   \  ,f  \                      
                |    \/-`\  \                     
                i.  _\';.,X j                     
                 `:_\ (  \ \',-.                  
                   .'"`\ a\eY' )               _,.
                   `._"\`-' `-/            .-;'  |
                     /;-`._.-';\.        ,',"    |
                   .'/   "'   | `\.-'""-/ /      j
                 ,/ /         i,-"        (  ,/  /
              .-' .f         .'            `"/  / 
             / ,,/ffj\      /          .-"`.'-.'  
            / /_\`--//)     \ ,--._ .-'_,-'; /    
           f  ".-"-._;'      `._ _.,-i; /_; /     
           `.,'   |; \          \`\_,/-'  \'      
            .'    l \ `.        /"\ _ \`  j       
            f      : `-'        `._;."/`-'        
"""

images["batman"] = r"""
Não é o que sou por dentro, é o que eu faço que me define.
                     .  .          
                     |\_|\         
                     | a_a\        
                     | | "]        
                 ____| '-\___      
                /.----.___.-'\     
               //        _    \    
              //   .-. (~v~) /|    
             |'|  /\:  .--  / \    
            // |-/  \_/____/\/~|   
           |/  \ |  []_|_|_] \ |   
           | \  | \ |___   _\ ]_}  
           | |  '-' /   '.'  |     
           | |     /    /|:  |     
           | |     |   / |:  /\    
           | |     /  /  |  /  \   
           | |    |  /  /  |    \  
           \ |    |/\/  |/|/\    \ 
            \|\ |\|  |  | / /\/\__\
             \ \| | /   | |__      
                  / |   |____)     
                  |_/              
"""


images["vegeta"] = r"""
O miserável é um gênio!
    ⢨⠊ ⢀⢀   ⠈⠺⡵⡱   ⢠⠃ ⡀         ⡘⢰⡁⠉⠊⠙⢎⣆    ⢩⢀⠜   
   ⢠⠃  ⢸⢸⡀    ⠘⢷⡡  ⠎ ⢰⣧  ⠈⡆       ⠈⣐⢤⣀⣀⢙⠦    ⡇    
  ⢀⠃   ⡌⢸⠃   ⢀  ⠑⢧⡸ ⢀⣿⢻⡀  ⣻     ⣠⡴⠛⠉   ⠑⢝⣦   ⢰⠠⠁  
  ⠌   ⡘⣖⣄⢃   ⠈⢦⡀ ⡜⡇ ⣼⠃⠈⢷⣶⢿⠟   ⢠⠞⠁ ⣀⠄⠂⣶⣶⣦⠆⠋⠓ ⢀⣀⡇   
⠡⡀⡇ ⢰⣧⢱⠊⠘⡈⠄  ⡀⠘⣿⢦⣡⢡⢰⡇⢀⠤⠊⡡⠃  ⢀⡴⠁⢀⠔⠊  ⢠⣿⠟⠁ ⢀ ⢀⠾⣤⣀  ⡠
⡀⠱⡇ ⡆⢃   ⠃   ⣧⣀⣹⡄⠙⡾⡏ ⡌⣠⡾⠁  ⣠⠊⢠⠔⠁    ⣸⡏   ⢨⣪⡄⢻⣥⠫⡳⢊⣴
  ⢡⢠ ⢸⡆ ⣀    ⠈⣛⢛⣁⣀⠘⣧⣀⢱⡿  ⢀⡔⢁⢔⠕⠉⠐⣄⣠⠤⠶⠛⠁⢀⣀  ⠉⠁⠈⠷⣞⠔⡕⣿
⢄⡀⠘⢸ ⣘⠇        ⠉⠐⠤⡑⢎⡉⢨⠁ ⣠⢏⠔⠁⠘⣤⠴⢊⣡⣤⠴⠖⠒⠻⠧⣐⠓    ⠈ ⡜ ⠇
⠤⡈⠑⠇⠡⣻⢠⠊⠉⠉⠉⠑⠒⠤⣀   ⠈⣾⣄⢘⣫⣜⠮⢿⣆⡴⢊⢥⡪⠛⠉    ⢀⠄⠂⠁      ⢧⡀⠈
⠁⠈⠑⠼⣀⣁⣇ ⣴⡉⠉⠉ ⠒⡢⠌⣐⡂⠶⣘⢾⡾⠿⢅ ⣠⣶⡿⠓⠁⢠⠖⣦⡄   ⠊         ⠈⢎⢳
    ⠉⣇⣿⢜⠙⢷⡄   ⣄⣠⠼⢶⡛⣡⢴ ⢀⠛⠱⡀    ⢀⠎ ⠁            ⢠⡋⠮⡈
  ⢀⣖⠂⢽⡈ ⠈⠑⠻⡦⠖⢋⣁⡴⠴⠊⣉⡠⢻⡖⠪⢄⡀⢈⠆  ⢠⠊⢠             ⢀⠤⡵⢤⣃
  ⠸⢠⡯⣖⢵⡀  ⣠⣤⠮⠋⠁     ⠸⣌⢆⢱⡾⠃⢀⠠⠔⠁⣀⢸     ⡄       ⡸⠚⡸⠈⠁
⠤⢀⣀⢇⢡⠸⡗⢔⡄⠸⠊           ⠉⡩⠔⢉⡠⠔⠂⠉⢀⠆            ⢠⢁⠎⢀⡠⠔
   ⠘⡌⢦⡃⣎⠘⡄        ⠠⡟⠠⡐⣋⠤ ⣀⠤⠐⠂⠉⠁             ⡸⢉⠉⠁  
⠤   ⠰⡀⠈⠻⡤⠚⢄  ⢠       ⠈⠂⠒⠉                  ⢠⠃⢸ ⢀⠤⠊
⣀    ⠘⠢⡑⢽⡬⢽⢆ ⠈           ⣠⣤⡶⠟⣉⣉⢢          ⢀⠇ ⠈⡖⠓⠒⠂
 ⢈⣑⣒⡤⠄ ⠈⠑⠥⣈⠙⠧           ⢰⣁⠔⠊⠁        ⡜   ⣠⡻   ⠇⠐⡔⣡
⠉⠉⠁ ⠒⠒⠒⠒ ⠤⠤⠍⣒⡗⢄⡀        ⠈           ⡸  ⢠⡞⢡⠃   ⢸ ⠸⣡
            ⢠  ⠈⣶⢄⡀                ⡰⠁⣠⡔⠉ ⡎    ⢸  ⠃
         ⢠⠇⣀⢼   ⢉⡄⠈⠐⠤⣀         ⢀⡀ ⡜⡡⣾⠃  ⠸      ⡧⢄⡈
       ⣀⠤⠚⠉ ⡆   ⠈⡵⢄⡀  ⠙⠂⠄⣀⡀⠤⠊⠉⢀⣀⣠⡴⢿⣟⠞  ⢀⠇      ⡗⠢⢌
    ⡠⠔⠉  ⢀⡠⡤⠇  ⢀ ⠰⣣⠈⠐⠤⡀ ⡀⠈⠙⢍⠉⣉⠤⠒⠉⣠⣟⢮⠂⡄ ⣼⠁ ⡆    ⢡⣀ 
⣿⡷⠖⠉  ⡠⠔⣪⣿⠟⣫   ⢸  ⢩⢆  ⠈⠑⢳⠤⠄⠠⠭⠤⠐⠂⢉⣾⢮⠃⢠⠃⢰⡹ ⢰     ⢸⡉⣳
⠉ ⢀⡠⠒⠉⣠⠾⠋⢁⠔⠹   ⡈⡇  ⢫⣆   ⠘⣆      ⣘⢾⠃⢀⠏⣠⡳⠁ ⣾      ⠈⠉
"""



images["esqueleto"] = r"""
Você venceu o desafio, mas não a guerra!
Espero você no próximo nível!
                              _.--""-._                     
  .                         ."         ".                   
 / \    ,^.         /(     Y             |      )\          
/   `---. |--'\    (  \__..'--   -   -- -'""-.-'  )         
|        :|    `>   '.     l_..-------.._l      .'          
|      __l;__ .'      "-.__.||_.-'v'-._||`"----"            
 \  .-' | |  `              l._       _.'                   
  \/    | |                   l`^^'^^'j                     
        | |                _   \_____/     _                
        j |               l `--__)-'(__.--' |               
        | |               | /`---``-----'"1 |  ,-----.      
        | |               )/  `--' '---'   \'-'  ___  `-.   
        | |              //  `-'  '`----'  /  ,-'   I`.  \  
      _ L |_            //  `-.-.'`-----' /  /  |   |  `. \ 
     '._' / \         _/(   `/   )- ---' ;  /__.J   L.__.\ :
      `._;/7(-.......'  /        ) (     |  |            | |
      `._;l _'--------_/        )-'/     :  |___.    _._./ ;
        | |                 .__ )-'\  __  \  \  I   1   / / 
        `-'                /   `-\-(-'   \ \  `.|   | ,' /  
                           \__  `-'    __/  `-. `---'',-'   
                              )-._.-- (        `-----'      
                             )(  l\ o ('..-.                
                       _..--' _'-' '--'.-. |                
                __,,-'' _,,-''            \ \               

"""

images["coiote"] = r"""
Você fez essa questão muito rápido, da próxima vez
vou aumentar a dificuldade!
                      _                                   
                     : \                                  
                     ;\ \_                   _            
                     ;@: ~:              _,-;@)           
                     ;@: ;~:          _,' _,'@;           
                     ;@;  ;~;      ,-'  _,@@@,'           
                    |@(     ;      ) ,-'@@@-;             
                    ;@;   |~~(   _/ /@@@@@@/              
                    \@\   ; _/ _/ /@@@@@@;~               
                     \@\   /  / ,'@@@,-'~                 
                       \\  (  ) :@@(~                     
                    ___ )-'~~~~`--/ ___                   
                   (   `--_    _,--'   )                  
                  (~`- ___ \  / ___ -'~)                  
                 __~\_(   \_~~_/   )_/~__                 
 /\ /\ /\     ,-'~~~~~`-._ 0\/0 _,-'~~~~~`-.              
| |:  ::|    ;     ______ `----'  ______    :             
| `'  `'|    ;    {      \   ~   /      }   |             
 \_   _/     `-._      ,-,' ~~  `.-.      _,'        |\   
   \ /_          `----' ,'       `, `----'           : \  
   |_( )                `-._/#\_,-'                  :  ) 
 ,-'  ~)           _,--./  (###)__                   :  : 
 (~~~~_)          /       ; `-'   `--,               |  ; 
 (~~~' )         ;       /@@@@@@.    `.              | /  
 `.HH~;        ,-'  ,-   |@@@ @@@@.   `.             .')  
  `HH `.      ,'   /     |@@@@@ @@@@.  `.           / /(~)
   HH   \_   ,'  _/`.    |@@@@@ @@@@@;  `.          ; (~~)
   ~~`.   \_,'  /   ;   .@@@@@ @@@@@@;\_  \___      ; H~\)
"""

images["piupiu"] = r"""
Eu acho que eu vi um programador!
                 $                
              $  $   $$           
              $ $$ $$             
         $$$$      $$$$$$         
       $$                $$       
     $$        $$          $$     
   $$                        $$   
  $$                          $$  
  $                           $ $ 
 $                $             $ 
 $             $$$$              $
 $            $$ $           $   $
 $          $$$$$$       $$$$    $
 $         $$$$$$$      $$  $    $
  $        $$$$$ $     $$$$$$   $ 
  $$       $     $    $$$$$$   $$ 
   $$      $    $    $$$$     $   
    $      $   $     $       $    
    $      $$$$         $  $$     
    $$               $$$  $       
     $$$       $$$$$      $       
        $$$     $$       $$       
            $$     $$$$$$         
          $$      $$ $            
       $$$$        $ $$           
         $  $$     $   $          
    $$$$$$ $       $  $           
  $$   $$$$ $      $   $$$$$$$    
  $$      $$$$     $ $$     $$    
  $          $$$$$$$$         $   
   $$         $   $          $    
    $$$$$$$$$$$   $$$$$$$$$$$ ~*  
"""

images["saitama"] = r"""
Se garantiu
        ⣠⣴⣶⡋⠉⠙⠒⢤⡀     ⢠⠖⠉⠉⠙⠢⡄ 
      ⢀⣼⣟⡒⠒     ⠙⣆   ⢠⠃     ⠹⡄
      ⣼⠷⠖        ⠘⡆  ⡇       ⢷
      ⣷⡒  ⢐⣒⣒⡒ ⣐⣒⣒⣧  ⡇ ⢠⢤⢠⡠  ⢸
     ⢰⣛⣟⣂ ⠘⠤⠬⠃⠰⠑⠥⠊⣿ ⢴⠃ ⠘⠚⠘⠑⠐ ⢸
     ⢸⣿⡿⠤     ⢀⡆  ⣿  ⡇       ⣸
     ⠈⠿⣯⡭    ⢀⣀   ⡟  ⢸      ⢠⠏
       ⠈⢯⡥⠄      ⡼⠁   ⠳⢄⣀⣀⣀⡴⠃ 
         ⢱⡦⣄⣀⣀⣀⣠⠞⠁      ⠈⠉    
       ⢀⣤⣾⠛⠃   ⢹⠳⡶⣤⡤⣄         
    ⣠⢴⣿⣿⣿⡟⡷⢄⣀⣀⣀⡼⠳⡹⣿⣷⠞⣳        
   ⢰⡯⠭⠹⡟⠿⠧⠷⣄⣀⣟⠛⣦⠔⠋⠛⠛⠋⠙⡆       
  ⢸⣿⠭⠉ ⢠⣤   ⠘⡷⣵⢻    ⣼ ⣇       
  ⡇⣿⠍⠁ ⢸⣗⠂   ⣧⣿⣼    ⣯ ⢸  
"""

images["cool"] = r"""
Essa foi show de bola!
       ⢀⣠⣤⣴⡾⠻⢶⣤⡀ 
     ⢀⣶⠟⠉⠉    ⠉⢷⡄
   ⠉⢿⣿⣿⣿⠏⠈⢿⣿⣿⣿⡿⢟⣿
    ⢸⡏ ⢠⣀ ⢀⡤   ⢨⣿
    ⠸⣿⡀ ⠉⠉⠉  ⢀⣠⡾⠃
     ⠈⠻⠷⠶⣶⡶⠾⠿⠛⠉  
 ⢀⡀     ⢀⣿       
⠿⢿⣧⡀    ⣸⣟       
  ⠘⢿⡄ ⣠⡾⢻⣿⣄      
    ⢿⣴⡟ ⢸⡏⠹⣧     
    ⠈⠛  ⢸⣟ ⠹⣧    
"""

images["among"] = r"""
Sossegue, você não é um importor
           ⣠⣤⣤⣤⣤⣤⣶⣦⣤⣄⡀         
        ⢀⣴⣿⡿⠛⠉⠙⠛⠛⠛⠛⠻⢿⣿⣷⣤⡀      
        ⣼⣿⠋       ⢀⣀⣀⠈⢻⣿⣿⡄     
       ⣸⣿⡏   ⣠⣶⣾⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣄    
       ⣿⣿⠁  ⢰⣿⣿⣯⠁       ⠈⠙⢿⣷⡄  
  ⣀⣤⣴⣶⣶⣿⡟   ⢸⣿⣿⣿⣆          ⣿⣷  
 ⢰⣿⡟⠋⠉⣹⣿⡇   ⠘⣿⣿⣿⣿⣷⣦⣤⣤⣤⣶⣶⣶⣶⣿⣿⣿  
 ⢸⣿⡇  ⣿⣿⡇    ⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃  
 ⣸⣿⡇  ⣿⣿⡇     ⠉⠻⠿⣿⣿⣿⣿⡿⠿⠿⠛⢻⣿⡇   
 ⣿⣿⠁  ⣿⣿⡇                ⢸⣿⣧   
 ⣿⣿   ⣿⣿⡇                ⢸⣿⣿   
 ⣿⣿   ⣿⣿⡇                ⢸⣿⣿   
 ⢿⣿⡆  ⣿⣿⡇                ⢸⣿⡇   
 ⠸⣿⣧⡀ ⣿⣿⡇                ⣿⣿⠃   
  ⠛⢿⣿⣿⣿⣿⣇     ⣰⣿⣿⣷⣶⣶⣶⣶⠶ ⢠⣿⣿    
       ⣿⣿     ⣿⣿⡇ ⣽⣿⡏⠁  ⢸⣿⡇    
       ⣿⣿     ⣿⣿⡇ ⢹⣿⡆   ⣸⣿⠇    
       ⢿⣿⣦⣄⣀⣠⣴⣿⣿⠁ ⠈⠻⣿⣿⣿⣿⡿⠏     
       ⠈⠛⠻⠿⠿⠿⠿⠋⠁               
"""

images["heart"] = r"""
O código ficou lindo dessa vez!
     ⣀⣀⣀⡀          ⣀⣠⣠⣴⣦⣤⣤⣄⣀   
  ⣰⣼⣿⣯⢭⣿⣿⣿⣻⣶⣤⡀  ⢀⣠⣾⣿⣿⣾⣿⣿⣿⣽⣿⣿⣻⣦⡀
 ⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⢀⣿⣿⣿⣿⣿⣿⣿⣿⡟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟
⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢡⠊⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠎⠠⠐⡉⢉⠁⠘⣭⣿⣿⣿⣿⣿⣿⣿⡿ 
⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠋⠈⠄⡁⠂⢀⠂⡬⣾⣿⣿⣿⣿⣿⣿⣿⣿⠁ 
 ⠈⢿⣿⣿⣿⣿⣿⣶⣤⣖⡂⠌⠐⠠⠐⢨⢀⠄⠘⢜⢿⣿⣿⣿⣿⣿⣿⠃  
   ⠹⣿⣿⣿⣿⣿⣿⣿⣿⠆⠁⢂⠅⣒⡈⠤⠈⡈ ⠻⣿⣿⣿⡿⠃   
    ⠙⢿⣿⣿⣿⣿⣿⣿⣄⡦⣠⣾⣿⣿⣿⣷⣾⣤⣗⣹⣿⡟     
      ⠘⠿⣿⣿⣿⣿⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏      
        ⠻⢿⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠏       
          ⠘⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁        
             ⠙⠿⢿⣿⣿⣿⡿⠋          
"""

images["pikachu"] = r"""
        Picapi!          
⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿    ⣠⣤⣶⣶
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿   ⢰⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣀⣀⣾⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡏⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿
⣿⣿⣿⣿⣿⣿   ⠈⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠁ ⣿
⣿⣿⣿⣿⣿⣿⣧⡀    ⠙⠿⠿⠿⠻⠿⠿⠟⠿⠛⠉     ⣸⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄ ⡀               ⢀⣴⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏              ⠠⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡟  ⢰⣹⡆      ⣭⣷   ⠸⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠃  ⠈⠉  ⠤⠄   ⠉⠁    ⢿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢾⣿⣷    ⡠⠤⢄   ⠠⣿⣿⣷ ⢸⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡀⠉     ⢄ ⢀    ⠉⠉⠁  ⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣧       ⠈          ⢹⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃                 ⢸⣿⣿
"""

images["yoda"] = r"""
Que a força esteja com você
 ⢀⣠⣄⣀⣀⣀               ⣀⣤⣴⣶⡾⠿⠿⠿⠿⢷⣶⣦⣤⣀⡀                     
⢰⣿⡟⠛⠛⠛⠻⠿⠿⢿⣶⣶⣦⣤⣤⣀⣀⡀⣀⣴⣾⡿⠟⠋⠉        ⠉⠙⠻⢿⣷⣦⣀         ⢀⣀⣀⣀⣀⣀⣀⣀⡀
 ⠻⣿⣦⡀ ⠉⠓⠶⢦⣄⣀⠉⠉⠛⠛⠻⠿⠟⠋⠁   ⣤⡀  ⢠   ⣠    ⠈⠙⠻⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠟⠛⠛⢻⣿
  ⠈⠻⣿⣦    ⠈⠙⠻⢷⣶⣤⡀    ⢀⣀⡀ ⠙⢷⡀⠸⡇ ⣰⠇ ⢀⣀⣀      ⣀⣠⣤⣤⣶⡶⠶⠶⠒⠂  ⣠⣾⠟
    ⠈⢿⣷⡀      ⠈⢻⣿⡄⣠⣴⣿⣯⣭⣽⣷⣆ ⠁    ⢠⣾⣿⣿⣿⣿⣦⡀ ⣠⣾⠟⠋⠁       ⣠⣾⡟⠁ 
     ⠈⢻⣷⣄       ⣿⡗⢻⣿⣧⣽⣿⣿⣿⣧  ⣀⣀ ⢠⣿⣧⣼⣿⣿⣿⣿⠗⠰⣿⠃        ⣠⣾⡿⠋   
       ⠙⢿⣶⣄⡀    ⠸⠃⠈⠻⣿⣿⣿⣿⣿⡿⠃⠾⣥⡬⠗⠸⣿⣿⣿⣿⣿⡿⠛ ⢀⡟      ⣀⣠⣾⡿⠋     
         ⠉⠛⠿⣷⣶⣤⣤⣄⣰⣄  ⠉⠉⠉⠁ ⢀⣀⣠⣄⣀⡀ ⠉⠉⠉  ⢀⣠⣾⣥⣤⣤⣤⣶⣶⡿⠿⠛⠉       
             ⠈⠉⢻⣿⠛⢿⣷⣦⣤⣴⣶⣶⣦⣤⣤⣤⣤⣬⣥⡴⠶⠾⠿⠿⠿⠿⠛⢛⣿⣿⣿⣯⡉⠁           
               ⠈⣿⣧⡀⠈⠉ ⠈⠁⣾⠛⠉⠉          ⣀⣴⣿⠟⠉⣹⣿⣇            
               ⢀⣸⣿⣿⣦⣀   ⢻⡀       ⢀⣠⣤⣶⣿⠋⣿⠛⠃ ⣈⣿⣿            
               ⣿⡿⢿⡀⠈⢹⡿⠶⣶⣼⡇ ⢀⣀⣀⣤⣴⣾⠟⠋⣡⣿⡟ ⢻⣶⠶⣿⣿⠛⠋            
              ⠘⣿⣷⡈⢿⣦⣸⠇⢀⡿⠿⠿⡿⠿⠿⣿⠛⠋⠁ ⣴⠟⣿⣧⡀⠈⢁⣰⣿⠏              
               ⢸⣿⢻⣦⣈⣽⣀⣾⠃ ⢸⡇ ⢸⡇ ⢀⣠⡾⠋⢰⣿⣿⣿⣿⡿⠟⠋               
               ⠘⠿⢿⣿⣿⡟⠛⠃  ⣾  ⢸⡇⠐⠿⠋  ⣿⢻⣿⣿                   
                  ⢸⣿⠁⢀⡴⠋ ⣿  ⢸⠇     ⠁⢸⣿⣿                   
                 ⢀⣿⡿⠟⠋   ⣿  ⣸       ⢸⣿⣿                   
                 ⢸⣿⣁⣀    ⣿⡀ ⣿      ⢀⣈⣿⣿                   
                 ⠘⠛⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠟⠛⠋                   
"""

images["vader"] = r"""
Sua falta de fé é perturbadora.
                 ⢀⣀⡀   ⢀⣀               
            ⣠⣤⣶⣾⣿⡉⢤⣍⡓⢶⣶⣦⣤⣉⠒⠤⡀           
         ⢀⣴⣿⣿⣿⣿⣿⣿⣷⡀⠙⣿⣷⣌⠻⣿⣿⣿⣶⣌⢳⡀         
        ⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠈⢿⣿⡆⠹⣿⣿⣿⣿⣷⣿⡀        
       ⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠹⣿⡄⢻⣿⣿⣿⣿⣿⣧        
      ⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⣿⣿⣷⣽⣷⢸⣿⡿⣿⡿⠿⠿⣆       
      ⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄   ⠐⠾⢭⣭⡼⠟⠃⣤⡆⠘⢟⢺⣦⡀     
      ⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢛⣥⣶⠾⠿⠛⠳⠶⢬⡁  ⠘⣃⠤⠤⠤⢍⠻⡄    
      ⣿⣿⣿⣿⣿⣿⣿⡿⣫⣾⡿⢋⣥⣶⣿⠿⢿⣿⣿⣿⠩⠭⢽⣷⡾⢿⣿⣦⢱⡹⡀   
      ⣿⣿⣿⣿⣿⣿⡟⠈⠛⠏⠰⢿⣿⣿⣧⣤⣼⣿⣿⣿⡏⠩⠽⣿⣀⣼⣿⣿⢻⣷⢡   
     ⢰⣿⣿⣿⣿⣿⣿⢁⣿⣷⣦⡀ ⠉⠙⠛⠛⠛⠋⠁⠙⢻⡆ ⢌⣉⠉⠉ ⠸⣿⣇⠆  
    ⢀⣾⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⠷⣄⢠⣶⣾⣿⣿⣿⣿⣿⠁  ⢿⣿⣿⣿⣷⠈⣿⠸⡀ 
    ⣼⣿⣿⣿⣿⣿⣿ ⣌⡛⠿⣿⣿ ⠈⢧⢿⣿⡿⠟⠋⠉⣠⣤⣤⣤⣄⠙⢿⣿⠏⣰⣿⡇⢇ 
   ⣼⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿⣶⣤⣙⠣⢀⠈⠘⠏  ⢀⣴⢹⡏⢻⡏⣿⣷⣄⠉⢸⣿⣿⣷⠸⡄
  ⣸⣿⣿⣿⣿⣿⣿⣿⠁⣾⣟⣛⠛⠛⠻⠿⠶⠬⠔ ⣠⡶⠋⠿⠈⠷⠸⠇⠻⠏⠻⠆⣀⢿⣿⣿⡄⢇
 ⢰⣿⣿⣿⣿⠿⠿⠛⠋⣰⣿⣿⣿⣿⠿⠿⠿⠒⠒⠂ ⢨⡤⢶⣶⣶⣶⣶⣶⣶⣶⣶⠆⠃⣀⣿⣿⡇⣸
⢀⣿⣿⠿⠋⣡⣤⣶⣾⣿⣿⣿⡟⠁ ⣠⣤⣴⣶⣶⣾⣿⣿⣷⡈⢿⣿⣿⣿⣿⠿⠛⣡⣴⣿⣿⣿⣿⠟⠁
⣼⠋⢁⣴⣿⣿⣿⣿⣿⣿⣿⣿   ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣎⠻⠟⠋⣠⣴⣿⣿⣿⣿⠿⠋⠁  
⢿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿ ⣴ ⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣠⣾⣿⠿⠿⠟⠋⠁     
 ⠉⠛⠛⠿⠿⠿⢿⣿⣿⣿⣵⣾⣿⣧⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠏           
                  ⠉⠉⠉⠉⠉⠉⠉⠁              
"""

images["mario"] = r"""
Vamos lá. Nossa grande aventura começa agora!
                      ⢀⣀⣠⣤⣤⣤⣄⣀            
                   ⣠⣴⡾⣻⣿⣿⣿⣿⣯⣍⠛⠻⢷⣦⣀        
                ⢀⣴⣿⠟⢁⣾⠟⠋⣁⣀⣤⡉⠻⣷⡀ ⠙⢿⣷⣄      
       ⢀⡀      ⣰⣿⠏  ⢸⣿ ⠼⢋⣉⣈⡳⢀⣿⠃   ⠙⣿⣦⡀    
      ⢰⡿⠿⣷⡀   ⣼⣿⠃  ⣀⣤⡿⠟⠛⠋⠉⠉⠙⢛⣻⠶⣦⣄⡀ ⠘⣿⣷⡀   
⢠⣾⠟⠳⣦⣄⢸⡇ ⠈⣷⡀ ⣼⣿⡏⢀⣤⡾⢋⣵⠿⠻⢿⠋⠉⠉⢻⠟⠛⠻⣦⣝⠻⣷⣄⠸⣿⣿   
⠘⣧   ⠙⢿⣿  ⢸⣷ ⣿⣿⣧⣾⣏⡴⠛⢡⠖⢛⣲⣅  ⣴⣋⡉⠳⡄⠈⠳⢬⣿⣿⣿⡿   
 ⠘⠷⣤⣀⣀⣀⣽⡶⠛⠛⠛⢷⣿⣿⣿⣿⣏  ⡏⢰⡿⢿⣿  ⣿⠻⣿ ⡷ ⣠⣾⣿⡿⠛⠷⣦  
  ⢀⣾⠟⠉⠙⣿⣤⣄ ⢀⣾⠉ ⢹⣿⣿⣷ ⠹⡘⣷⠾⠛⠋⠉⠛⠻⢿⡴⢃⣄⣻⣿⣿⣷  ⢹⡇ 
  ⢸⡇⠈⠉⠛⢦⣿⡏ ⢸⣧ ⠈⠻⣿⡿⢣⣾⣦⣽⠃       ⣷⣾⣿⡇⠉⢿⡇ ⢀⣼⠇ 
  ⠘⣷⡠⣄⣀⣼⠇   ⠻⣷⣤⣀⣸⡇ ⠹⣿⣿⣦⣀    ⢀⣴⣿⣿⡟  ⢸⣷⣾⡿⠃  
   ⠈⠻⢦⣍⣀⣀⣀⡄ ⣰⣿⡿⠿⢿⣇  ⠉⠛⠻⣿⣿⡷⠾⣿⣿⡿⠉⠁  ⢀⣾⠋⠁    
      ⠈⠉⠉⠙⠿⢿⣿⣇  ⠈⢿⣧⣄   ⢹⣷⣶⣶⣾⣿⡇  ⣀⣴⡿⣧⣄⡀    
            ⠙⢿⣷⡀  ⠙⢿⣿⣶⣤⡀⠻⢤⣀⡤⠞⢀⣴⣿⣿⠟⢷⡀⠙⠻⣦⣄  
              ⠈⢻⣦ ⢠⡟⠁⠙⢻⣿⠷⠶⣶⠶⠾⠛⠙⣿⠇  ⢻⡄  ⠙⢷⡀
               ⣸⣿⡀⣿⠁⣤⣤⡄⢻⡶⠶⠛⠛⠛⠛⠛⣿⢠⣾⣷⣆⢻⡀  ⠈⣷
               ⣿⣿⣿⣿⢸⣿⣿⣿⡈⢿⡀     ⡿⢸⣿⣿⣿⢸⡇   ⡟
               ⠈⠉⠉⠉⠈⠉⠉⠉⠁⠈⠁    ⠈⠁⠈⠉⠉⠉ ⠁  ⠈⠁
"""

images["mandalorian"] = r"""
Como deve ser
                     ⢀⣀⣀⣀⣀                        
                 ⢀⣠⠴⠚⣹⠁⣶⢲⢈⠉⠓⠶⢤⡀                   
               ⣠⠞⠉ ⢀⣾⢻ ⣿⡈⢸    ⠉⠳⢄⡀                
             ⢠⠞    ⣈⣿⣾⣾⣿⡇⢸       ⠙⢄               
           ⢀⡴⠃ ⢀⡀ ⣴⣿⡏⣿⣿⣿⡇⣼⡇       ⠈⠳⣄⡀            
       ⣠⡴⠶⠟⠋  ⡄⢸⡇⢸⣿⣼⣧⣿⣿⣿⣁⣿⣤⣄⣀⣀ ⢀    ⠈⠙⠛⠒⠦⠄        
            ⣠⣦⣷⣾⡿⠿⢿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⣿⣓⣲⠲⠦⢤⣀              
          ⢀⣴⣿⣫⣭⣼⣶⣿⠿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⣿⣟⢻⣶⣌⢻⣶            
         ⢀⣿⡿⡿⢿⠓⠒⣛⠻⣿⣟⣿⣿⣿⣿⣿⣿⡏⠙⠋⠛    ⠈⠉⣿⢹⡆           
         ⠸⣿⡇⢀⣀  ⣿⢀ ⠸⣿⣿⣿⣿⣿⣿⠁     ⣠⣴⣶⣦⣼⣿⣇           
         ⠈⣿⡇⣿⣿⣿⣦⡹⣆  ⣿⣿⣿⣿⣿⣿   ⣴⣿⣾⣿⣿⢿⣿⣿⣿⠛           
          ⢘⣿⣿⣿⣿⣿⣿⡝⣧ ⢹⣿⣿⣿⣿⣿ ⢀⣼⣿⣿⣿⣿⣿⣿⠃⣿⣿            
          ⠈⢻⣿⢸⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⡗⠈⣼⣿⢿⣿⡿⠿⢿⣯ ⠿⣿            
           ⢸⣿⣸⡇⠈⠙⢿⣷⢿⡘⣿⣿⣿⣿⠃⢠⣿⣿⡿⠉   ⢻⡀⢀⣿            
           ⢸⣿⣿   ⠈⢻⡟⣇⣇⣿⣿⣿ ⢸⣿⡿⠁     ⢷⣄⢻            
           ⢸⣿⡏     ⣿⢿⣿⣿⣿⣿ ⣾⣿⠃      ⠘⣿⡟            
           ⠘⠻⠧⣄⡀   ⢸⣾⣿⣿⣿⣿ ⣿⡟    ⣀⣠⣥⣶⣿⣦⣄⡀          
               ⠉⠙⠲⣦⣄⣿⣿⣿⣿⣿⣷⣿⣧⣴⣶⡾⣛⣯⣭⣷⠤⠶⠤⢬⣭⢽⣆⡀⢠⣶⣶⣶⠶⠶⢤
               ⣀⣀⡤⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣟⢿⠏⣉⣡⣤⣶⣾⠿⣿⣿⣿⣿⠛⢸⣾⡿⠛⠛⠛⠶
           ⣀⣠⣤⣿⣛⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣿⣷⣿⣿⡿⢟⣿⡟⣰⣾⠋     
       ⣠⣴⡶⣫⣽⢿⣯⣽⣿⣿⣿⣿⠿⠛⠁⢈⣹⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⠿⣤⣴⣿⠛⢰⣿⠇      
      ⣰⣿⣿⣼⣟⣽⣼⣿⣿⣿⣿⣯⣷⢍⣣⣶⣿⣿⣿⣿⣿⣿⣿⠟⠁     ⢸⣿⣿⡟ ⣧⣿ ⡀     
"""


images["minion"] = r"""
Bananaaaa!
              ⣀ ⠤⠤⠤ ⣀       
           ⡠⠐⢉⠴⣚⠉⣙⠢⢄⡤⢞⡂⢀⣐⢄  
          ⡔⡤⣞⢁⠊⢀⣀⠐⢿⡄⠰⢁⡀⠈⠺⣦⢡ 
         ⢰⣿⣗⣟⡸ ⠻⡿⠃⢸⣇⢃⠿⠿  ⣽⢸ 
         ⠁ ⠈⠙⢷⣴⡀ ⠠⣪⣾⣷⡄⡀⠠⣐⢕⠁ 
 ⢰⡦      ⡇    ⠙⠲⡖⠓⠉⠁⠈⠉⠒ ⠈⢸  
⢶⣿⣷⣤⢀⣀⡀  ⣏⡑⠢⢄   ⠈⠐ ⠐     ⡸⡀ 
⠛⠛⠛⠟ ⠤⠤⠌⢉ ⠈⠓⢬⣿⣦⡤⣤⣤⠤⠤⣤⣤⣤⣤⣚⣔⣄ 
         ⡇  ⡤⠂  ⢀⠤⠤⢄⡨⠔⠒⢍⠉⢁⣯⡆
         ⡗⢤⡤⣬   ⢇   ⠁  ⡸⢰⣿⣿⡿
         ⠘⢌⡿⣽⡀  ⠈⠒⢄⡀ ⢀⠔⠁⠈⠙⡋ 
           ⠑⠳⢧⣠⣤⣄⣠⣀⣈⣱⡥⠤⠴⠦⠴⠃ 
              ⢹⣿⣿ ⣿⣿⣿⣄      
              ⠙⠉⠉ ⠈⠉⠉⠉      
"""

images["minions2"] = r"""
Banana banana bananáaaaaa!
            ⣀⢀⣠⣤⣄⡀⢀⣀          
         ⣠⡶⠛⢉⠤⣀⠤⡠⢫⠵⠶⢩⡢        
 ⣀      ⢰⠋ ⣠⢡⠋⠉⠙⣆⢂⣤⡄⠈⡇⡇  ⣀⣶⣄⢤ 
⢠⢇⠓⠒⣂⡤⡀ ⡆ ⡜⣿⣜⢄⣿⢆⠜⣤⣝⣓⣢⠜ ⡠⢛⠧⠬⠭⠸⠇
⠈⠒⠓⠂⠙⠓⢌⠢⢷⡫⠐⠉⠛⠴⠶⠖⠊ ⠉⠉ ⢸⠌⡰⠁     
       ⠑⡀⠙⢕⢦  ⠠⣲⣒⠲⢲⠎⢻⢈⣷       
        ⠸⡀ ⢣⡑⡄ ⠑⠠⠄⠘⠴⠂⣸⣹       
         ⠃  ⢹⣼⡶⣄    ⡴⢿⢻       
         ⢀   ⡝⠁ ⠙⠒⠒⠋ ⢸⢸       
         ⢸⢄⣀⣀⡇  ⡖⢦⣴⠊⡆⢸⣸       
         ⢰ ⠉⢸⠁ ⠸⡇⣞⣯⡷⡇⢨⢹       
         ⣸⡀⠔⠃   ⠑⠬⠭⠝ ⣈⡾⡄      
        ⡴⢣⠑⢄⣀⣀⣀⣀⣀ ⠤⣐⢞⣿⡡⠃      
        ⠈⠁⠉⠉       ⠈⠫⠙        
"""

images["slayer"] = r"""
Não há atalhos, apenas trabalho duro.
Treine duro e seja paciente. Vai valer a pena.
⠏⠁⠈⠙⠛⢿⣿⣿⣿⣿⣿⣿⣿⡟ ⠈⠻⣿⣿⣿⣿⣿⠟⢡⡿⢿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
    ⢀⣎⣏⡏⣟⠛⠿⠿⡟⢁⣀⣀⣠⡼⠟⠛⠉  ⠉⠐⠋  ⠛⠋⠭⠾⢿⣿⣿⠟⣫⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣦⣶⡀   ⠉⠛⣿⣿⣷⣿⣇⣠⠟⠋⠁  ⢀⡄       ⣀⣠⡤⠴⠒⠋⠁⣰⡿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣷  ⡀   ⠉⠉⡿⠋⠁⡠⢀⠄⡠⠔⠋⢀⣀⠔ ⢀⡤⠚⣽⡟⠋   ⢀⡜⢱⠃⠉⣩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣦⡀⢹   ⢀⡞⠁⡰⠛⣡⢃⣾⠁⠤⡾⢋⣀⡀⠠⠊ ⢾⣏⡾ ⢀⣠⡴⠿⠙⣿⠃ ⠙⠛⢉⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⡄  ⡜ ⠐⡅⡜⡇⢠⠃⡠⠊⠐⠝⠋    ⠈⠙⢁⠔⣯⡝⢁⡶⢾⣿⠇   ⠐⠺⠿⢻⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡀⣠⡇ ⣠⡇⡸ ⢣⠎⢀⣀⣤⣴⣶⠟⠛      ⣭⣷⣤⡴⠋        ⠙⣽⡿⢿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢿⡇⢀⡟⠃⣡⡿⠃⣰⣾⡯⠚⠉⣀⣠⣄⣤            ⢀ ⢀⡈⠁   ⣠⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡇⢸⣷⠸⠁⢲⡏⢀⣾⣿⠏⣠⠞⠁ ⢾⣿⣽⡆⡀ ⣠        ⣀⡠⠄   ⢀⡾⢧⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣟⣳⣿⣿⣆ ⢸⠁⠸⣿⠏⣰⣿ ⡀  ⢁⣻⣧⣷⣿⡽⠃      ⠉    ⢠⣶⠯⣄⣠⡽⠿⢿⣿
⣿⣿⣿⣿⣿⣿⣟⡁⢈⠟⣁    ⠋⢰⣿⡿⣧⣌⣒⣒⣿⣞⣿⣿⠋           ⢀⣸⣯⠽⠋⠁     
⣿⣿⣿⠿⣿⣿⡿⠟⠁⠊⠱⣣⣶⡀  ⢘⡛⠓⠚⣛⣋⣛⣸⠭⠞⠁          ⣀⡠⣞⡋⠁        
⣿⣿⡃ ⠘⣿⢤⡀   ⣹⣿⡟ ⢀⡎⢱ ⡀                ⣉⡥⠖⠉          
⣿⣟⢿ ⢆⠘⢦⡈⢦⡠⡺⠋⠉⠠⢊⡝ ⢰⣧⡈⠓⢤⣀             ⣽⠶⠄           
⣿⣿⣼⣷⠈⢳⣄⠙⠲⣧  ⣠⠖⠋⠙⠢⠼⠁⠙⠶ ⠈⠉⠛⠤         ⣀⠉⠉            
⣿⣿⣷⣍  ⠻⠷⠄⢘⣧⣞⣡⣶⣏⠉⣳ ⣠⣤⣀ ⢤⣠⡐⠦⣄⡀    ⢀⡐⠒⠉              
⣿⣿⣿⣿⣿⣷⣶⣄⣀⣸⣿⣿⣿⣿⣿⣶⣿⣆⣻⣿⣿⣷⣶⢭⣿⣦⣶⠿⠾⣗⢒⠿ ⠁                
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡌⠁⠙⠂⢀⡉⣁⡠⠴⠛⠉⠁                  
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀  ⠈ ⣄              ⣠⣤⣶⠶⠖⣶⠁ 
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣛⡦ ⣀⣨⠟⠲⠤⠤⠬⣷⣀          ⣠⣴⠟⢁⡀ ⣼⠇  
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣶⣬⣿⣿⣡⣵⣖⣤⣀⣤⣈⣙⣶⣦⣤⣀⣀⣠⡤⠶⠟⠋⠁  ⠉⢷⠉   
"""

images["jujutsu"] = r"""
Não sei como vou me sentir quando estiver morto, 
mas não quero me arrepender da maneira como vivi.
   ⣀                      
⢠⣀⡀⡏⠳⣄   ⢀⡀ ⢠             
⡤⠵ ⢀⡶⠛⠁⢢⢄⡜⠱⡾⠍⠧⠲⡇⣀⡄        
⠈⢶⣤⠛⠁⣀⡹⠉        ⠰⠥⣤       
  ⠁ ⠠⣿⢃⢀⣤⣤⡴⣰⢰⣠⢠  ⢨⣷⡆      
     ⠝⢿⠙⢯⣟ ⣱⡿⠌⡷⣿⣾⣿⡿⠙⢦     
      ⣸ ⠼   ⠃⣠⠄⠘⡟⢘⣄ ⠈⢷    
     ⠘⡏⠉ ⡐⢢ ⢀⡀ ⢰⠖⡩⠊ ⣠⠋    
      ⢈⣷⢄⡑⠚⢀⡠⠤⣒⠡⠊⢀⣠⣾⣿⣦    
    ⢀⣴⣿⣿⣿⣍⠫⠇⠐⠉⢒⣠⣴⣿⣿⣿⣿⣿⡆   
  ⡤⢐⠚⣿⣿⣿⣿⣿⣶⣶⣶⣶⣾⣿⣛⠟⠛⣿⣿⣿⡇   
 ⢸⠐⠠⢌⣺⣿⠿⠛⠻⣿⣿⣿⣿⣿⣿ ⠄ ⠈⣿⣿⣷   
  ⠣⢌⡹⠋⠁ ⢀⣠⣿⣿⣿⣿⣿⣿⣯⣭⣀⣴⣿⣿⣿⠇  
     ⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣍   
   ⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇  
  ⢀⣾⣿⣿⣿⣿⣿⡿⠏⠁ ⠈⠉⠙⢿⣿⣿⣿⣿⣿⣿⣿⣇ 
  ⣼⣿⣿⣿⣿⡿⠋⠁       ⠙⢿⣿⣿⣿⣿⣿⣿⡆
 ⠘⠛⣿⡿⠛⠋              ⢿⣿⣏⠉⠉
⢀⠤⣾⠛⣿                ⠾⣐⣚⣦ 
⠉⠉⠉⠉⠁                     
"""


images["gollum"] = r"""
Meu precioso!
        ⣀⣠⣴⣶⡿⠟⠋⠁              
     ⢀⣴⣾⣿⣿⣿⠋      ⠈           
   ⢀⣼⡿⠛⠻⣿⣿⠃⢀            ⢀     
  ⢠⣿⣿⠃⢰⣆⠘⢿⡦⠈            ⠸     
 ⢠⣿⣿⣿ ⠙⢿⡆⠈⠁                 ⡀ 
⢀⣿⣿⣿⣿⢀⠐⢿⠃                  ⢀⣷ 
⠈⠉⠉⠙⠛⠃⣷⣮⠃ ⢀⣀⣀⡀             ⢸⣿⡇
      ⠘⣿⡄⠐⠚⢆⠁⠙⢻⣶⣦⣄⡀⡀       ⠘⠋⠁
  ⢀⣶⡀⠐⣠⣿⣷⣤⡀⠐⠙⠶⠶⠿⠿⠛⠿⣿⣿⣿⣤⣴⣀  ⣴⢎ 
  ⠈⣿⣿⣾⣿⣿⣿⣿⣇⣠⠴⠖⠲⡂   ⠹⣿⣟⡛⠹⠛⠂⠘⣡⡿ 
   ⢻⣿⣿⣿⣿⣿⡇⢹⣧   ⠱⢀⣀⡠⠲⣄⣹⣿⡏ ⣠⣾⣿⠃ 
   ⠸⣿⣿⣿⣿⣿⡇ ⠁⠙⣢⣄⣀    ⢹⣿⣿⣫⣾⣿⡿⠃  
    ⠙⢩⢻⣿⣿⣷⡀  ⢈⡙⠛⠿⠓⠐⠉ ⢸⣿⣿⣿⠟⠁   
       ⠽⢀⣤⡀ ⢠⣤⡈⠉⠁⠠⠤  ⠘⠿⠋⠁     
         ⠉⠛⠿⠶⢾⣭⢤⡾ ⠠⠒          
"""
class GuiActions:
    tab = "↔TAB"
    leave   = "Sair"
    edit = "Editar"
    principal = "Principal"
    github = "Web   "
    help = "Ajuda"
    download = "Baixar"
    activate = "Ativar"
    navigate = "←↓→"
    uncheck = "Desmarcar"
    search = "Busca"
    config = "Config"
    grade = "Pontuar"
    # tester frame
    time_limit = "Tempo"
    evaluate_tester = "Avaliar "
    execute_tester  = "Rodar"
    all = "Todos"

class GuiKeys:
    left = "h"
    right = "l"
    down = "j"
    up = "k"

    palette = "c"
    images = "I"
    down_task = "d"
    activate = "\n"
    key_help = "?"
        
    set_lang = "L"
    github_web = "w"
    key_quit = "q"
    edit= "e"
    colors = "C"
    borders = "B"
    search = "/"
    graph = "v"
    grade_play = "p"
    execute_tester = "r" # Interact in manual input
    diff = "d"
    evaluate = "\n"
    toggle_main = "\t"
    quit   = "q"
    lock = "u"
    limite  = "t"
    expand = "]"
    collapse = "["
    mass = "Y"
    hidden = "E"

class InputManager:
    backspace_list = [8, 127, 263, curses.KEY_BACKSPACE]
    left_list = [260, curses.KEY_LEFT]
    right_list = [261, curses.KEY_RIGHT]
    up_list = [259, curses.KEY_UP]
    down_list = [258, curses.KEY_DOWN]
    a = 97
    d = 100
    tab = 9
    special_double_key = 195
    cedilha = 167
    esc = 27
    plus = 465
    minus = 464
    delete = 330

    def __init__(self):
        # stores a function than can return another function
        self.calls: Dict[int, Callable[[], Optional[Callable[[], None]]]] = {}

    def add_int(self, _key: int, fn: Callable[[], None]):
        if _key in self.calls.keys():
            raise ValueError(f"Chave duplicada {chr(_key)}")
        self.calls[_key] = fn

    def add_str(self, str_key: str, fn: Callable[[], None]):
        if str_key != "":
            self.add_int(ord(str_key), fn)

    def has_str_key(self, key: str) -> bool:
        return ord(key) in self.calls
    
    def has_int_key(self, key: int) -> bool:
        return key in self.calls
    
    def exec_call(self, key: int):
        return self.calls[key]()

    @staticmethod
    def fix_esc_delay():
        if hasattr(curses, "set_escdelay"):
            curses.set_escdelay(25)
        else:
            os.environ.setdefault('ESCDELAY', '25')

    @staticmethod
    def fix_cedilha(scr, value: int) -> int:
        if value == InputManager.special_double_key:
            value = scr.getch()
            if value == InputManager.cedilha: #ç
                value = ord("c")
        return value
# from typing import List, Dict, Tuple, Optional
# from .quest import Quest
# from .game import Game
# import pydot # type: ignore


# class Graph:
#     graph_generated: bool = False

#     colorlist: List[Tuple[str, str]] = [
#             ("aquamarine3", "aquamarine4"),
#             ("bisque3", "bisque4"),
#             ("brown3", "brown4"),
#             ("chartreuse3", "chartreuse4"),
#             ("coral3", "coral4"),
#             ("cyan3", "cyan4"),
#             ("darkgoldenrod3", "darkgoldenrod4"),
#             ("darkolivegreen3", "darkolivegreen4"),
#             ("darkorchid3", "darkorchid4"),
#             ("darkseagreen3", "darkseagreen4"),
#             ("darkslategray3", "darkslategray4"),
#             ("deeppink3", "deeppink4"),
#             ("deepskyblue3", "deepskyblue4"),
#             ("dodgerblue3", "dodgerblue4"),
#             ("firebrick3", "firebrick4"),
#             ("gold3", "gold4"),
#             ("green3", "green4"),
#             ("hotpink3", "hotpink4"),
#             ("indianred3", "indianred4"),
#             ("khaki3", "khaki4"),
#             ("lightblue3", "lightblue4"),
#             ("lightcoral", "lightcoral"),
#             ("lightcyan3", "lightcyan4"),
#             ("lightgoldenrod3", "lightgoldenrod4"),
#             ("lightgreen", "lightgreen"),
#             ("lightpink3", "lightpink4"),
#             ("lightsalmon3", "lightsalmon4"),
#             ("lightseagreen", "lightseagreen"),
#             ("lightskyblue3", "lightskyblue4"),
#             ("lightsteelblue3", "lightsteelblue4"),
#             ("lightyellow3", "lightyellow4"),
#             ("magenta3", "magenta4"),
#             ("maroon3", "maroon4"),
#             ("mediumorchid3", "mediumorchid4"),
#             ("mediumpurple3", "mediumpurple4"),
#             ("mediumspringgreen", "mediumspringgreen"),
#             ("mediumturquoise", "mediumturquoise"),
#             ("mediumvioletred", "mediumvioletred"),
#             ("mistyrose3", "mistyrose4"),
#             ("navajowhite3", "navajowhite4"),
#             ("olivedrab3", "olivedrab4"),
#             ("orange3", "orange4"),
#             ("orangered3", "orangered4"),
#             ("orchid3", "orchid4"),
#             ("palegreen3", "palegreen4"),
#             ("paleturquoise3", "paleturquoise4"),
#             ("palevioletred3", "palevioletred4")
#             ]

#     def __init__(self, game: Game):
#         self.game = game
#         self.path = "graph.png"
#         self.opt = False
#         self.reachable = [q.key for q in self.game.quests.values() if q.is_reachable()]
#         # self.reachable = [key for key in self.game.quests.keys()]

#         self.counts: Dict[str, str] = {}
#         for q in self.game.quests.values():
#             done = len([t for t in q.get_tasks() if t.is_complete()])
#             init = len([t for t in q.get_tasks() if t.in_progress()])
#             todo = len([t for t in q.get_tasks() if t.not_started()])
#             self.counts[q.key] = f"{done} / {done + init + todo}"

#     def set_path(self, path: str):
#         self.path = path
#         return self

#     def set_opt(self, opt: bool):
#         self.opt = opt
#         return self

#     def set_counts(self, counts: Dict[str, str]):
#         self.counts = counts
#         return self
    
#     def set_output(self, output: str):
#         self.output = output
#         return self

#     def info(self, qx: Quest):
#         text = f'{qx.title.strip()}'
#         if self.reachable is None or self.counts is None:
#             return f'"{text}"'
#         return f'"{text}\\n{self.counts[qx.key]}"'

#     def is_reachable_or_next(self, q: Quest):
#         if self.reachable is None:
#             return True
#         if q.key in self.reachable:
#             return True
#         for r in q.requires_ptr:
#             if r.key in self.reachable:
#                 return True
#         return False

#     def generate(self):
#         saida = ["digraph diag {", '  node [penwidth=1, style="rounded,filled", shape=box]']

#         targets = [q for q in self.game.quests.values()]
#         for q in targets:
#             token = "->"
#             if len(q.requires_ptr) > 0:
#                 for r in q.requires_ptr:
#                     extra = ""
#                     if self.reachable is not None:
#                         if q.key not in self.reachable and not r.is_complete():
#                             extra = "[style=dotted]"
#                     saida.append(f"  {self.info(r)} {token} {self.info(q)} {extra}")
#             else:
#                 v = '  "Início"'
#                 saida.append(f"{v} {token} {self.info(q)}")

#         for i, c in enumerate(self.game.clusters.values()):
#             # cluster_targets = [q for q in c.quests if self.is_reachable_or_next(q)]
#             cluster_targets = [q for q in c.__quests]
#             for q in cluster_targets:
#                 if self.opt:
#                     if q.opt:
#                         fillcolor = "pink"
#                     else:
#                         fillcolor = "lime"
#                 else:
#                     if c.color is not None:
#                         fillcolor = c.color
#                     else:
#                         fillcolor = self.colorlist[i][0]

#                     if q.opt:
#                         fillcolor = f'"{fillcolor};0.9:orange"'
#                     else:
#                         fillcolor = f'"{fillcolor};0.9:lime"'
#                 shape = "ellipse"
#                 color = "black"
#                 width = 1
#                 if self.reachable is not None:
#                     if q.key not in self.reachable:
#                         color = "white"
#                     else:
#                         width = 3
#                         color = q.get_grade_color()
#                         if color == "g":
#                             color = "green"
#                         elif color == "r":
#                             color = "red"
#                         elif color == "y":
#                             color = "yellow"
#                         elif color == "m":
#                             color = "magenta"
#                 saida.append(f"  {self.info(q)} [shape={shape} color={color} penwidth={width} fillcolor={fillcolor} ]")

#         saida.append("}")

#         saida.append("")

#         out_file = self.path
#         data = "\n".join(saida)
#         graph_dot  = pydot.graph_from_dot_data(data)[0]
#         graph_dot.write_png(out_file)
tko_guide = """
       ╔════ tko GUIA COMPACTO ════╗
╔══════╩═════ BAIXAR PROBLEMA ═════╩═══════╗
║        tko down <curso> <label>          ║
║ exemplo poo  : tko down poo carro        ║
║ exemplo fup  : tko down fup opala        ║
╟─────────── EXECUTAR SEM TESTAR ──────────╢
║          tko run <cod, cod...>           ║
║exemplo ts  : tko run solver.ts           ║
║exemplo cpp : tko run main.cpp lib.cpp    ║
╟──────── ABRIR O MODO INTERATIVO ─────────╢
║              tko play <curso>            ║
║exemplo:      tko play fup                ║
╟──────────── RODAR OS TESTES ─────────────╢
║   tko run cases.tio <cod, ...> [-i ind]  ║
║ exemplo: tko run cases.tio main.ts       ║
╟── DEFINIR EXTENSÃO PADRÃO DOS RASCUNHOS ─╢
║           tko config -l <ext>            ║
║     exemplo c : tko config -l c          ║
║  exemplo java : tko config -l java       ║
╟─────────── MUDAR VISUALIZAÇÃO ───────────╢
║             tko config <--opcao>         ║
║DiffMode: tko config [--side  | --down ]  ║
║Cores   : tko config [--mono  | --color  ]║
║Encoding: tko config [--ascii | --unicode]║
╚══════════════════════════════════════════╝
"""

bash_guide = """
       ╔═══ BASH  GUIA COMPACTO ════╗
╔══════╩════ MOSTRAR E NAVEGAR ═════╩══════╗
║Mostrar arquivos  : ls                    ║
║Mostrar ocultos   : ls -la                ║
║Mudar de pasta    : cd _nome_da_pasta     ║
║Subir um nível    : cd ..                 ║
╟─────────────── CRIAR ────────────────────╢
║Criar um arquivo  : touch _nome_do_arquivo║
║Criar uma pasta   : mkdir _nome_da_pasta  ║
╟─────────────── REMOVER ──────────────────╢
║Apagar um arquivo : rm _nome_do_arquivo   ║
║Apagar uma pasta  : rm -r _nome_da_pasta  ║
║Renomear ou mover : mv _antigo _novo      ║
╟─────────────── CONTROLAR ────────────────╢
║Últimos comandos  : SETA PRA CIMA         ║
║Limpar console    : Control L             ║
║Cancelar execução : Control C             ║
║Finalizar entrada : Control D             ║
╚══════════════════════════════════════════╝
"""
def get_md_link(title: str) -> str:
    if title is None:
        return ""
    title = title.lower()
    out = ""
    for c in title:
        if c == " " or c == "-":
            out += "-"
        elif c == "_":
            out += "_"
        elif c.isalnum():
            out += c
    return out


class FileSource:
    def __init__(self, label, input_file, output_file):
        self.label = label
        self.input_file = input_file
        self.output_file = output_file

    def __eq__(self, other):
        return self.label == other.label and self.input_file == other.input_file and \
                self.output_file == other.output_file


class PatternLoader:
    pattern: str = ""

    def __init__(self):
        parts = PatternLoader.pattern.split(" ")
        self.input_pattern = parts[0]
        self.output_pattern = parts[1] if len(parts) > 1 else ""
        self._check_pattern()

    def _check_pattern(self):
        self.__check_double_wildcard()
        self.__check_missing_wildcard()

    def __check_double_wildcard(self):
        if self.input_pattern.count("@") > 1 or self.output_pattern.count("@") > 1:
            raise ValueError("  fail: the wildcard @ should be used only once per pattern")

    def __check_missing_wildcard(self):
        if "@" in self.input_pattern and "@" not in self.output_pattern:
            raise ValueError("  fail: is input_pattern has the wildcard @, the input_patter should have too")
        if "@" not in self.input_pattern and "@" in self.output_pattern:
            raise ValueError("  fail: is output_pattern has the wildcard @, the input_pattern should have too")

    def make_file_source(self, label):
        return FileSource(label, self.input_pattern.replace("@", label), self.output_pattern.replace("@", label))

    def get_file_sources(self, filename_list: List[str]) -> List[FileSource]:
        input_re = self.input_pattern.replace(".", "\\.")
        input_re = input_re.replace("@", "(.*)")
        file_source_list = []
        for filename in filename_list:
            match = re.findall(input_re, filename)
            if not match:
                continue
            label = match[0]
            file_source = self.make_file_source(label)
            if file_source.output_file not in filename_list:
                print("fail: file " + file_source.output_file + " not found")
            else:
                file_source_list.append(file_source)
        return file_source_list

    def get_odd_files(self, filename_list) -> List[str]:
        matched = []
        sources = self.get_file_sources(filename_list)
        for source in sources:
            matched.append(source.input_file)
            matched.append(source.output_file)
        unmatched = [file for file in filename_list if file not in matched]
        return unmatched

class AnsiColor:
    enabled = True
    terminal_styles = {
        '.': '\033[0m', # Reset
        '*': '\033[1m', # Bold
        '/': '\033[3m', # Italic
        '_': '\033[4m', # Underline
        
        'k': '\033[30m', # Black
        'r': '\033[31m', # Red
        'g': '\033[32m', # Green
        'y': '\033[33m', # Yellow
        'b': '\033[34m', # Blue
        'm': '\033[35m', # Magenta
        'c': '\033[36m', # Cyan
        'w': '\033[37m', # White


        'K': '\033[40m', # Background black
        'W': '\033[47m', # Background white
        "R": '\033[41m', # Background red
        "G": '\033[42m', # Background green
        "Y": '\033[43m', # Background yellow
        "B": '\033[44m', # Background blue
        "M": '\033[45m', # Background magenta
        "C": '\033[46m', # Background cyan
    }

    @staticmethod
    def colour(modifiers: str, text: str) -> str:
        if not AnsiColor.enabled:
            return text
        output = ''
        for m in modifiers:
            val = AnsiColor.terminal_styles.get(m, '')
            if val != '':
                output += val
        output += text
        if len(modifiers) > 0:
            output += AnsiColor.terminal_styles.get('.', "")
        return output

class Token:
    def __init__(self, text: str = "", fmt: str = "", ):
        if not isinstance(text, str):
            raise TypeError("text must be a string")
        self.text = text
        self.fmt = fmt

    def __eq__(self, other: Any):
        if not isinstance(other, Token):
            return False
        return self.text == other.text and self.fmt == other.fmt

    def __len__(self):
        return len(self.text)
    
    def __add__(self, other: Any):
        return Text().add(self).add(other)

    def __str__(self):
        return f"({self.fmt}:{self.text})"

def RToken(fmt: str, text: str) -> Token:
    return Token(text, fmt)

class Text:
    def __init__(self):
        self.data: List[Token] = []

    @staticmethod
    def format(value: str = "", *args):
        if not isinstance(value, str):
            raise TypeError("value must be a string")
        text = Text()
        text.__process_placeholders(value, *args)
        return text

    def set_background(self, fmt: str):
        for d in self.data:
            lower_only = "".join([c for c in d.fmt if c.islower()])
            d.fmt = fmt + lower_only
        return self

    def clone(self):
        other = Text()
        other.data = [v for v in self.data]
        return other

    def setup(self, data: List[Token]):
        self.data = []
        for d in data:
            for c in d.text:
                self.data.append(Token(c, d.fmt))
        return self

    def split(self, sep: str) -> List[Text]:
        output = []
        current = Text()
        for d in self.data:
            if d.text == sep:
                output.append(current)
                current = Text()
            else:
                current.add(d)
        output.append(current)
        return output

    def slice(self, start: int | None = None, end: int | None = None) -> Text:
        if start is None:
            start = 0
        while start < 0:
            start = len(self) + start
        if end is None:
            end = len(self)
        while end < 0:
            end = len(self) + end
        output = Text()
        for i in range(start, end):
            output.add(self[i])
        return output

    def __getitem__(self, index: int) -> Token:
        if index < 0 or index >= len(self):
            raise IndexError("index out of range")
        return self.data[index]

    def __len__(self):
        return self.len()
    
    def __add__(self, other: Any):
        return Text().add(self).add(other)

    def __eq__(self, other: Any):
        if len(self.data) != len(other.data):
            return False
        for i in range(len(self.data)):
            if self.data[i] != other.data[i]:
                return False
        return True


    def __str__(self):
        output = ""
        for elem in self.resume():
            output += AnsiColor.colour(elem.fmt, elem.text)
        return output
    
    def resume(self) -> List[Token]:
        if len(self.data) == 0:
            return []
        
        new_data: List[Token] = [Token("", self.data[0].fmt)]
        for d in self.data:
            if d.fmt == new_data[-1].fmt:
                new_data[-1].text += d.text
            else:
                new_data.append(Token())
                new_data[-1].text = d.text
                new_data[-1].fmt = d.fmt
        return new_data

    # search for a value inside the tokens and replace it with a new value and fmt
    def replace(self, old: str, token: Token):
        index = 0
        while True:
            if index + len(old) > len(self.data):
                break
            sub = "".join([t.text for t in self.data[index:index + len(old)]])
            if sub == old:
                pre = self.data[:index]
                mid = [Token(t, token.fmt) for t in token.text]
                pos = self.data[index + len(old):]
                self.data = pre + mid + pos
                index += len(token.text)
            else:
                index += 1
        return self

    def plus(self, qtd: int) -> Text:
        output = Text()
        for i in range(qtd):
            output.add(self)
        return output

    def add(self, value: str | Token | Text | None):
        if value is None:
            return self
        if isinstance(value, str):
            if value != "":
                for c in value:
                    self.data.append(Token(c))
        elif isinstance(value, Token):
            if value.text != "":
                for c in value.text:
                    self.data.append(Token(c, value.fmt))
        elif isinstance(value, Text):
            self.data += value.data
        else:
            raise TypeError("unsupported type '{}'".format(type(value)))
        return self
    
    def addf(self, fmt: str, value: str | Token | Text | None):
        if isinstance(value, str):
            self.add(Token(value, fmt))
        elif isinstance(value, Token):
            self.add(Token(value.text, fmt))
        elif isinstance(value, Text):
            self.add(Token(value.get_text(), fmt))
        return self

    def ljust(self, width: int, filler: Token = Token(" ")):
        total = self.len()
        char = " " if filler.text == "" else filler.text[0]
        fmt = filler.fmt
        if total < width:
            suffix = [Token(char, fmt) for _ in range(width - total)]
            self.data = self.data + suffix
        return self
    
    def rjust(self, width: int, filler: Token = Token(" ")):
        total = self.len()
        char = " " if filler.text == "" else filler.text[0]
        fmt = filler.fmt
        if total < width:
            prefix = [Token(char, fmt) for _ in range(width - total)]
            self.data = prefix + self.data
        return self
    
    def center(self, width: int, filler: Token = Token(" ")):
        if isinstance(filler, str):
            filler = Token(filler)
        total = self.len()
        char = " " if filler.text == "" else filler.text[0]
        fmt = filler.fmt
        if total < width:
            left = (width - total) // 2
            right = width - total - left
            prefix = [Token(char, fmt) for _ in range(left)]
            suffix = [Token(char, fmt) for _ in range(right)]
            self.data = prefix + self.data + suffix
        return self

    def fold_in(
        self, width: int, sep: str | Token = " ", left_border: str | Token = " ", right_border: str | Token  = " "
    ) -> Text:
        if isinstance(sep, str):
            sep = Token(sep)
        if isinstance(left_border, str):
            left_border = Token(left_border)
        if isinstance(right_border, str):
            right_border = Token(right_border)

        available = width - len(left_border) - len(right_border)
        if self.len() > available:
            self.trim_end(available)
            return Text() + left_border + self + right_border
        missing = width - self.len() - 2
        left = missing // 2
        right = missing - left
        filler_left = Text().add(sep).plus(left)
        filler_right = Text().add(sep).plus(right)
        return Text() + left_border + filler_left + self + filler_right + right_border
    
    def len(self):
        return len(self.data)
    
    def get_data(self):
        return self.data
    
    def get_text(self) -> str:
        return "".join([t.text for t in self.data])

    def cut_begin(self, qtd: int):
        if qtd > len(self.data):
            self.data = []
        else:
            self.data = self.data[qtd:]
        return self

    def trim_spaces(self, limit: int):
        return self

    def trim_end(self, width: int):
        if self.len() > width:
            self.data = self.data[:width]
        return self

    def join(self, array: List[Text]):
        out = Text()
        for i, a in enumerate(array):
            if i != 0:
                out.add(self)
            out.add(a)
        return out

    @staticmethod
    def __preprocess(data):
        # Primeira etapa: substitui << por \a
        result1 = []
        i = 0
        while i < len(data):
            if i < len(data) - 1 and data[i] == '{' and data[i + 1] == '{':
                result1.append('\a')  # Usa o marcador \a para << 
                i += 2  # Pula o próximo '<'
            else:
                result1.append(data[i])
                i += 1

        # Segunda etapa: substitui >> por \b, de trás para frente
        result2 = []
        i = len(result1) - 1
        while i >= 0:
            if i > 0 and result1[i] == '}' and result1[i - 1] == '}':
                result2.append('\b')  # Usa o marcador \b para >>
                i -= 2  # Pula o próximo '>'
            else:
                result2.append(result1[i])
                i -= 1

        # Inverter result2 para obter o resultado final
        final_result = ''.join(result2[::-1])
        return final_result

    @staticmethod
    def __extract(data):
        data = Text.__preprocess(data)  # Preprocessar a string
        texts: list[str] = [""]
        placeholders: list[str] = []
        destiny = texts  # Começa preenchendo textos"

        for c in data:
            if c == '{':
                placeholders.append("")  # Inicia um novo placeholder
                destiny = placeholders  # Muda o destino para placeholders
            elif c == '}':
                texts.append("")  # Volta para o texto
                destiny = texts
            else:
                # Substitui \a e \b por < e >
                if c == '\a':
                    c = '{'
                elif c == '\b':
                    c = '}'
                # Adiciona o caractere ao destino atual
                destiny[-1] += c

        # Garantir que o tamanho dos textos e placeholders sejam iguais
        while len(texts) > len(placeholders):
            placeholders.append("")

        return texts, placeholders

    def __process_placeholders(self, text, *args) -> None:
        params = list(args)
        texts, placeholders = Text.__extract(text)
        while len(params) < len(placeholders):
            params.append("")
        # Aplicar a função fn aos placeholders e montar o resultado final
        for i in range(len(texts)):
            value = texts[i]
            self.add(value)
            
            fmt = placeholders[i]
            value = params[i]
            if fmt == "":
                self.add(value)
            else:
                self.addf(fmt, value)


class CheckVersion:

    link = "https://raw.githubusercontent.com/senapk/tko/master/src/tko/__init__.py"

    def __init__(self):
        self.version: str = __version__
        self.latest_version: Optional[str] = self.get_latest_version()

    def version_check(self):
        if self.latest_version is None:
            return
        if self.version != self.latest_version:
            major, minor, patch = [int(x) for x in self.version.split(".")]
            latest_major, latest_minor, latest_patch = [int(x) for x in self.latest_version.split(".")]
            if major < latest_major or (major == latest_major and minor < latest_minor) or (major == latest_major and minor == latest_minor and patch < latest_patch):
                print(f"Sua versão do  tko ({self.version}) está desatualizada.")
                print(f"A última versão é a {self.latest_version}.")
                print(Text.format("Se foi instalado via pipx, execute {y}.", "pipx upgrade tko"))

    def get_latest_version(self):
        try:
            with urlopen(self.link) as f:
                for line in f:
                    if b"__version__" in line:
                        return line.decode().split('"')[1]
        except:
            return None

class Flag:
    def __init__(self):
        self._name: str = ""
        self._text: str = ""  # description
        self._char: str = ""
        self._values: List[str] = ["0", "1"]
        self._index: int = 0
        self._location: str = ""
        self._bool = True  # many options

    def set_name(self, _name):
        self._name = _name
        return self

    def set_description(self, _text):
        self._text = _text
        return self

    def set_keycode(self, _key):
        self._char = _key
        return self

    def set_values(self, _values: List[str]):
        self._values = _values
        return self

    def index(self, _index):
        self._index = _index
        return self

    def get_values(self):
        return self._values

    def toggle(self):
        self._index = (self._index + 1) % len(self._values)
        return self

    def get_value(self) -> str:
        return self._values[self._index % len(self._values)]
    
    def set_value(self, value: Any):
        for i, v in enumerate(self._values):
            if v == value:
                self._index = i
                break

    def get_name(self) -> str:
        return self._name

    def get_description(self) -> str:
        return self._text

    def get_keycode(self) -> str:
        return self._char

    def get_index(self) -> int:
        return self._index
    
    def __bool__(self) -> bool:
        return self.get_value() == "1"
    

class Flags:
    minimum = Flag().set_name("Mínimo").set_keycode("M").set_values(["0", "1"])    .set_description("Mostra os requisitos para completar a missão")
    reward = Flag().set_name("Recompensa").set_keycode("R").set_values(["0", "1"]) .set_description("Mostra a experiência obtida nas tarefas     ")
    percent = Flag().set_name("Percentual").set_keycode("P").set_values(["1", "0"]).set_description("Mostra todos os valores em porcentagem      ")
    admin = Flag().set_name("Admin").set_keycode("A").set_values(["0", "1"])       .set_description("Habilitas todas as missões e tarefas        ")
    skills = Flag().set_name("Skills").set_keycode("S").set_values(["0", "1"]).set_description("Mostra a barra de skills")
    graph = Flag().set_name("Graph").set_keycode(GuiKeys.graph).set_values(["0", "1", "2"]).set_description("Muda o Gráfico")
    devel = Flag().set_name("Devel").set_values(["0", "1"])

class FlagsMan:
    def __init__(self, data: Dict[str, int]):
        self.flags: Dict[str, Flag] = {}

        for varname, flag in Flags.__dict__.items():
            if isinstance(flag, Flag):
                self.flags[varname] = flag

        for key, _index in data.items():
            if key in self.flags:
                self.flags[key].index(_index)

    def get_data(self) -> Dict[str, int]:
        data = {}
        for name, flag in self.flags.items():
            if len(flag.get_values()) > 1:
                data[name] = flag.get_index()
        return data

class FlagFunctor:
    def __init__(self, flag: Flag):
        self.flag = flag

    def __call__(self):
        self.flag.toggle()

class GradeFunctor:
    def __init__(self, grade: int, fn):
        self.grade = grade
        self.fn = fn

    def __call__(self):
        self.fn(self.grade)

class TextPosition:
    def __init__(self, y: int, x: int, text: Text):
        self.y = y
        self.x = x
        self.text = text

    def __str__(self):
        return f"{self.y}:{self.x}:{self.text}"
    
class TokenPosition:
    def __init__(self, y: int, x: int, token: Token):
        self.y = y
        self.x = x
        self.token = token

    def __str__(self):
        return f"{self.y}:{self.x}:{self.token}"

class Fmt:
    __scr = None
    # Definindo constantes para as cores
    color_pairs: Dict[str, int] = {}

    COLOR_MAP = {
        'k': curses.COLOR_BLACK,
        'r': curses.COLOR_RED,
        'g': curses.COLOR_GREEN,
        'y': curses.COLOR_YELLOW,
        'b': curses.COLOR_BLUE,
        'm': curses.COLOR_MAGENTA,
        'c': curses.COLOR_CYAN,
        'w': curses.COLOR_WHITE,
    }
    @staticmethod
    def set_scr(scr):
        Fmt.__scr = scr
        Fmt.init_colors()

    @staticmethod
    def init_colors():
        pair_number = 1
        curses.start_color()
        curses.use_default_colors()
        for fk, fg in Fmt.COLOR_MAP.items():
            curses.init_pair(pair_number, fg, -1)
            Fmt.color_pairs[fk] = pair_number
            pair_number += 1

        for fk, fg in Fmt.COLOR_MAP.items():
            for bk, bg in Fmt.COLOR_MAP.items():
                curses.init_pair(pair_number, fg, bg)
                Fmt.color_pairs[fk + bk.upper()] = pair_number
                pair_number += 1

    @staticmethod
    def stroke(y: int, x: int, fmt: str, text: str):
        if Fmt.__scr is None:
            raise Exception("Fmt.__scr não foi inicializado")
        stdscr = Fmt.__scr
        italic = False
        underline = False
        source_fmt = fmt
        if "/" in fmt:
            italic = True
            fmt = fmt.replace("/", "")
        if "_" in fmt:
            underline = True
            fmt = fmt.replace("_", "")

        fg_list = [c for c in fmt if c.islower()]
        bg_list = [c for c in fmt if c.isupper()]
        bg = "" if len(bg_list) == 0 else bg_list[0]
        fg = "" if len(fg_list) == 0 else fg_list[0]

        if bg != "" and fg == "":
            fg = "k"
        if fg == "" and bg == "":
            pair_number = -1
        else:
            try:
                pair_number = Fmt.color_pairs[fg + bg]
            except KeyError:
                # print("Cor não encontrada: " + fg + bg)
                raise(Exception("Cor não encontrada: " + source_fmt))
                exit(1)
        if italic:
            stdscr.attron(curses.A_ITALIC)
        if underline:
            stdscr.attron(curses.A_UNDERLINE)
        # Exibir o texto com a combinação de cores escolhida
        if pair_number != -1:
            stdscr.attron(curses.color_pair(pair_number))
        try:
            stdscr.addstr(y, x, text)
        except curses.error as _e:
            lines, cols = Fmt.get_size()
            if y == lines - 1:
                if x + len(text) <= cols:
                    pass
        except ValueError as _e:
            pass
            # lines, cols = stdscr.getmaxyx()
            # stdscr.addstr(10, 10, f"y:{y}, x:{x}, fmt:{fmt}, len:{len(text)} lines:{lines}, cols:{cols}")
            # stdscr.addstr(1, 0, text)
            # raise Exception(f"y:{y}, x:{x}, fmt:{fmt}, len:{len(text)} lines:{lines}, cols:{cols}\n{text}")
        if pair_number != -1:
            stdscr.attroff(curses.color_pair(pair_number))
        if italic:
            stdscr.attroff(curses.A_ITALIC)
        if underline:
            stdscr.attroff(curses.A_UNDERLINE)

    # break in lines and cut everything that is out of the box
    @staticmethod
    def cut_box(y: int, x: int, box_y: int, box_x: int, sentence: Text) -> list[TextPosition]:
        lines: list[Text] = sentence.split("\n")
        output: list[TextPosition] = []
        for line in lines:
            px = x
            if y < 0:
                y += 1
                continue
            if y >= box_y:
                break
            if px < 0:
                line.data = line.data[-px:]
                px = 0
            if px + len(line) > box_x:
                line.data = line.data[:box_x - px]
            output.append(TextPosition(y, px, line))
            y += 1
        return output

    @staticmethod
    def split_in_tokens(text_lines: list[TextPosition]) -> list[TokenPosition]:
        output: list[TokenPosition] = []
        for text_pos in text_lines:
            y = text_pos.y
            x = text_pos.x
            line = text_pos.text
            for token in line.resume():
                output.append(TokenPosition(y, x, token))
                x += len(token)
        return output

    @staticmethod
    def write(y: int, x: int, sentence: Text | str):
        if isinstance(sentence, str):
            data: Text = Text().add(sentence)
        else:
            data = sentence

        lines, cols = Fmt.get_size()
        text_lines = Fmt.cut_box(y, x, lines, cols, data)
        token_list = Fmt.split_in_tokens(text_lines)
        for token_pos in token_list:
            y = token_pos.y
            x = token_pos.x
            token = token_pos.token
            # print(f"y:{y}, x:{x}, fmt:{token.fmt}, len:{len(token.text)}")
            Fmt.stroke(y, x, token.fmt, token.text)

    # @staticmethod
    # def get_user_input(stdscr, prompt: str) -> str:
    #     lines, cols = stdscr.getmaxyx()
    #     curses.echo()  # Ativa a exibição dos caracteres digitados
    #     curses.curs_set(1)  # Ativa o cursor
    #     stdscr.addstr(0, 0, cols * " ")
    #     stdscr.addstr(0, 0, prompt)
    #     stdscr.refresh()
    #     input_str = stdscr.getstr(0, len(prompt), 20).decode('utf-8')  # Captura o input do usuário
    #     curses.noecho()  # Desativa a exibição dos caracteres digitados
    #     curses.curs_set(0)
    #     return input_str

    @staticmethod
    def get_percent(value, pad = 0) -> Text:
        text = f"{str(value)}%".rjust(pad)
        if value == 100:
            return Text().addf(Colors.mark_complete, "100%")
        if value >= 70:
            return Text().addf(Colors.mark_required, text)
        if value == 0:
            return Text().addf(Colors.mark_nothing, text)
        return Text().addf(Colors.mark_started, text)
    
    @staticmethod
    def get_screen() -> curses.window:
        if Fmt.__scr is None:
            raise Exception("Fmt.__scr não foi inicializado")
        return Fmt.__scr

    @staticmethod
    def getch():
        return Fmt.get_screen().getch()

    @staticmethod
    def clear():
        Fmt.get_screen().erase()

    @staticmethod
    def refresh():
        Fmt.get_screen().refresh()

    @staticmethod
    def get_size() -> Tuple[int, int]:
        return Fmt.get_screen().getmaxyx()
        

def test_fmt(scr):
    curses.curs_set(0)  # Esconde o cursor
    Fmt.init_colors()  # Inicializa as cores
    Fmt.set_scr(scr)  # Define o scr como global

    output = Text.format("..")
    for i in range(60):
        output.addf("r", str(i) + " ")
    for i in range(15):
        Fmt.write(i - 2, -1, output)
    scr.getch()



class Frame:
    def __init__(self, y: int = 0, x: int = 0):
        self._x = x
        self._y = y
        self._inner_dx = 0
        self._inner_dy = 0
        self._border = "rounded"
        self._filled = False
        self._header: Text = Text()
        self._halign = ""
        self._hprefix = ""
        self._hsuffix = ""
        self._footer: Text = Text()
        self._falign = ""
        self._fprefix = ""
        self._fsuffix = ""
        self._fill_char = " "
        self._wrap = False
        self._border_color = ""
        self._print_index = 0

    def set_border_color(self, color: str):
        self._border_color = color
        return self

    def get_dx(self):
        return self._inner_dx

    def get_dy(self):
        return self._inner_dy

    def get_x(self):
        return self._x

    def get_y(self):
        return self._y

    def __align_header_footer(self, data, symbol, prefix, suffix):
        dx = self._inner_dx
        color = self._border_color
        pad = dx - len(prefix) - len(suffix)
        hor = self.get_symbol("h")
        
        data.trim_end(pad)
        sent = Text().addf(color, prefix).add(data).addf(color, suffix)
        if symbol == "<":
            sent.ljust(dx, Token(hor, color))
        elif symbol == ">":
            sent.rjust(dx, Token(hor, color))
        else:
            sent.center(dx, Token(hor, color))
        return sent

    def get_header(self):
        return Text().add(self._hprefix).add(self._header).add(self._hsuffix)
    
    def get_footer(self):
        return Text().add(self._fprefix).add(self._footer).add(self._fsuffix)

    def get_full_header(self):
        return self.__align_header_footer(self._header, self._halign, self._hprefix, self._hsuffix)

    def get_full_footer(self):
        return self.__align_header_footer(self._footer, self._falign, self._fprefix, self._fsuffix)

    def set_pos(self, y: int, x: int):
        self._x = x
        self._y = y
        return self

    def set_size(self, size_y: int, size_x: int):
        self._inner_dx = size_x - 2
        self._inner_dy = size_y - 2
        return self

    def set_inner(self, inner_dy: int, inner_dx: int):
        self._inner_dy = inner_dy
        self._inner_dx = inner_dx
        return self

    def get_inner(self):
        return (self._inner_dy, self._inner_dx)

    def get_size(self):
        return self._inner_dy + 2, self._inner_dx + 2

    def set_end(self, y: int, x: int):
        self._inner_dx = x - self._x - 1
        self._inner_dy = y - self._y - 1
        return self

    def set_wrap(self):
        self._wrap = True
        return self

    def set_fill_char(self, char: str):
        self._fill_char = char
        return self

    def get_symbol(self, value: str):
        square = {"lu": "┌", "ru": "┐", "ld": "└", "rd": "┘", "h": "─", "v": "│"}
        rounded = {"lu": "╭", "ru": "╮", "ld": "╰", "rd": "╯", "h": "─", "v": "│"}
        bold = {"lu": "┏", "ru": "┓", "ld": "┗", "rd": "┛", "h": "━", "v": "┃"}

        if self._border == "square":
            return square[value]
        elif self._border == "rounded":
            return rounded[value]
        elif self._border == "bold":
            return bold[value]
        return " "

    def set_border_none(self):
        self._border = "none"
        return self

    def set_border_bold(self):
        self._border = "bold"
        return self

    def set_border_rounded(self):
        self._border = "rounded"
        return self

    def set_border_square(self):
        self._border = "square"
        return self

    def set_header(self, header: Text, align="<", prefix="", suffix=""):
        self._halign = align
        self._header = header
        self._hprefix = prefix
        self._hsuffix = suffix
        return self

    def set_footer(self, footer: Text, align=">", prefix="", suffix=""):
        self._falign = align
        self._footer = footer
        self._fprefix = prefix
        self._fsuffix = suffix
        return self

    def set_fill(self):
        self._filled = True
        return self

    def set_nofill(self):
        self._filled = False
        return self

    def print(self, x: int, sentence: Text):
        self.write(self._print_index, x, sentence)
        self._print_index += 1
        return self

    # return y, x of the last character
    def write(self, y: int, x: int, sentence: Text) -> bool:
        lines, cols = Fmt.get_size()

        x_min = max(-1, self._x)
        y_min = max(-1, self._y)
        x_max = min(cols, self._x + self._inner_dx)
        y_max = min(lines, self._y + self._inner_dy)

        x_abs = x + self._x + 1
        y_abs = y + self._y + 1

        if y_abs <= y_min or y_abs > y_max:
            return False
        count = 0
        for token in sentence.resume():
            fmt, text = token.fmt, token.text
            if x_abs - 1 < x_min:  # Se o texto começa fora do frame
                if x_abs + len(text) > x_min:  # mas ter parte dentro
                    text = text[x_min - x_abs + 1 :]
                    x_abs = x_min + 1
            if x_abs <= x_max:  # Se o texto começa dentro do frame
                if x_abs + len(text) >= x_max:
                    cut_point = x_max - x_abs + 1
                    text = text[:cut_point]

                Fmt.stroke(y_abs, x_abs, fmt, text)
                count += 1
            x_abs += len(text)
        return count != 0

    def draw(self):
        x = self._x
        y = self._y
        dx = self._inner_dx
        dy = self._inner_dy
        color = self._border_color
        up_left = self.get_symbol("lu")
        up_right = self.get_symbol("ru")
        down_left = self.get_symbol("ld")
        down_right = self.get_symbol("rd")
        hor = self.get_symbol("h")
        ver = self.get_symbol("v")

        header = self.get_full_header()
        footer = self.get_full_footer()

        above = Text().addf(color, up_left).add(header).addf(color, up_right)
        below = Text().addf(color, down_left).add(footer).addf(color, down_right)

        Fmt.write(y, x, above)
        if dy >= 0:
            Fmt.write(y + dy + 1, x, below)
        if self._filled:
            for i in range(1, dy + 1):
                Fmt.write(
                    y + i,
                    x,
                    Text()
                    .addf(color, ver)
                    .add(dx * self._fill_char)
                    .addf(color, ver),
                )
        else:
            for i in range(1, dy + 1):
                Fmt.write(y + i, x, Text().addf(color, ver))
                Fmt.write(y + i, x + dx + 1, Text().addf(color, ver))
        return self

class TreeItem:
    def __init__(self):
        self.sentence = Text()
        self.key = ""
        self.title = ""

    def get_key(self):
        return self.key

    def get_title(self):
        return self.title
    
    def get_sentence(self):
        return self.sentence


class RawTerminal:
    __term_width: Optional[int] = None

    def __init__(self):
        pass

    @staticmethod
    def __get_terminal_size() -> int:
        return shutil.get_terminal_size().columns

    @staticmethod
    def get_terminal_size():
        if RawTerminal.__term_width is None:
            return RawTerminal.__get_terminal_size()
        return RawTerminal.__term_width

    @staticmethod
    def set_terminal_size(value: int):
        RawTerminal.__term_width = value

    @staticmethod
    def centralize(text: Text | str, filler: Token | str = Token(" ")):
        if isinstance(filler, str):
            filler2: Token = Token(filler)
        else:
            filler2 = filler

        if isinstance(text, str):
            text2: Text = Text().add(text)
        else:
            text2 = text
        width = RawTerminal.get_terminal_size()
        return text2.center(width, filler2)
    

class __Symbols:

    def __init__(self):
        self.set_unicode()
        # self.set_ascii()

    def set_unicode(self):
        self.task_downloaded = Token("▼", "g")
        self.task_to_download = Token("▲")
        self.task_local = Token("▶", "g")
        self.task_to_visit = Token("◉", "b")
        self.opening = Token("=> ")
        self.neutral = Token("»")
        self.success = Token("✓")
        self.failure = Token("✗")
        self.wrong = Token("ω")
        self.compilation = Token("ϲ")
        self.execution = Token("ϵ")
        self.unequal = Token("├")
        self.equalbar = Token("│")
        self.hbar = Token("─")
        self.vbar = Token("│")

        self.whitespace = Token("·") #Token("␣")
        self.newline = Token("↲")

        self.cfill = Token("_")
        self.tab = Token("    ")
        self.arrow_up = Token("↑")

        self.check = Token("✓")
        self.uncheck = Token("✗")

        self.infinity = Token("∞")
        self.locked_free = Token("⇉")
        self.locked_locked = Token("⇟")
        self.left_toggle = Token("━─")
        self.right_toggle = Token("─━")
        self.timer = Token("⏳") #⏰
        self.diff_down = Token("↓")
        self.diff_left = Token("→")
        self.sharpR = Token("")
        self.sharpL = Token("")
        self.action = Token("◎", "b")

        # self.emoji_confiante = Token("●", "g")
        # self.emoji_capaz     = Token("◕", "y")
        # self.emoji_inseguro  = Token("◑", "m")
        # self.emoji_confuso   = Token("◔", "r")
        # self.emoji_nao_fiz   = Token("ⵔ")

        # self.emoji_confiante = Token("■", "g")
        # self.emoji_capaz     = Token("◨", "y")
        # self.emoji_inseguro  = Token("◧", "m")
        # self.emoji_confuso   = Token("◱", "r")
        # self.emoji_nao_fiz   = Token("□")

        self.autonomy_a = Token("▇", "g")
        self.autonomy_b = Token("▆", "y")
        self.autonomy_c = Token("▅", "m")
        self.autonomy_d = Token("▄", "r")
        self.autonomy_e = Token("▂", "c")
        self.autonomy_x = Token("▁", "")
        self.autonomy_list = [self.autonomy_x, self.autonomy_e, self.autonomy_d, self.autonomy_c, self.autonomy_b, self.autonomy_a]

        self.approach_a = Token("A", "g")
        self.approach_b = Token("B", "y")
        self.approach_c = Token("C", "m")
        self.approach_d = Token("D", "r")
        self.approach_e = Token("E", "c")
        self.approach_x = Token("x", "")
        self.approach_list = [self.approach_x, self.approach_e, self.approach_d, self.approach_c, self.approach_b, self.approach_a]
        
        self.cursor = Token("┊")

    # def set_ascii(self):
    #     self.task_downloaded = Token("D", "g")
    #     self.task_to_download = Token("X")
    #     self.task_local = Token(">", "g")
    #     self.task_to_visit = Token("◉", "b")
    #     self.whitespace = Token("¨")
    #     self.newline = Token("~")

    #     self.cfill = Token("_")
    #     self.tab = Token("    ")
    #     self.arrow_up = Token("|")

    #     self.check = Token("A")
    #     self.uncheck = Token("0")

    #     self.infinity = Token("0")
    #     self.locked_free = Token(">")
    #     self.locked_locked = Token("v")
    #     self.left_toggle = Token("━─")
    #     self.right_toggle = Token("─━")
    #     self.timer = Token("l")
    #     self.diff_down = Token("|")
    #     self.diff_left = Token("─")
    #     self.sharpR = Token("")
    #     self.sharpL = Token("")
    #     self.action = Token("◎", "b")

    #     self.emoji_vazio = Token("✗", "r")
    #     self.emoji_confiante = Token("A", "g")
    #     self.emoji_capaz     = Token("B", "y")
    #     self.emoji_inseguro  = Token("C", "m")
    #     self.emoji_confuso   = Token("D", "r")
    #     self.emoji_nao_fiz   = Token("E")

    #     self.emoji_alone = Token("A", "g")
    #     self.emoji_dicas = Token("B", "y")
    #     self.emoji_codes = Token("C", "m")
    #     self.emoji_guide = Token("D", "r")
    #     self.cursor = Token("|")

    def set_colors(self):
        self.opening.fmt = "b"
        self.neutral.fmt = "b"
        self.success.fmt = "g"
        self.failure.fmt = "r"
        self.wrong.fmt = "r"
        self.compilation.fmt = "y"
        self.execution.fmt = "y"
        self.unequal.fmt = "r"
        self.equalbar.fmt = "g"

symbols = __Symbols()

class Floating:
    def __init__(self, _align=""):
        self._frame = Frame(0, 0)
        self._content: List[Text] = []
        self._type = "warning"
        self._enable = True
        self._extra_exit: List[int] = []
        self._exit_fn = None
        self._exit_key = None
        self._centralize = True
        self._floating_align = _align

    def disable(self):
        self._enable = False

    def set_text_ljust(self):
        self._centralize = False
        return self

    def set_text_center(self):
        self._centralize = True
        return self

    def set_frame_align(self, _align: str):
        self._floating_align = _align
        return self

    def set_header(self, text: str):
        self._frame.set_header(Text().addf("/", text), "")
        return self
    
    def set_header_text(self, sentence: Text):
        self._frame.set_header(sentence, "")
        return self
    
    def set_footer(self, text: str):
        self._frame.set_footer(Text().addf("/", text), "")
        return self
    
    def set_footer_text(self, sentence: Text):
        self._frame.set_footer(sentence, "")
        return self
    
    def set_exit_key(self, key: str):
        self._exit_key = ord(key)
        return self

    def set_exit_fn(self, fn):
        self._exit_fn = fn
        return self

    def _set_xy(self, dy, dx):
        valid = "<>^v"
        for c in self._floating_align:
            if c not in valid:
                raise ValueError("Invalid align " + c)

        lines, cols = Fmt.get_size()

        x = (cols - dx) // 2
        if "<" in self._floating_align:
            x = 1
        elif ">" in self._floating_align:
            x = cols - dx - 3

        y = (lines - dy) // 2
        if "^" in self._floating_align:
            y = 1
        elif "v" in self._floating_align:
            y = lines - dy - 5

        self._frame.set_pos(y, x)
        return self
            
    def is_enable(self):
        return self._enable

    def calc_dy_dx(self):
        header_len = self._frame.get_header().len()
        footer_len = self._frame.get_footer().len()
        data = [x.len() for x in self._content] + [header_len, footer_len]
        max_dx = max(data)
        dx = max_dx
        dy = len(self._content)
        return dy, dx

    def setup_frame(self):
        dy, dx = self.calc_dy_dx()
        self._frame.set_inner(dy, dx)
        self._set_xy(dy, dx)
        self._frame.set_fill()

    def put_text(self, text: str):
        lines = text.splitlines()
        for line in lines:
            self._content.append(Text().add(line))
        return self

    def put_sentence(self, sentence: Text):
        for line in sentence.split('\n'):
            self._content.append(line)
        return self
    
    def set_content(self, content: List[str]):
        self._content = [Text().add(x) for x in content]
        return self

    def _set_default_footer(self):
        if self._frame.get_footer().len() == 0:
            label = Text().addf("/", " Pressione espaço ")
            self._frame.set_footer(label, "", "─", "─")
        return self

    def _set_default_header(self):
        if self._frame.get_header().len() == 0:
            if self._type == "warning":
                self.set_header(" Aviso ")
            elif self._type == "error":
                self.set_header(" Erro ")

    def warning(self):
        self._type = "warning"
        self._frame.set_border_color("y")
        return self
    
    def error(self):
        self._type = "error"
        self._frame.set_border_color("r")
        return self

    def draw(self):
        self._set_default_header()
        self._set_default_footer()
        self.setup_frame()
        self._frame.draw()
        self.write_content()

    def write_content(self):
        y = 0
        for line in self._content:
            x = 0
            if self._centralize:
                x = (self._frame.get_dx() - line.len()) // 2
            self._frame.write(y, x, line)
            y += 1
        return self

    def get_input(self) -> int:
        self.draw()
        key: int = Fmt.getch()
        key = InputManager.fix_cedilha(Fmt.get_screen(), key)
        if self._type == "warning" or self._type == "error":
            if key < 300:
                self._enable = False
                if self._exit_fn is not None:
                    self._exit_fn()
                if self._exit_key is not None:
                    return self._exit_key
                if key == ord(" ") or key == 27:
                    return -1
                return key
        
        return -1
        
class FloatingInputData:
    def __init__(self, label: Callable[[], Text], action: Callable[[], None], shortcut: str = ""):
        self.label = label
        self.action = action
        self.shortcut = shortcut
        self.exit_on_action = False


    def set_exit_on_action(self, value: bool):
        self.exit_on_action = value
        return self

class FloatingInput(Floating):
    def __init__(self, _align=""):
        super().__init__(_align)
        self._index = 0
        self._options: List[FloatingInputData] = []
        self._frame.set_border_color("m")
        self._exit_on_action = True
        self.right_dx = 5 # shortcut space
        self.search_text: List[str] = []

    def calc_dy_dx(self):
        dy, dx = super().calc_dy_dx()
        dy += len(self._options) + 2
        for option in self._options:
            dx = max(dx, len(option.label()))
        return dy, dx + self.right_dx
    
    def set_exit_on_enter(self, value: bool):
        self._exit_on_action = value
        return self

    def match_search(self, index: int):
        return "".join(self.search_text) in self._options[index].label().get_text().lower()

    def next_option(self):
        if not self.match_search(self._index):
            self._index = 0
        steps = len(self._options)
        index = self._index
        while steps > 0:
            index = (index + 1) % len(self._options)
            if self.match_search(index):
                self._index = index
                return
            steps -= 1
    
    def prev_option(self):
        if not self.match_search(self._index):
            self._index = 0
        steps = len(self._options)
        index = self._index
        while steps > 0:
            index = (index - 1) % len(self._options)
            if self.match_search(index):
                self._index = index
                return
            steps -= 1

    def write_content(self):
        options: List[Text] = []
        dx = self._frame.get_dx() - self.right_dx
        for i, option in enumerate(self._options):
            if not self.match_search(i):
                continue
            text = Text().add(option.label()).ljust(dx)
            if option.shortcut != "":
                if len(option.shortcut) > 1:
                    text.add(" " + option.shortcut)
                else:
                    text.add(f" [{option.shortcut}]")
            fmt = "M" if i == self._index else ""
            text.set_background(fmt)
            options.append(text)
        
        self._frame.write(0, 0, Text.format("Busca: ") + "".join(self.search_text) + symbols.cursor)
        y = 1
        for line in self._content + options:
            x = 0
            if self._centralize:
                x = (self._frame.get_dx() - line.len()) // 2
            self._frame.write(y, x, line)
            y += 1

        return self

    def set_options(self, options: List[FloatingInputData]):
        self._options = options
        return self
    
    def set_default_index(self, index: int):
        self._index = index
        return self

    def update_index(self):
        for i, _ in enumerate(self._options):
            if self.match_search(i):
                self._index = i
                return
        self._index = -1

    def get_input(self) -> int:
        self.draw()
        key: int = Fmt.getch()
        key = InputManager.fix_cedilha(Fmt.get_screen(), key)
        
        if key == curses.KEY_UP:
            self.prev_option()
        elif key == curses.KEY_DOWN:
            self.next_option()
        elif key == InputManager.esc:
            self._enable = False
        elif any([key == x for x in InputManager.backspace_list]) or key == InputManager.delete:
            self.search_text = self.search_text[:-1]
            self.update_index()
        elif key >= 32 and key < 127:
            self.search_text += chr(key).lower()
            self.update_index()
        elif key == ord('\n'):
            if self._exit_on_action or self._options[self._index].exit_on_action:
                self._enable = False
            if self._index != -1:
                self._options[self._index].action()
            return -1
        else:
            return key
        return -1


class FloatingManager:
    def __init__(self):
        self.input_layer: List[Floating] = []

    def add_input(self, floating: Floating):
        self.input_layer.append(floating)

    def draw_warnings(self):
        if len(self.input_layer) > 0 and self.input_layer[0].is_enable():
            self.input_layer[0].draw()

    def has_floating(self) -> bool:
        while len(self.input_layer) > 0 and not self.input_layer[0].is_enable():
            self.input_layer = self.input_layer[1:]
        return len(self.input_layer) > 0 and self.input_layer[0].is_enable()

    def get_input(self) -> int:
        return self.input_layer[0].get_input()



class Task(TreeItem):

    class Types(enum.Enum):
        UNDEFINED = 0
        VISITABLE_URL = 1
        STATIC_FILE = 2 # static folder inside database
        REMOTE_FILE = 3 # url link do download file
        IMPORT_FILE = 4 # source folder outside database to import files

        def __str__(self):
            return self.name

    def __init__(self):
        super().__init__()
        self.line_number = 0
        self.line = ""

        self.coverage: int = 0 # valor de 0 a 100
        self.autonomy: int = 0 # valor de 0 a 5
        self.skill: int = 0 # valor de 0 a 5
        self.main_idx: int = 0

        self.qskills: Dict[str, int] = {} # default quest skills
        self.skills: Dict[str, int] = {} # local skills
        self.xp: int = 0

        self.opt: bool = False
        
        self.link = ""
        self.link_type: Task.Types = Task.Types.UNDEFINED

        self.quest_key = ""
        self.cluster_key = ""

        self.folder: str | None = None # the place where are the test case file
        self.__is_reachable = False
        self.default_min_value = 7 # default min grade to complete task


    def set_reachable(self, reachable: bool):
        self.__is_reachable = reachable
        return self

    def is_reachable(self) -> bool:
        return self.__is_reachable

    def set_folder(self, folder: str):
        self.folder = folder
        return self
    
    def get_folder(self) -> str | None:
        return self.folder
    
    @staticmethod
    def decode_autonomy_skill(value: int) -> Tuple[int, int]:
        opts = [(0, 0), (1, 1), (1, 2), (2, 2), (3, 2), (1, 3), (2, 3), (3, 3), (4, 3), (3, 4), (4, 4)]
        autonomy = opts[value][0]
        skill = opts[value][1]
        return autonomy, skill

    def load_from_db(self, value: str):
        if value.startswith("{"):
            value_list = value[1:-1]
            key_values = value_list.split(",")
            for kv in key_values:
                k, val = kv.split(":")
                k = k.strip()
                val = val.strip()
                if k == "cov":
                    self.coverage = int(val)
                elif k == "aut":
                    self.autonomy = int(val)
                elif k == "hab":
                    self.skill = int(val)
                elif k == "idx":
                    self.main_idx = int(val)
        elif ":" not in value:
            self.autonomy, self.skill = Task.decode_autonomy_skill(int(value))
        else:
            v = value.split(":")
            if len(v) == 3:
                self.autonomy, self.skill = Task.decode_autonomy_skill(int(v[0]))
                self.main_idx = int(v[1])
                self.coverage = int(v[2])
            elif len(v) == 4:
                self.coverage = (int(v[0]))
                self.autonomy = (int(v[1]))
                self.skill    = (int(v[2]))
                self.main_idx = (int(v[3]))

    def save_to_db(self) -> str:
        return "{" + f"cov:{self.coverage}, aut:{self.autonomy}, hab:{self.skill}, idx:{self.main_idx}" + "}"
    
    def is_db_empty(self) -> bool:
        return self.autonomy == 0 and self.skill == 0 and self.main_idx == 0 and self.coverage == 0

    def get_prog_color(self, min_value: Optional[int] = None) -> str:
        if min_value is None:
            min_value = self.default_min_value
        prog = self.coverage // 10
        if prog == 0:
            return "c"
        if prog < min_value:
            return "r"
        if prog < 10:
            return "y"
        if prog == 10:
            return "g"
        return "w"  

    def get_prog_symbol(self, min_value: Optional[int] = None) -> Text:
        
        if min_value is None:
            min_value = self.default_min_value
        color = self.get_prog_color(min_value)
        prog = self.coverage // 10
        if prog == 0:
            return Text().add("x")
        if prog < min_value:
            return Text().addf(color, str(prog))
        if prog < 10:
            return Text().addf(color, str(prog))
        if prog == 10:
            return Text().addf(color, symbols.check.text)
        return Text().add("0")

    def get_percent(self):
        return (self.autonomy / 5) * (self.skill / 5) * self.coverage
    
    def get_ratio(self) -> float:
        return self.get_percent() / 10.0

    def is_complete(self):
        return self.get_percent() == 100

    def not_started(self):
        return self.get_percent() == 0
    
    def in_progress(self):
        return self.get_percent() > 0 and self.get_percent() < 100

    def set_coverage(self, coverage: int):
        coverage = int(coverage)
        if coverage >= 0 and coverage <= 100:
            self.coverage = coverage
        else:
            print(f"Progresso inválido: {coverage}")

    def set_autonomy(self, value: int):
        value = int(value)
        if value >= 0 and value <= 5:
            self.autonomy = value
        else:
            print(f"Autonomia inválida: {value}")

    def set_skill(self, value: int):
        value = int(value)
        if value >= 0 and value <= 5:
            self.skill = value
        else:
            print(f"Compreensão inválida: {value}")

    def __str__(self):
        lnum = str(self.line_number).rjust(3)
        key = "" if self.key == self.title else self.key + " "
        return f"{lnum} grade:{self.autonomy}:{self.skill} key:{key} title:{self.title} skills:{self.skills} remote:{self.link} type:{self.link_type} folder:{self.folder}"

    def has_at_symbol(self):
        return any([s.startswith("@") for s in self.title.split(" ")])

class LogInfo:
    def __init__(self):
        self.timestamp = ""
        self.type: str = LogAction.Type.NONE.value
        self.key = ""
        self.coverage: int = -1
        self.autonomy: int = -1
        self.skill: int = -1
        self.elapsed: datetime.timedelta = datetime.timedelta(0)
        self.attempts: int = 0

    def get_minutes(self) -> int:
        return int(self.elapsed.total_seconds() / 60)

    def set_timestamp(self, value: str):
        self.timestamp = value
        return self

    def set_type(self, value: str):
        self.type = value
        return self
    
    def set_key(self, value: str):
        self.key = value
        return self
    
    def set_attempts(self, value: int):
        self.attempts = value
        return self
    
    def set_coverage(self, value: int):
        self.coverage = value
        return self
    
    def set_autonomy(self, value: int):
        self.autonomy = value
        return self
    
    def set_skill(self, value: int):
        self.skill = value
        return self
    
    def set_elapsed(self, value: datetime.timedelta):
        self.elapsed = value
        return self
    
    def calc_and_set_elapsed(self, last: LogInfo, limit_minutes: int, format: str):
        last_time = datetime.datetime.strptime(last.timestamp, format)
        current_time = datetime.datetime.strptime(self.timestamp, format)
        diff = current_time - last_time
        if diff.total_seconds() < limit_minutes * 60:
            elapsed = last.elapsed + diff
        else:
            elapsed = last.elapsed
        self.elapsed = elapsed
        return self
        
    def to_dict(self) -> dict[str, str]:
        return {
            "type": self.type,
            "key": self.key,
            "coverage": str(self.coverage),
            "autonomy": str(self.autonomy),
            "skill": str(self.skill),
            "elapsed": str(int(self.elapsed.total_seconds() / 60)),
            "attempts": str(self.attempts)
        }

    def __str__(self) -> str:
        output = "{" + f'time:{self.timestamp}, type:{self.type}, key:{self.key}'
        if self.coverage != -1:
            output += f', c:{self.coverage}'
        if self.autonomy != -1:
            output += f', a:{self.autonomy}'
        if self.skill != -1:
            output += f', s:{self.skill}'
        if self.elapsed.total_seconds() > 0:
            minutes = int(self.elapsed.total_seconds() / 60)
            output += f', e:{minutes}'
        return output + "}"
    
    def decode(self, action: LogAction):
        self.timestamp = action.timestamp
        self.type = action.type_value
        self.key = action.task_key
        if action.type_value == LogAction.Type.TEST.value:
            self.load_from_test(action.payload)
        elif action.type_value == LogAction.Type.PROG.value:
            self.load_from_prog(action.payload)
        elif action.type_value == LogAction.Type.SELF.value:
            self.load_from_self(action.payload)

        return self

    def load_from_test(self, payload: str):
        try:
            self.coverage = int(payload)
        except:
            pass
    
    def load_from_prog(self, payload: str):
        self.coverage = int(payload)
        return
    
    def load_from_self(self, payload: str):
        if len(payload) == 1:
            self.autonomy, self.skill = Task.decode_autonomy_skill(int(payload))
            return
    
        if len(payload) == 2:
            self.autonomy = int(payload[0])
            self.skill = int(payload[1])
            return
        
        if len(payload) == 3 and payload[0] == "0":
            self.autonomy = int(payload[1])
            self.skill = int(payload[2])
            return
        
        if payload[0] == "{":
            payload = payload[1:-1]
            values = payload.split(",")
            kv = {}
            for svalue in values:
                k, v = svalue.split(":")
                kv[k.strip()] = v.strip()
            self.coverage = int(kv.get("c", -1))
            self.autonomy = int(kv.get("a", -1))
            self.skill = int(kv.get("s", -1))
            return
        
        raise Exception(f"Invalid SELF payload: {payload}")
            
    
        
class WeekData:
    def __init__(self, weed_day: str = "", elapsed: int = 0):
        self.weed_day = weed_day
        self.elapsed = elapsed

class WeekListener:
    def __init__(self):
        self.day_actions: dict[str, list[LogInfo]] = {}
        self.log_file: str | None = None
        self.format = '%Y-%m-%d %H:%M:%S'
        self.max_minutes = 60

    def listener(self, action: LogAction, new_entry: bool = False):
        decoder = LogInfo().decode(action)
        day = decoder.timestamp.split(" ")[0]

        if day not in self.day_actions:
            self.day_actions[day] = [decoder]
        else:
            last_action = self.day_actions[day][-1]
            decoder.calc_and_set_elapsed(last_action, self.max_minutes, self.format)
            self.day_actions[day].append(decoder)

    def set_task_file(self, value: str):
        self.log_file = value
        return self

    @staticmethod
    def next_day(day: str) -> str:
        date = datetime.datetime.strptime(day, '%Y-%m-%d')
        return (date + datetime.timedelta(days=1)).strftime('%Y-%m-%d')

    @staticmethod
    def week_day(day: str) -> str:
        date = datetime.datetime.strptime(day, '%Y-%m-%d')
        return date.strftime('%A')

    def resume(self):
        days = sorted(self.day_actions.keys())
        day = days[0]
        last = days[-1]
        while True:
            if day == last:
                break
            if day not in self.day_actions:
                self.day_actions[day] = []
            day = self.next_day(day)

        output: dict[str, WeekData] = {}
        for key in sorted(self.day_actions.keys()):
            entries = self.day_actions[key]
            elapsed = 0 if len(entries) == 0 else entries[-1].get_minutes()
            output[key] = WeekData(weed_day=self.week_day(key), elapsed=elapsed)
        return output
    
    def save_yaml(self):
        if self.log_file is None:
            return
        with open(self.log_file, 'w') as file:
            yaml.dump(self.day_actions, file)

class DailyListener:
    def __init__(self):
        self.history: dict[str, dict[str, TaskBasic]] = {} # dict[day, dict[key, [key, cov, how]]]
        self.actual: dict[str, TaskBasic] = {}
        self.daily_file: str | None
        
    def listener(self, action: LogAction, new_entry: bool = False):
        decoder = LogInfo().decode(action)
        types = [LogAction.Type.TEST.value, LogAction.Type.PROG.value, LogAction.Type.SELF.value]
        if decoder.type in types:
            self.log_task(decoder.timestamp, decoder.key, decoder.coverage, decoder.autonomy, decoder.skill)

    def set_daily_file(self, daily_file: str):
        self.daily_file = daily_file
        return self

    def log_task(self, timestamp: str, key: str, coverage: int = -1, autonomy: int = -1, skill: int = -1):
        if key not in self.actual:
            self.actual[key] = TaskBasic(key)
        self.actual[key].set_coverage(coverage).set_autonomy(autonomy).set_skill(skill)

        day = timestamp.split(" ")[0]
        if day not in self.history:
            self.history[day] = {}
        if key not in self.history[day]:
            self.history[day][key] = self.actual[key]
        else:
            self.history[day][key].set_coverage(coverage).set_autonomy(autonomy).set_skill(skill)
        # self.save_yaml()

    def __str__(self) -> str:
        output: dict[str, dict[str, str]] = {}
        for day in sorted(self.history.keys()):
            output[day] = {}
            for key in self.history[day]:
                output[day][key] = str(self.history[day][key])
        return yaml.dump(output)
    
    def save_yaml(self):
        if self.daily_file is None:
            return
        with open(self.daily_file, 'w') as file:
            file.write(str(self))




class FloatingGrade(Floating):
    def __init__(self, task: Task, _align=""):
        super().__init__(_align)
        self._task = task
        self._line = 0
        self.set_text_ljust()
        self._frame.set_border_color("g")
        self.set_header_text(Text.format("{y/}", " Utilize os direcionais para  marcar "))
        self.set_footer_text(Text.format("{y/}", " Pressione Enter para confirmar "))

        self.grades_index = [task.coverage // 10, task.autonomy, task.skill]
        self.coverage = ["x", "1", "2", "3", "4", "5", "6", "7", "8", "9", "✓"]
        self.coverage_msg = [
            "Não fiz",
            "Fiz 10%",
            "Fiz 20%",
            "Fiz 30%",
            "Fiz 40%",
            "Fiz 50%",
            "Fiz 60%",
            "Fiz 70%",
            "Fiz 80%",
            "Fiz 90%",
            "Fiz 100%"]
        self.approach = [x.text for x in [symbols.approach_x, symbols.approach_e, symbols.approach_d, symbols.approach_c, symbols.approach_b, symbols.approach_a]]
        self.approach_msg = [
            "Não fiz                                     ",
            "Copiei o código de um colega e estudei      ",
            "Fiz com ajuda de IA (copilot | gpt | outros)",
            "Fiz seguindo aula, vídeo, colega ou monitor ",
            "Criei os códigos, mas tirei pequenas dúvidas",
            "Fiz completamente sozinho e sem consulta    "
            ]
        self.autonomy = [x.text for x in [symbols.autonomy_x, symbols.autonomy_e, symbols.autonomy_d, symbols.autonomy_c, symbols.autonomy_b, symbols.autonomy_a]]
        self.autonomy_msg = [
            r"Consigo refazer menos de 30% sem consulta",
            r"Consigo refazer ao menos 30% sem consulta",
            r"Consigo refazer ao menos 50% sem consulta",
            r"Consigo refazer ao menos 70% sem consulta",
            r"Consigo refazer ao menos 90% sem consulta",
            r"Consigo refazer 100% sem consulta        "
            ]
        self.grades_value = [self.coverage, self.approach, self.autonomy]
        self.grades_msg = [self.coverage_msg, self.approach_msg, self.autonomy_msg]


    def update_content(self):
        self._content = []
        self._content.append(Text())
        self._content.append(Text().add("   Pontue de acordo com a última fez que você (re)fez a tarefa do zero"))
        self._content.append(Text())

        coverage_question = "Cobertura: Quanto entregou?"
        approach_question = "Abordagem: Como foi feito ?"
        autonomy_question = "Autonomia: Quanto domina  ?"

        coverage_text = Text().add(" ").addf("Y" if self._line == 0 else "", coverage_question).add("  ")
        for i, c in enumerate(self.coverage):
            coverage_text.addf("C" if i == self.grades_index[0] else "", c)
        coverage_text.add("  ").addf("m", self.coverage_msg[self.grades_index[0]])
        self._content.append(coverage_text)
        # self._content.append(Text())
        approach_text = Text().add(" ").addf("Y" if self._line == 1 else "", approach_question).add("  ")
        for i, c in enumerate(self.approach):
            approach_text.addf("G" if i == self.grades_index[1] else "", c).add(" ")
        approach_text.add(" ").addf("m", self.approach_msg[self.grades_index[1]])
        self._content.append(approach_text)
        # self._content.append(Text())
        autonomy_text = Text().add(" ").addf("Y" if self._line == 2 else "", autonomy_question).add("  ")
        for i, c in enumerate(self.autonomy):
            autonomy_text.addf("yW" if i == self.grades_index[2] else "", c).add(" ")
        autonomy_text.add(" ").addf("m", self.autonomy_msg[self.grades_index[2]])
        self._content.append(autonomy_text)
        self._content.append(Text())

    def draw(self):
        self._set_default_header()
        self._set_default_footer()
        self.setup_frame()
        self._frame.draw()
        self.update_content()
        self.write_content()

    def change_task(self):
        self._task.set_coverage(self.grades_index[0] * 10)
        self._task.set_autonomy(self.grades_index[1])
        self._task.set_skill(self.grades_index[2])

    def get_input(self) -> int:
        self.draw()
        key: int = Fmt.getch()
        key = InputManager.fix_cedilha(Fmt.get_screen(), key)
        if key == curses.KEY_UP or key == ord('w'):
            self._line = max(self._line - 1, 0)
        elif key == curses.KEY_DOWN or key == ord('s'):
            self._line = min(self._line + 1, 2)
        elif key == curses.KEY_LEFT or key == ord('a'):
            self.grades_index[self._line] = max(self.grades_index[self._line] - 1, 0)
            self.change_task()
        elif key == curses.KEY_RIGHT or key == ord('d'):
            self.grades_index[self._line] = min(self.grades_index[self._line] + 1, len(self.grades_value[self._line]) - 1)
            self.change_task()
        elif key == ord('\n') or key == curses.KEY_BACKSPACE or key == InputManager.esc:
            self._enable = False
            if self._exit_fn is not None:
                self._exit_fn()
        return -1


class TaskParser:

    def __init__(self, index_path: str, database_folder: str):
        self.index_path = os.path.abspath(index_path) # path of Repository Root Readme file
        self.database_folder = os.path.abspath(database_folder)
        self.task = Task()

    def __load_tags(self, tags_raw: str):
        task = self.task
        tags = [tag.strip() for tag in tags_raw.split(" ")]
        task.opt = "opt" in tags
        for t in tags:
            if t.startswith("+"):
                key, value = t[1:].split(":")
                task.skills[key] = int(value)

    def parse_line(self, line: str, line_num: int = 0) -> Task | None:
        pattern = r'\s*?- \[ \](.*?)\[([^\]]+)\]\(([^)]+)\)(?:\s*<!--(.*?)-->)?'

        match = re.match(pattern, line)
        if match is None:
            return None
        task = self.task
        task.line_number = line_num
        task.line = line
        task.title = match.group(1).strip()
        if task.title != "":
            task.title += " "
        task.title += match.group(2).strip()
        task.title = task.title.replace("`", "")

        if match.group(4) is not None:
            self.__load_tags(match.group(4))

        for item in task.title.split(" "):
            if item.startswith("@"):
                task.key = item[1:]
            elif item.startswith("#"):
                task.key = item[1:]
                task.link_type = Task.Types.VISITABLE_URL

        #remove last non alfa char from key
        allowed = "0123456789_abcdefghijklmnopqrstuvwxyz-ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        key = ""
        for c in task.key:
            if c in allowed:
                key += c
            else:
                break
        task.key = key

        link = match.group(3).strip()
        self.select_link_type(link)

        if task.key == "":
            task.key = link
        return task

    def select_link_type(self, link: str):
        task = self.task
        task.link = link

        if task.link_type == Task.Types.VISITABLE_URL:
            # open both url and files
            return

        if self.task.key == "":
            raise Warning(f"Chave não definida para tarefa: {link}")

        if link.startswith("http:") or link.startswith("https:"):
            task.set_folder(os.path.relpath(os.path.join(self.database_folder, task.key)))
            task.link_type = Task.Types.REMOTE_FILE
            return

        if not os.path.isabs(link):
            basedir = os.path.dirname(self.index_path)
            link = os.path.join(basedir, link)
            task.link = os.path.relpath(link)
        # verify if file exists
        # update link using index_path to update de relative path
        if not os.path.isfile(link):
            raise Warning(f"Arquivo não encontrado: {link}")

        # verify if file is inside database_folder/folder
        abs_task_folder = os.path.abspath(os.path.join(self.database_folder, task.key))
        task.set_folder(os.path.relpath(abs_task_folder))
        if link.startswith(abs_task_folder):
            task.link_type = Task.Types.STATIC_FILE
            return

        task.link_type = Task.Types.IMPORT_FILE
        return

class Quest(TreeItem):
    def __init__(self, title: str = "", key: str = ""):
        super().__init__()
        self.key = key
        self.title = title
        self.line_number = 0
        self.line = ""
        self.__tasks: List[Task] = []
        self.skills: Dict[str, int] = {}  # s:skill
        self.requires: List[str] = []  # r:quest_key
        self.requires_ptr: List[Quest] = []
        self.opt = False  # opt
        self.prog = False  # progressive tasks
        self.qmin: Optional[int] = None  # q:  minimo de 50 porcento da pontuação total para completar
        self.tmin: Optional[int] = None  # t: ou ter no mínimo esse valor de todas as tarefas
        self.filename = ""
        self.cluster_key = ""
        self.__is_reachable: bool = False

    def get_full_title(self):
        output = self.title
        if Flags.minimum:
            output += " " + self.get_requirement().get_text()
        if Flags.reward:
            xp = ""
            for s, v in self.skills.items():
                xp += f" +{s}:{v}"
            output += xp
        return output


    def is_reachable(self)-> bool:
        return self.__is_reachable

    def set_reachable(self, value: bool):
        self.__is_reachable = value
        return self
    
    def update_tasks_reachable(self):
        if not self.prog:
            for t in self.__tasks:
                t.set_reachable(True)
            return
        reach = True
        for i in range(len(self.__tasks)):
            if i == 0:
                self.__tasks[i].set_reachable(True)
            else:
                if self.__tasks[i-1].get_percent() < 50:
                    reach = False
                self.__tasks[i].set_reachable(reach)

    def __str__(self):
        line = str(self.line_number).rjust(3)
        tasks_size = str(len(self.__tasks)).rjust(2, "0")
        key = "" if self.key == self.title else self.key + " "
        output = f"{line} {tasks_size} {key}{self.title} {self.skills} {self.requires}"
        return output

    def get_resume_by_percent(self) -> Text:
        value = self.get_percent()
        return Text().addf(self.get_grade_color(), (str(value) + "%").rjust(4))
    
    def get_requirement(self) -> Text:
        if self.qmin is not None:
            return Text().addf("y", f"[{self.qmin}%]")
        if self.tmin is not None:
            return Text().addf("y", f"[t>{self.tmin - 1}]")
        return Text()

    def get_resume_by_tasks(self) -> Text:
        tmin = self.tmin if self.tmin is not None else 70
        total = len([t for t in self.__tasks if not t.opt])
        plus = len([t for t in self.__tasks if t.opt])
        count = len([t for t in self.__tasks if t.get_percent() >= tmin])
        output = f"{count}/{total}"
        if plus > 0:
            output += f"+{plus}"
        return Text().addf(self.get_grade_color(), "(" + output + ")")

    def get_grade_color(self) -> str:
        if self.not_started():
            return "m"
        if not self.is_complete():
            return "r"
        if self.get_percent() == 100:
            return "g"
        return "y"

    def is_complete(self):
        if self.qmin is not None:
            return self.get_percent() >= self.qmin
        # task complete mode
        if self.tmin is not None:
            for t in self.__tasks:
                if not t.opt and t.get_percent() < self.tmin:
                    return False
        return True

    def add_task(self, task: Task, filename: str):
        if self.qmin is not None:
            if task.opt:
                print(f"Quests com requerimento de porcentagem não deve ter Tasks opcionais")
                print(f"{filename}:{task.line_number} {task.key}")
                exit(1)
        task.qskills = self.skills

        task.xp = 0
        for s in task.skills:
            task.xp += task.skills[s]

        for s in task.qskills:
            task.xp += task.qskills[s]
        
        self.__tasks.append(task)

    def get_tasks(self):
        return self.__tasks

    def get_xp(self) -> Tuple[int, int]:
        total = 0
        obtained = 0
        for t in self.__tasks:
            total += t.xp
            if t.get_percent() > 0:
                obtained += int(t.xp * t.get_ratio())

        return obtained, total
        
    def get_percent(self):
        obtained, total = self.get_xp()
        if total == 0:
            return 0
        return obtained * 10 // total

    def in_progress(self):
        if self.is_complete():
            return False
        for t in self.__tasks:
            if t.get_percent() != 0:
                return True
        return False

    def not_started(self):
        if self.is_complete():
            return False
        if self.in_progress():
            return False
        return True


class QuestParser:
    quest: Quest

    def __init__(self):
        self.quest = Quest()
        self.line = ""
        self.line_num = 0
        self.default_qmin_requirement = 50
        self.default_task_xp = 10
        self.filename = ""

    def finish_quest(self) -> Quest:

        if self.quest.key == "":
            self.quest.key = get_md_link(self.quest.title)

        if len(self.quest.skills) == 0:
            self.quest.skills["xp"] = self.default_task_xp
        
        if self.quest.qmin is None and self.quest.tmin is None:
            self.quest.qmin = self.default_qmin_requirement

        return self.quest

    def match_full_pattern(self) -> bool:
        if not self.line.startswith("### "):
            return False
        line = self.line[4:]
        
        pieces: list[str] = line.split("<!--")

        # html tags
        if len(pieces) > 1:
            middle_end: list[str] = pieces[1].split("-->")
            middle: str = middle_end[0]
            end: str = middle_end[1]
            line = pieces[0] + end # removendo raw text
            self.process_raw_tags(middle)

        self.quest.title = line
        if "[](" in line:
            pieces = line.split("[](")
            self.quest.title = pieces[0]

            del pieces[0]
            for p in pieces:
                key = p.split(")")[0]
                if key[0] == "#":
                    key = key[1:]
                self.quest.requires.append(key)
 
        return True

    def process_raw_tags(self, raw_tags):
        tags = [tag.strip() for tag in raw_tags.split(" ")]

        # skills
        skills = [t[1:] for t in tags if t.startswith("+")]
        if len(skills) > 0:
            self.quest.skills = {}
            for s in skills:
                k, v = s.split(":")
                self.quest.skills[k] = int(v)
        self.quest.opt = "opt" in tags
        self.quest.prog = "prog" in tags

        # quest percent
        qmin = [t[2:] for t in tags if t.startswith("q:")]
        
        if len(qmin) > 0:
            self.quest.qmin = int(qmin[0])

        # task min value requirement
        tmin = [t[2:] for t in tags if t.startswith("t:")]
        if len(tmin) > 0:
            self.quest.tmin = int(tmin[0])
            if self.quest.tmin > 10:
                print("fail: tmin > 10")
                exit(1)


    def parse_quest(self, filename, line, line_num) -> Optional[Quest]:
        self.line = line
        self.line_num = line_num
        self.filename = filename

        self.quest.line = self.line
        self.quest.line_number = self.line_num
        self.quest.cluster_key = ""

        if self.match_full_pattern():
            return self.finish_quest()
                
        return None

class Cluster(TreeItem):
    def __init__(self, line_number: int = 0, title: str = "", key: str = "", color: Optional[str] = None):
        super().__init__()
        self.line_number = line_number
        self.__quests: List[Quest] = []
        self.color: Optional[str] = color
        self.__is_reachable = False
        self.key = key
        self.title = title

    def add_quest(self, quest: Quest):
        self.__quests.append(quest)
        return self

    def remove_empty_quests(self):
        self.__quests = [q for q in self.__quests if len(q.get_tasks()) > 0]
        return self

    def get_quests(self) -> List[Quest]:
        return self.__quests

    def is_reachable(self):
        return self.__is_reachable
    
    def set_reachable(self, value: bool):
        self.__is_reachable = value
        return self

    def __str__(self):
        line = str(self.line_number).rjust(3)
        quests_size = str(len(self.__quests)).rjust(2, "0")
        key = "" if self.key == self.title else self.key + " "
        return f"{line} {quests_size} {key}{self.title}"
    
    def get_grade_color(self) -> str:
        perc = self.get_percent()
        if perc == 0:
            return "m"
        if perc < 50:
            return "r"
        if perc < 100:
            return "y"
        return "g"

    def get_percent(self):
        total = 0
        for q in self.__quests:
            total += q.get_percent()
        return total // len(self.__quests)

    def get_resume_by_percent(self) -> Text:
        return Text().addf(self.get_grade_color(), f"{self.get_percent()}%".rjust(4))

    def get_resume_by_quests(self):
        total = len(self.__quests)
        count = len([q for q in self.__quests if q.is_complete()])
        return Text().addf(self.get_grade_color(), f"({count}/{total})")
        




class GameValidator:
    def __init__(self, filename: str, clusters: Dict[str, Cluster], 
                 quests: Dict[str, Quest], tasks: Dict[str, Task]):
        self.filename = filename
        self.clusters: Dict[str, Cluster] = clusters
        self.quests: Dict[str, Quest] = {}
        self.tasks: Dict[str, Task] = {}
        
    def validate(self):
        self.__validate_requirements()
        self.__check_cycle()
        return self

    def __validate_requirements(self):
        # verify is there are keys repeated between quests, tasks and groups
        keys = [c.key for c in self.clusters.values()] +\
               [k for k in self.quests.keys()] +\
               [k for k in self.tasks.keys()]

        # print chaves repetidas
        for k in keys:
            if keys.count(k) > 1:
                print(f"Chave repetida: {k}")
                exit(1)

        # trim titles
        for q in self.quests.values():
            q.title = q.title.strip()
        for c in self.clusters.values():
            c.title = c.title.strip()

        # verificar auto dependencia
        for q in self.quests.values():
            for r in q.requires:
                if q.key == r:
                    print(f"Erro: auto refência {q.line_number} {q.line}")
                    exit(1)


    # call after create_requirements_pointers
    def __check_cycle(self):
        def dfs(qx, visitedx):
            if len(visitedx) > 0:
                if visitedx[0] == qx.key:
                    print(f"Cycle detected: {visitedx}")
                    exit(1)
            if q.key in visitedx:
                return
            visitedx.append(q.key)
            for r in q.requires_ptr:
                dfs(r, visitedx)

        for q in self.quests.values():
            visited: List[str] = []
            dfs(q, visited)


class DiffBuilder:
    vinput    = " INSERIDO "
    vexpected = " ESPERADO "
    vreceived = " RECEBIDO "
    vunequal  = " DESIGUAL "

    def __init__(self, width: int):
        self.width = width
        self.curses = False

    def set_curses(self):
        self.curses = True
        return self

    @staticmethod
    def make_line_arrow_up(a: str, b: str) -> Text:
        hdiff = Text()
        first = True
        i = 0
        lim = max(len(a), len(b))
        while i < lim:
            if i >= len(a) or i >= len(b) or a[i] != b[i]:
                if first:
                    first = False
                    hdiff += symbols.arrow_up
                    return hdiff
            else:
                hdiff += " "
            i += 1
        while len(hdiff) < lim:
            hdiff += " "
        return hdiff

    @staticmethod
    def render_white(text: Text, color: str = "") -> Optional[Text]:
        out = Text().add(text).replace(' ', Token(symbols.whitespace.text, color)).replace('\n', Token(symbols.newline.text, color))
        return out

    def first_failure_diff(self, a_text: str, b_text: str | None, first_failure: int) -> List[Text]:
        if b_text is None:
            b_text = ""
        def get(vet, index):
            if index < len(vet):
                return DiffBuilder.render_white(vet[index])
            return ""

        a_render = a_text.splitlines(True)
        b_render = b_text.splitlines(True)
        first_a = get(a_render, first_failure)
        first_b = get(b_render, first_failure)
        out_a, out_b = DiffBuilder.colorize_2_lines_diff(Text().add(first_a), Text().add(first_b))
        if out_a is None:
            out_a = Text()
        if out_b is None:
            out_b = Text()
        greater = max(len(out_a), len(out_b))
        output: List[Text] = []
        width = self.width - 13
        output.append(Text().add(" ").add(out_a.ljust(greater)).trim_end(width).addf("g", " (esperado)"))
        output.append(Text().add(" ").add(out_b.ljust(greater)).trim_end(width).addf("r", " (recebido)"))
        diff = DiffBuilder.make_line_arrow_up(first_a, first_b)
        output.append(Text().add(" ").add(diff.ljust(greater)).trim_end(width).addf("b", " (primeiro)"))
        return output

    @staticmethod
    def colorize_2_lines_diff(la: Text | None, lb: Text | None, neut: str = "", exp: str = "g", rec: str = "r") -> Tuple[Text | None, Text | None]:
        pos = DiffBuilder.find_first_mismatch(la, lb)
        if la is not None:
            lat = la.get_text()
            la = Text().addf(neut, lat[0:pos]).addf(exp, lat[pos:])
        if lb is not None:
            lbt = lb.get_text()
            lb = Text().addf(neut, lbt[0:pos]).addf(rec, lbt[pos:])
        return la, lb

    @staticmethod
    def find_first_mismatch(line_a: Text | None, line_b: Text | None) -> int: 
        if line_a is None or line_b is None:
            return 0
        i = 0
        while i < len(line_a) and i < len(line_b):
            if line_a[i] != line_b[i]:
                return i
            i += 1
        return i

    # return a tuple of two strings with the diff and the index of the first mismatch line
    def render_diff(self, a_text: str, b_text: str | None) -> Tuple[List[Tuple[Text | None, Text | None]], int]:
        if b_text is None:
            b_text = ""
        a_lines = a_text.splitlines()
        b_lines = b_text.splitlines()
        output: list[tuple[Text | None, Text | None]] = []
        a_size = len(a_lines)
        b_size = len(b_lines)
        first_failure = -1
        max_size = max(a_size, b_size)

        # lambda function to return element in index i or empty if out of bounds
        def get(vet, index) -> Text | None:
            if index < len(vet):
                return Text().add(vet[index])
            return None
        
        expected_color = "g"
        received_color = "r" if a_text != "" else ""
        for i in range(max_size):
            a_data = get(a_lines, i)
            b_data = get(b_lines, i)
            if a_data is None or b_data is None or a_data != b_data:
                if first_failure == -1:
                    first_failure = i
                a_out, b_out = DiffBuilder.colorize_2_lines_diff(a_data, b_data, "y", expected_color, received_color)
                output.append((a_out, b_out))
            else:
                output.append((a_data, b_data))
        return output, first_failure
class LabelFactory:
    def __init__(self):
        self._label = ""
        self._index = -1

    def index(self, value: int):
        try:
            self._index = int(value)
        except ValueError:
            raise ValueError("Index on label must be a integer")
        return self

    def label(self, value: str):
        self._label = value
        return self

    def generate(self):
        label = LabelFactory.trim_spaces(self._label)
        label = LabelFactory.remove_old_index(label)
        if self._index != -1:
            index = str(self._index).zfill(2)
            if label != "":
                return index + " " + label
            else:
                return index
        return label

    @staticmethod
    def trim_spaces(text):
        parts = text.split(" ")
        parts = [word for word in parts if word != '']
        return " ".join(parts)

    @staticmethod
    def remove_old_index(label):
        split_label = label.split(" ")
        if len(split_label) > 0:
            try:
                int(split_label[0])
                return " ".join(split_label[1:])
            except ValueError:
                return label

class Runner:
    def __init__(self):
        pass

    @staticmethod
    def subprocess_run(cmd: str, input_data: str = "", timeout:Optional[float] = None, folder: str | None = None) -> Tuple[int, str, str]:
        try:
            answer = subprocess.run(cmd, cwd=folder, shell=True, input=input_data, stdout=PIPE, stderr=PIPE, text=True, timeout=timeout)
            err = ""
            if answer.returncode != 0:
                err = answer.stderr + Runner.decode_code(answer.returncode)
            # if running on windows
            if os.name == "nt":
                return answer.returncode, answer.stdout.encode("cp1252").decode("utf-8"), err
            return answer.returncode, answer.stdout, err
        except subprocess.TimeoutExpired:
            err = "fail: processo abortado depois de {} segundos".format(timeout)
            return 1, "", err

    @staticmethod
    def clear_screen():
        if os.name == 'nt':
            os.system('cls')
        else:
            os.system('clear')

    @staticmethod
    def decode_code(return_code: int) -> str:
        code = 128 - return_code
        if code == 127:
            return ""
        if code == 139:
            return "fail: segmentation fault"
        if code == 134:
            return "fail: runtime exception"
        return "fail: execution error code " + str(code)

# class Runner:

#     def __init__(self):
#         pass

#     @staticmethod
#     def subprocess_run(cmd_list: List[str], input_data: str = "") -> Tuple[int, Any, Any]:
#         try:
#             p = subprocess.Popen(cmd_list, stdout=PIPE, stdin=PIPE, stderr=PIPE, universal_newlines=True)
#             stdout, stderr = p.communicate(input=input_data)
#             return p.returncode, stdout, stderr
#         except FileNotFoundError:
#             print("\n\nCommand not found: " + " ".join(cmd_list))
#             exit(1)

def uni_to_asc(input_str: str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)])

class SearchAsc:
    def __init__(self, pattern: str):
        self.pattern = uni_to_asc(pattern.lower())

    def find(self, title: str) -> int:
        return uni_to_asc(title.lower()).find(self.pattern)
    
    def inside(self, title: str) -> bool:
        return self.find(title) != -1



class GameBuilder:
    def __init__(self, filename: str, database_folder: str):
        self.filename = filename
        self.database_folder = database_folder
        self.ordered_clusters: List[str] = [] # ordered clusters
        self.clusters: Dict[str, Cluster] = {}
        self.active_cluster: Cluster | None = None
        self.active_quest: Quest | None = None

    def build_from(self, content: str):
        self.__parse_file_content(content)
        self.__parse_database_for_user_tasks()
        self.__clear_empty()
        self.__create_requirements_pointers()
        self.__create_cross_references()
        return self

    def collect_tasks(self) -> dict[str, Task]:
        tasks: Dict[str, Task] = {}
        for cluster in self.clusters.values():
            for quest in cluster.get_quests():
                for task in quest.get_tasks():
                    tasks[task.key] = task
        return tasks

    def collect_quests(self) -> dict[str, Quest]:
        quests: Dict[str, Quest] = {}
        for cluster in self.clusters.values():
            for quest in cluster.get_quests():
                quests[quest.key] = quest
        return quests

    def __create_requirements_pointers(self):
        quests = self.collect_quests()
        # verificar se todas as quests requeridas existem e adicionar o ponteiro
        for q in quests.values():
            for r in q.requires:
                if r in quests:
                    q.requires_ptr.append(quests[r])
                else:
                    # print(f"keys: {self.quests.keys()}")
                    print(f"Quest\n{self.filename}:{q.line_number}\n{str(q)}\nrequer {r} que não existe")
                    exit(1)

    def __parse_database_for_user_tasks(self):
        folder = self.database_folder
        local_tasks_cluster: Cluster = Cluster(0, "Atividades Locais", "local_task_cluster")
        self.__add_cluster(local_tasks_cluster)
        tasks = self.collect_tasks()
        if not os.path.exists(folder):
            os.makedirs(folder)
        for entry in os.listdir(folder):
            path = os.path.join(folder, entry)
            if not os.path.isdir(path):
                continue
            if entry in tasks:
                continue
            # create task for folder
            task = Task()
            task.key = entry
            task.title = entry
            task.folder = path
            self.__add_task(task)

    def __parse_file_content(self, content: str):
        lines = content.splitlines()
        for line_num, line in enumerate(lines):
            cluster = self.__load_cluster(line, line_num)
            if cluster is not None:
                self.__add_cluster(cluster)
                continue
            
            quest = QuestParser().parse_quest(self.filename, line, line_num + 1)
            if quest is not None:
                self.__add_quest(quest)
                continue
            
            tp = TaskParser(self.filename, self.database_folder)
            task = tp.parse_line(line, line_num + 1)
            if task is not None:
                self.__add_task(task)

    def __get_active_cluster(self) -> Cluster:
        if self.active_cluster is None:
            raise Warning("Active Cluster Missing")
        return self.active_cluster

    def __get_active_quest(self) -> Quest:
        if self.active_quest is None:
            raise Warning("Active Quest Missing")
        return self.active_quest

    def __add_cluster(self, cluster: Cluster):
        self.clusters[cluster.key] = cluster
        self.ordered_clusters.append(cluster.key)
        self.active_cluster = cluster
        self.active_quest = None

    def __add_quest(self, quest: Quest):
        self.__get_active_cluster().add_quest(quest)
        self.active_quest = quest

    def __add_task(self, task: Task):
        if self.active_cluster is None:
            ckey = "sem_cluster"
            self.__add_cluster(Cluster(0, "Sem Cluster", ckey))
        if self.active_quest is None:
            qkey = self.__get_active_cluster().key + "_sem_quest"
            self.__add_quest(Quest("Sem Quest", qkey))
        self.__get_active_quest().add_task(task, self.filename)

    # se existir um cluster nessa linha, insere na lista de clusters e 
    # retorno o objeto cluster inserido
    def __load_cluster(self, line: str, line_num: int) -> None | Cluster:
        if not line.startswith("## "):
            return None
        line = line[3:]

        titulo = line
        tags_raw = ""
        if "<!--" in line:
            pieces = line.split("<!--")
            titulo = pieces[0]
            middle_end = pieces[1].split("-->")
            tags_raw = middle_end[0]
            titulo += middle_end[1]

        tags = [tag.strip() for tag in tags_raw.split(" ")]        
        key = uni_to_asc(get_md_link(titulo))
        try:
            color = [tag[2:] for tag in tags if tag.startswith("c:")][0]
        except IndexError as _e:
            color = None
        
        cluster = Cluster(line_num, titulo, key, color)

        if key in self.clusters.keys():
            c = self.clusters[key]
            print(f"Cluster {key} já existe")
            print(f"{self.filename}:{line_num}")
            print(f"{self.filename}:{c.line_number}")
            print("  " + str(c))
            print("  " + str(cluster))
            exit(1)
                
        self.clusters[key] = cluster
        self.ordered_clusters.append(key)
        return cluster

    def __clear_empty(self): #call before create_cross_references

        # apagando quests vazias da lista de quests
        for cluster in self.clusters.values():
            cluster.remove_empty_quests()

        # apagando quests vazias dos clusters e clusters vazios
        ordered_clusters: List[str] = []
        clusters: Dict[str, Cluster] = {}
        for key in self.ordered_clusters:
            cluster = self.clusters[key]
            if len(cluster.get_quests()) > 0:
                ordered_clusters.append(cluster.key)
                clusters[cluster.key] = cluster
        self.ordered_clusters = ordered_clusters
        self.clusters = clusters

    def __create_cross_references(self): #call after clear_empty
        for cluster in self.clusters.values():
            for quest in cluster.get_quests():
                quest.cluster_key = cluster.key
                for task in quest.get_tasks():
                    task.cluster_key = cluster.key
                    task.quest_key = quest.key


class ExecutionResult(enum.Enum):
    UNTESTED          = "não_verificado_"
    SUCCESS           = "saída_correta__"
    WRONG_OUTPUT      = "saída_incorreta"
    COMPILATION_ERROR = "erro_compilação"
    EXECUTION_ERROR   = "erro_execução__"

    @staticmethod
    def get_symbol(result) -> Token:
        if result == ExecutionResult.UNTESTED:
            return symbols.neutral
        elif result == ExecutionResult.SUCCESS:
            return symbols.success
        elif result == ExecutionResult.WRONG_OUTPUT:
            return symbols.wrong
        elif result == ExecutionResult.COMPILATION_ERROR:
            return symbols.compilation
        elif result == ExecutionResult.EXECUTION_ERROR:
            return symbols.execution
        else:
            raise ValueError("Invalid result type")

    def __str__(self):
        return self.value

class DiffMode(enum.Enum): # não mude os valores pois são utilizados no json
    SIDE = "side"
    DOWN = "down"

class DiffCount(enum.Enum):
    FIRST = "MODO: APENAS PRIMEIRO ERRO"
    ALL   = "MODO: TODOS OS ERROS"
    QUIET = "MODO: SILENCIOSO"


class IdentifierType(enum.Enum):
    OBI = "OBI"
    MD = "MD"
    TIO = "TIO"
    VPL = "VPL"
    SOLVER = "SOLVER"

class Success(enum.Enum):
    RANDOM = "RANDOM"
    FIXED = "FIXED"

class AppSettings:

    def __init__(self):
        self.diff_mode = DiffMode.SIDE.value
        self.show_hidden = False
        self.use_images = True
        self.use_borders = False
        self.editor = "code"
        self.timeout = 2

    def to_dict(self):
        return self.__dict__
    
    def from_dict(self, attr_dict):
        for key, value in attr_dict.items():
            if hasattr(self, key) and type(getattr(self, key)) == type(value):
                setattr(self, key, value)
        return self

    def toggle_diff(self):
        if self.diff_mode == DiffMode.SIDE.value:
            self.diff_mode = DiffMode.DOWN.value
        else:
            self.diff_mode = DiffMode.SIDE.value

    def toggle_borders(self):
        self.use_borders = not self.use_borders
    
    def toggle_images(self):
        self.use_images = not self.use_images
    
    def toggle_hidden(self):
        self.show_hidden = not self.show_hidden

    def set_diff_mode(self, diff_mode: DiffMode):
        self.diff_mode = diff_mode.value
        return self

    def set_show_hidden(self, show_hidden: bool):
        self.show_hidden = show_hidden
        return self

    def set_use_borders(self, borders: bool):
        self.use_borders = borders
        return self
    
    def set_use_images(self, images: bool):
        self.use_images = images
        return self

    def set_editor(self, editor: str):
        self.editor = editor
        return self

    def set_timeout(self, timeout: int):
        self.timeout = timeout
        return self

    def get_diff_mode(self) -> DiffMode:
        if self.diff_mode == DiffMode.SIDE.value:
            return DiffMode.SIDE
        return DiffMode.DOWN

    # def get_lang_default(self) -> str:
    #     return self._lang_default

    # def get_last_rep(self) -> str:
    #     return self._last_rep

    def get_show_hidden(self) -> bool:
        return self.show_hidden

    def get_use_images(self) -> bool:
        return self.use_images

    def get_use_borders(self) -> bool:
        return self.use_borders

    def get_editor(self) -> str:
        return self.editor

    def get_timeout(self) -> int:
        return self.timeout

    def __str__(self):
        output: list[str] = []
        output.append(str(Text.format("{g}", "Configurações globais:")))
        output.append("- Diff    : {}".format(str(self.get_diff_mode().value)))
        output.append("- Editor  : {}".format(self.get_editor()))
        output.append("- Bordas  : {}".format(self.get_use_borders()))
        output.append("- Images  : {}".format(self.get_use_images()))
        output.append("- Timeout : {}".format(self.get_timeout()))
        return "\n".join(output)

class Border:
    def __init__(self, app: AppSettings):
        self.app = app

    def has_borders(self):
        return self.app.get_use_borders()

    def border(self, color: str, data: str):
        return Text().add(self.roundL(color)).addf(color, data).add(self.roundR(color))

    def border_sharp(self, color: str, data: str):
        return Text().add(self.sharpL(color)).addf(color, data).add(self.sharpR(color))

    def roundL(self, color: str) -> Token:
        return Token("", color.lower()) if self.has_borders() else Token(" ", color)

    def roundR(self, color: str) -> Token:
        return Token("", color.lower()) if self.has_borders() else Token(" ", color)

    def sharpL(self, color: str) -> Token:
        return Token("", color.lower()) if self.has_borders() else Token(" ", color)

    def sharpR(self, color: str):
        return Token("", color.lower()) if self.has_borders() else Token(" ", color)

    def build_bar(self, text: str, percent: float, length: int, fmt_true: str = "/kC",
                  fmt_false: str = "/kY", round=True) -> Text:
        if round and (len(text) >= length - 2):
            text = " " + text

        if length > len(text):
            prefix = (length - len(text)) // 2
            suffix = length - len(text) - prefix
            text = " " * prefix + text + " " * suffix
        elif length < len(text):
            text = text[:length]
        
        full_line = text
        done_len = int(percent * length)
        xp_bar = Token(full_line[:done_len], fmt_true) + Token(full_line[done_len:], fmt_false)
            
        if round:
            xp_bar.data[0] = self.roundL(xp_bar.data[0].fmt)
            xp_bar.data[-1] = self.roundR(xp_bar.data[-1].fmt)
        return xp_bar

    def get_flag_sentence(self, flag: Flag, pad: int = 0, button_mode: bool = True, include_symbol: bool = True, include_key: bool = True) -> Text:
        char = flag.get_keycode()
        text = flag.get_name()
        color = "M" 
        symbol = symbols.neutral
        if len(flag.get_values()) > 0:
            color = "G" if flag else "Y"
            symbol = symbols.success if flag else symbols.failure
        if not button_mode:
            color = color.lower()
        extra = Text()
        filler = " "
        if pad > 2:
            extra.addf(color, (pad - 2 - len(text)) * filler)

        mid = Text()
        if include_symbol:
            mid.addf(color, symbol.text).addf(color, " ")
        mid.addf(color, text)
        if include_key:
            mid.add(extra).addf(color, f"[{char}]")
        if button_mode:
            middle = Text().add(self.roundL(color)).add(mid).add(self.roundR(color))
        else:
            middle = Text().add(" ").add(mid).add(" ")
        return middle

class Unit:
    def __init__(self, case: str = "", input_data: str = "", expected: str = "", grade: Optional[int] = None, source: str = ""):
        self.source = source  # stores the source file of the unit
        self.source_pad = 0  # stores the pad to justify the source file
        self.case = case  # name
        self.case_pad = 0  # stores the pad to justify the case name
        self.inserted = input_data  # input
        self.expected = expected  # expected output
        self.received: Optional[str] = None  # solver generated answer
        self.grade: Optional[int] = grade  # None represents proportional gr, 100 represents all
        self.grade_reduction: int = 0  # if grade is None, this atribute should be filled with the right grade reduction
        self.index = 0
        self.repeated: Optional[int] = None

        self.result: ExecutionResult = ExecutionResult.UNTESTED

    def str(self, pad: bool = True) -> Text:
        index = str(self.index).zfill(2)
        grade = str(self.grade_reduction).zfill(3)
        rep = "" if self.repeated is None else " [" + str(self.repeated) + "]"
        op = Text() + ExecutionResult.get_symbol(self.result) + " " + self.result.value
        source = os.path.basename(self.source)
        if pad:
            source = self.source.ljust(self.source_pad)
        case = self.case
        if pad:
            case = self.case.ljust(self.case_pad)
        return Text() + "(" + op + ")" + f"[{index}] GR:{grade} {source} ({case}){rep}"




class DownDiff:
    def __init__(self, width: int, unit: Unit):
        self.width = width
        self.curses = False
        self.db = DiffBuilder(width)
        self.unit = unit
        self.output: List[Text] = []
        self.__to_insert_header = False
        self.no_diff_mode = self.unit.inserted == "" and self.unit.expected == ""
        self.expected_received, self.first_failure = self.db.render_diff(self.unit.expected, self.unit.received)

    def to_insert_header(self):
        self.__to_insert_header = True
        return self

    def set_curses(self):
        self.curses = True
        return self

    @staticmethod
    def put_left_equal(exp_rec_list: List[Tuple[Text | None, Text | None]], unequal: Token = symbols.unequal):

        output: List[Tuple[Text, Text]] = []
        for exp, rec in exp_rec_list:
            if exp is None or rec is None or exp != rec:
                exp_lines = Text() + unequal + " " + exp
                rec_lines = Text() + unequal + " " + rec
            else:
                exp_lines = Text() + symbols.vbar + " " + exp
                rec_lines = Text() + symbols.vbar + " " + rec
            output.append((exp_lines, rec_lines))
        return output

    def insert_header(self):
        self.output.append(Text().fold_in(self.width, symbols.hbar, "╭", "╮"))
        self.output.append(self.unit.str().fold_in(self.width, " ", symbols.vbar, symbols.vbar))

    def insert_input(self):
        color = "g" if self.unit.expected == self.unit.received else "b"
        # header
        if self.__to_insert_header:
            self.output.append(Text().addf(color, DiffBuilder.vinput).fold_in(self.width, symbols.hbar, "├", "┤"))
        else:
            self.output.append(Text().addf(color, DiffBuilder.vinput).fold_in(self.width, symbols.hbar, "╭", "╮"))
        # lines
        for line in self.unit.inserted.splitlines():
            self.output.append(Text().add(symbols.vbar).add(" ").add(line).ljust(self.width - 1, Token(" ")).add(symbols.vbar))

    def insert_expected(self):
        if self.no_diff_mode:
            return
        # color = "g" if self.unit.expected == self.unit.received else "b"
        # self.output.append(Text().addf(color, DiffBuilder.vreceived).fold_in(self.width, symbols.hbar, "╭", "╮"))
        if self.unit.expected == "":
            return
        self.output.append(Text().addf("g", DiffBuilder.vexpected).fold_in(self.width, symbols.hbar, "├", "┤"))
        for line, _ in self.expected_received:
            if line is not None:
                self.output.append(line.ljust(self.width - 1, Token(" ")).add(symbols.vbar))

    def insert_received(self):
        # headers
        color = "r" if self.unit.expected == self.unit.received else "g"
        if self.no_diff_mode:
            color = "g"
            self.output.append(Text().addf(color, DiffBuilder.vreceived).fold_in(self.width, symbols.hbar, "╭", "╮"))
        else:
            self.output.append(Text().addf(color, DiffBuilder.vreceived).fold_in(self.width, symbols.hbar, "├", "┤"))

        # lines
        for _, line in self.expected_received:
            if line is not None:
                self.output.append(line.ljust(self.width - 1, Token(" ")).trim_end(self.width).add(symbols.vbar))

    def insert_first_line_diff(self):
        include_rendering = False
        if self.unit.expected != self.unit.received and self.unit.expected != "":
            include_rendering = True
        if self.unit.result == ExecutionResult.EXECUTION_ERROR or self.unit.result == ExecutionResult.COMPILATION_ERROR:
            include_rendering = False

        if not include_rendering:
            return
        self.output.append(Text().addf("b", DiffBuilder.vunequal).fold_in(self.width, symbols.hbar, "├", "┤"))
        for line in self.db.first_failure_diff(self.unit.expected, self.unit.received, self.first_failure):
            self.output.append(Text().add("│").add(line).ljust(self.width - 1, Token(" ")).add("│"))

    def end_frame(self):
        self.output.append(Text().fold_in(self.width, symbols.hbar, "╰", "╯"))

    def build_diff(self) -> List[Text]:
        if self.__to_insert_header:
            self.insert_header()
        if not self.no_diff_mode:
            self.insert_input()
        symb = symbols.unequal
        if self.unit.result == ExecutionResult.EXECUTION_ERROR or self.unit.result == ExecutionResult.COMPILATION_ERROR or self.unit.expected == "":
            symb = symbols.vbar
        self.expected_received = self.put_left_equal(self.expected_received, symb)
        self.insert_expected()
        self.insert_received()
        self.insert_first_line_diff()
        self.end_frame()

        return self.output




class SideDiff:
    def __init__(self, width: int, unit: Unit):
        self.width = width
        self.curses = False
        self.db = DiffBuilder(width)
        self.unit: Unit = unit
        self.output: List[Text] = []
        self.__to_insert_header = False
        self.expected_received, self.first_failure = self.db.render_diff(self.unit.expected, self.unit.received)

    def set_curses(self):
        self.curses = True
        return self

    def split_screen(self, a: Text | None, b: Text | None, unequal: Token = symbols.vbar) -> Text:
        avaliable = self.width - 7 # 2 spaces before, 2 spaces after, 3 between
        cut = avaliable // 2
        if a is None or b is None or a != b:
            symb = unequal
        else:
            symb = symbols.vbar
        ta = Text() + a
        tb = Text() + b
        ta = ta.ljust(cut, Token(" ")).trim_end(cut)
        tb = tb.ljust(cut, Token(" ")).trim_end(cut)
        line = symb + " " + ta + " " + symb + " " + tb + " "
        if self.width % 2 == 0:
            line += " "
        return line + symbols.vbar

    def title_side_by_side(self, left: Text, right: Text, filler: Token = Token(" "), middle: Token = Token(" "), prefix: Token = Token(), posfix: Token = Token()) -> Text:
        avaliable = self.width - len(prefix) - len(posfix) - len(middle)
        half = avaliable // 2
        line = Text() + prefix

        a = left
        a = a.center(half, filler)
        if len(a) > half:
            a = a.trim_end(half)
        line += a
        line += middle
        b = right
        b = b.center(half, filler)
        if len(b) > half:
            b = b.trim_end(half)
        line += b
        if self.width % 2 == 0:
            line += filler
        line += posfix
        return line

    def to_insert_header(self, value: bool):
        self.__to_insert_header = value
        return self

    def _insert_header(self):
        self.output.append(Text().fold_in(self.width, symbols.hbar, "╭", "╮"))
        self.output.append(self.unit.str().fold_in(self.width, " ", "│", "│"))

    def _insert_input(self):
        # input header
        input_color = "b" if self.unit.expected != self.unit.received else "g"
        input_headera = Text().addf(input_color, DiffBuilder.vinput)
        input_headerb = Text().addf(input_color, DiffBuilder.vinput)
        if self.__to_insert_header:
            self.output.append(self.title_side_by_side(input_headera, input_headerb, symbols.hbar, Token("┬"), Token("├"), Token("┤")))
        else:
            self.output.append(Text().addf(input_color, DiffBuilder.vinput).fold_in(self.width, symbols.hbar, "╭", "╮"))

        # input lines
        if self.unit.inserted != "":
            lines = [Text().add(x) for x in self.unit.inserted.splitlines()]
            for l in lines:
                self.output.append(self.split_screen(l, l))
    
    def _insert_expected_received(self):
        # expected and received header
        expected_header = Text().addf("g", DiffBuilder.vexpected)
        rcolor = "r" if self.unit.expected != self.unit.received else "g"
        received_header = Text().addf(rcolor, DiffBuilder.vreceived)
        self.output.append(self.title_side_by_side(expected_header, received_header, symbols.hbar, Token("┼"), Token("├"), Token("┤")))
        # expected and received lines
        symbol = symbols.unequal
        if self.unit.result == ExecutionResult.EXECUTION_ERROR or self.unit.result == ExecutionResult.COMPILATION_ERROR:
            symbol = symbols.vbar
        for exp, rec in self.expected_received:
            self.output.append(self.split_screen(exp, rec, symbol))

    def _insert_first_line_diff(self):
        self.output.append(Text().addf("b", DiffBuilder.vunequal).fold_in(self.width, symbols.hbar, "├", "┤"))
        for line in self.db.first_failure_diff(self.unit.expected, self.unit.received, self.first_failure):
            width = self.width - 1
            self.output.append(Text().add("│").add(line).ljust(width, Token(" ")).add("│"))
        
    def _finish(self):
        self.output.append(Text().fold_in(self.width, symbols.hbar, "╰", "╯"))

    def build_diff(self) -> List[Text]:
        self.output = []
        if self.__to_insert_header:
            self._insert_header()
        self._insert_input()
        self._insert_expected_received()
        self._insert_first_line_diff()
        self._finish()
        
        return self.output

class Param:

    def __init__(self):
        pass

    class Basic:
        def __init__(self):
            self.index: Optional[int] = None
            self.label_pattern: Optional[str] = None
            self.diff_mode = DiffMode.SIDE
            self.diff_count = DiffCount.FIRST
            self.filter: bool = False
            self.compact: bool = False

        def set_index(self, value: Optional[int]):
            self.index= value
            return self

        def set_label_pattern(self, label_pattern: Optional[str]):
            self.label_pattern = label_pattern
            return self
        
        def set_compact(self, value: bool):
            self.compact = value
            return self

        def set_diff_mode(self, value: DiffMode):
            self.diff_mode = value
            return self
    
        def set_filter(self, value: bool):
            self.filter = value
            return self

        def set_diff_count(self, value: DiffCount):
            self.diff_count = value
            return self

    class Manip:
        def __init__(self):
            self.unlabel: bool = False
            self.to_sort: bool = False
            self.to_number: bool = False
        
        def set_unlabel(self, value: bool):
            self.unlabel = value
            return self
        
        def set_to_sort(self, value: bool):
            self.to_sort = value
            return self
        
        def set_to_number(self, value: bool):
            self.to_number = value
            return self


class Identifier:
    def __init__(self):
        pass

    @staticmethod
    def get_type(target: str) -> IdentifierType:
        if os.path.isdir(target):
            return IdentifierType.OBI
        elif target.endswith(".md"):
            return IdentifierType.MD
        elif target.endswith(".tio"):
            return IdentifierType.TIO
        elif target.endswith(".vpl") or target.endswith(".cases"):
            return IdentifierType.VPL
        else:
            return IdentifierType.SOLVER
# ignore missing import 

class Decoder:

    @staticmethod
    def load(file_path: str) -> str:
        if not os.path.exists(file_path):

            raise Exception("Arquivo {} não encontrado".format(os.path.abspath(file_path)))
        with open(file_path, "rb") as file:
            raw_data = file.read()
            enc_dict = chardet.detect(raw_data)
            encoding = enc_dict["encoding"]
            if encoding is None or enc_dict["confidence"] < 0.90:
                encoding = "utf-8"
            try:
                content = raw_data.decode(encoding)
            except UnicodeDecodeError as e:
                content = raw_data.decode(enc_dict["encoding"])
            return content.replace('\r\n', '\n')

    @staticmethod
    def save(file_path: str, content: str):
        base_path = os.path.dirname(file_path)
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(file_path, "w", encoding="utf-8", newline='\n') as file:
            file.write(content)

    @staticmethod
    def get_encoding(file_path: str) -> str:
        with open(file_path, "rb") as file:
            raw_data = file.read()
            enc_dict = chardet.detect(raw_data)
            encoding = enc_dict["encoding"]
            if encoding is None or enc_dict["confidence"] < 0.90:
                encoding = "utf-8"
            return encoding


def singleton(class_):
    instances = {}
    def getinstance(*args, **kwargs):
        if class_ not in instances:
            instances[class_] = class_(*args, **kwargs)
        return instances[class_]
    return getinstance

@singleton
class Settings:
    CFG_FILE = "settings.yaml"


    def __init__(self):
        self.__remote = "remote"
        self.__appcfg = "appcfg"
        self.__colors = "colors"

        self.dict_alias_remote: Dict[str, str] = {}
        self.app = AppSettings()
        self.colors = Colors()

        self.settings_file = ""

    def set_settings_file(self, path: str):
        self.settings_file = path
        return self

    def get_settings_file(self) -> str:
        if self.settings_file is None or self.settings_file == "":
            self.package_name = "tko"
            default_filename = self.CFG_FILE
        
        if not os.path.exists(self.settings_file):
            os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)
        return self.settings_file

    def reset(self):
        self.dict_alias_remote = {}
        self.dict_alias_remote["fup"] = "https://github.com/qxcodefup/arcade/blob/master/Readme.md"
        self.dict_alias_remote["ed"] = "https://github.com/qxcodeed/arcade/blob/master/Readme.md"
        self.dict_alias_remote["poo"] = "https://github.com/qxcodepoo/arcade/blob/master/Readme.md"

        self.app = AppSettings()
        self.colors = Colors()
        return self

    def set_alias_remote(self, alias: str, url_or_path: str):
        if not(url_or_path.startswith("http:") or url_or_path.startswith("https:")):
            url_or_path = os.path.abspath(url_or_path)
        self.dict_alias_remote[alias] = url_or_path
        return self

    def has_alias_remote(self, alias: str) -> bool:
        return alias in self.dict_alias_remote

    def get_alias_remote(self, alias: str) -> str:
        if alias in self.dict_alias_remote:
            return self.dict_alias_remote[alias]
        raise Warning(f"Repositório remoto {alias} não encontrado")
    
    def load_settings(self):
        try:
            settings_file = self.get_settings_file() # assure right loading if value == ""
            encoding = Decoder.get_encoding(settings_file)
            with open(settings_file, "r", encoding=encoding) as f:
                data = yaml.safe_load(f)
                self.dict_alias_remote = data.get(self.__remote, {})
                self.app = AppSettings().from_dict(data.get(self.__appcfg, {}))
                self.colors = Colors().from_dict(data.get(self.__colors, {}))
        except (FileNotFoundError, yaml.YAMLError) as e:
            self.reset()
            self.save_settings()
        return self
    
    def save_settings(self):
        file = self.get_settings_file()
        value = {
            self.__remote: self.dict_alias_remote,
            self.__appcfg: self.app.to_dict(),
            self.__colors: self.colors.to_dict()
        }
        with open(file, "w", encoding="utf-8") as f:
            yaml.dump(value, f)
        return self

    def __str__(self):
        output = []
        output.append(str(Text.format("{g}", "Arquivo de configuração:")))
        output.append("- " + self.get_settings_file())
        output.append("")
        output.append(str(Text.format("{g}", "Repositórios remotos cadastrados:")))
        max_alias = max([len(key) for key in self.dict_alias_remote])
        for key in self.dict_alias_remote:
            output.append("- {} : {}".format(key.ljust(max_alias), self.dict_alias_remote[key]))
        output.append("")
        
        app_str = str(self.app)
        return "\n".join(output) + "\n\n" + app_str
        
class TaskListener:
    def __init__(self):
        self.key_actions: dict[str, list[LogInfo]] = {}
        self.log_file: str | None = None
        self.format = '%Y-%m-%d %H:%M:%S'
        self.max_minutes = 60

    def listener(self, action: LogAction, new_entry: bool = False):
        decoder = LogInfo().decode(action)
        if decoder.key == "":
            return
        if decoder.key not in self.key_actions:
            self.key_actions[decoder.key] = [decoder]
        else:
            last_action = self.key_actions[decoder.key][-1]
            last_time = datetime.datetime.strptime(last_action.timestamp, self.format)
            current_time = datetime.datetime.strptime(decoder.timestamp, self.format)
            diff = current_time - last_time
            if diff.total_seconds() < self.max_minutes * 60:
                elapsed = last_action.elapsed + diff
            else:
                elapsed = last_action.elapsed
            decoder.elapsed = elapsed
            self.key_actions[decoder.key].append(decoder)
        # self.save_yaml()

    def set_task_file(self, value: str):
        self.log_file = value
        return self
    
    def __str__(self) -> str: # yaml formatted output of key_actions
        output: dict[str, list[str]] = {}
        for key in sorted(self.key_actions.keys()):
            output[key] = []
            for action in self.key_actions[key]:
                output[key].append(str(action))
        return yaml.dump(output)

    def resume(self) -> dict[str, LogInfo]:
        output: dict[str, LogInfo] = {}
        for key in sorted(self.key_actions.keys()):
            entries = self.key_actions[key]
            info = LogInfo().set_key(key)
            info.set_elapsed(entries[-1].elapsed)
            info.set_attempts(len([x for x in entries if x.type == "TEST" or x.type == "FAIL"]))
            for action in entries:
                if action.coverage != -1:
                    info.set_coverage(action.coverage)
                if action.autonomy != -1:
                    info.set_autonomy(action.autonomy)
                if action.skill != -1:
                    info.set_skill(action.skill)
            output[key] = info
        return output
    
    def save_yaml(self):
        if self.log_file is None:
            return
        with open(self.log_file, 'w') as file:
            yaml.dump(self.key_actions, file)


class HistoryFile:

    def __init__(self, history_file: str | None = None, listeners: list[Callable[[LogAction, bool], None]] = []):
        self.history_file: str | None = history_file
        self.listeners: list[Callable[[LogAction, bool], None]] = listeners
        self.entries: list[LogAction] = HistoryFile.__load_file(history_file)
        for entry in self.entries:
            for listener in self.listeners:
                listener(entry, False)

    def get_entries(self) -> list[LogAction]:
        return self.entries

    def get_log_file(self) -> str | None:
        return self.history_file

    def __append_action_data(self, action_data: LogAction):
        self.entries.append(action_data)
        for listener in self.listeners:
            listener(action_data, True)
        log_file = self.get_log_file()
        if log_file is None:
            return
        if not os.path.exists(os.path.dirname(log_file)):
            os.makedirs(os.path.dirname(log_file))
        with open(log_file, 'a', encoding="utf-8", newline='') as file:
            writer = csv.writer(file)
            ad = action_data
            writer.writerow([ad.hash, ad.timestamp, ad.type_value, ad.task_key, ad.payload])

    def append_new_action(self, action: LogAction.Type, task_key: str = "", payload: str = ""):
        action_data = LogAction(action.value, task_key, payload)
        action_data.hash = LogAction.generate_hash(action_data, self.get_last_hash())
        action_data.timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        self.__append_action_data(action_data)

    @staticmethod
    def __row_to_action_data( row: list[str]) -> LogAction | None:
        if len(row) < 5:
            return None
        hash = row[0]
        timestamp = row[1]
        action_value = row[2]
        task = row[3]
        payload = row[4]
        action_data = LogAction(action_value, task, payload).set_hash(hash).set_timestamp(timestamp)
        return action_data

    @staticmethod
    def __load_file(history_file: str | None) -> list[LogAction]:
        if history_file is None:
            return []
        if not os.path.exists(history_file):
            return []
        encoding = Decoder.get_encoding(history_file)
        entries: list[LogAction] = []
        with open(history_file, 'r', encoding=encoding) as file:
            reader = csv.reader(file)
            rows = list(reader)
            for row in rows:
                action_data = HistoryFile.__row_to_action_data(row)
                if action_data is not None:
                    entries.append(action_data)
        return entries

    def get_last_hash(self) -> str:
        if len(self.entries) == 0:
            return ""
        return self.entries[-1].hash

class Logger:
    instance: None | Logger = None

    @staticmethod
    def get_instance() -> Logger:
        if Logger.instance is None:
            Logger.instance = Logger()
        return Logger.instance

    def __init__(self):
        self.last_hash: str | None = None
        self.history: None | HistoryFile = None
        self.daily = DailyListener()
        self.tasks = TaskListener()
        self.week = WeekListener()

    def set_log_files(self, log_file: str) -> Logger:
        if self.history is not None:
            return self
        self.history = HistoryFile(log_file, [self.daily.listener, self.tasks.listener, self.week.listener])
        # resume = self.week.resume()
        # print("\n".join([f"{x.weed_day} {x.elapsed}" for x in resume.values()]))
        return self
    
    def get_history_file(self) -> HistoryFile:
        if self.history is None:
            raise Warning("fail: History File not set")
        return self.history

    def check_log_file_integrity(self) -> list[str]:
        entries = self.get_history_file().get_entries()
        if len(entries) == 0:
            return []
        hash = entries[0].hash
        output: list[str] = []

        for i in range(1, len(entries)):
            calculated_hash = LogAction.generate_hash(entries[i], hash)
            if calculated_hash != entries[i].hash:
                output.append(f"Hash mismatch line {i + 1}: {str(entries[i])}")
            hash = calculated_hash
        return output

    def record_pick(self, task_key: str):
        self.__record_event(LogAction.Type.PICK, task_key)

    def record_back(self, task_key: str):
        self.__record_event(LogAction.Type.BACK, task_key)

    def record_down(self, task_key: str):
        self.__record_event(LogAction.Type.DOWN, task_key)

    def record_compilation_execution_error(self, task_key: str):
        self.__record_event(LogAction.Type.FAIL, task_key)
    
    def record_test_result(self, task_key: str, result: int):
        self.__record_event(LogAction.Type.TEST, task_key, str(result))

    def record_freerun(self, task_key: str):
        self.__record_event(LogAction.Type.FREE, task_key)

    def record_self_grade(self, task_key: str, coverage: int, autonomy: int, skill: int):
        self.__record_event(LogAction.Type.SELF, task_key, "{" + f"c:{coverage},a:{autonomy},s:{skill}" + "}")

    def record_open(self):
        self.__record_event(LogAction.Type.OPEN)
    
    def record_quit(self):
        self.__record_event(LogAction.Type.QUIT)

    def __record_event(self, action: LogAction.Type, task_key: str = "", payload: str = ""):
        if self.history is None:
            return
        self.get_history_file().append_new_action(action, task_key, payload)

class WeekGraph:
    def __init__(self, width: int, height: int, week_mode: bool = False):
        self.width = width
        self.height = height
        self.week_mode = week_mode
        self.collected: list[float] = []
        self.eixo: list[float] = []
        self.__collect()

    def __collect(self):
        logger = Logger.get_instance()
        days_minutes = logger.week.resume()
        if self.week_mode:
            self.collected = [0]
            for day, value in days_minutes.items():
                week_day = value.weed_day
                elapsed = value.elapsed
                if week_day == "Sunday":
                    self.collected.append(0)
                self.collected[-1] += elapsed

        else:
            self.collected = []
            for value in days_minutes.values():
                self.collected.append(value.elapsed)
        # convertendo de minutos pra horas/minutos
        for i in range(len(self.collected)):
            value = self.collected[i]
            hours = value // 60
            minutes = value % 60
            self.collected[i] = hours + minutes / 100.0
        self.eixo = list(range(len(self.collected)))
        # self.eixo = list(range(len(collected)))

    def get_collected(self) -> list[str]:
        output: list[str] = []
        for value in self.collected:
            output.append(f"{value:.2f}")
        for i in range(len(output)):
            output[i] = output[i].replace(".", ":").rjust(5, " ")
        return output

    def get_graph(self) -> list[str]:
        collected: list[float] = []
        eixo: list[int] = []
        if self.week_mode:
            title = " (horas / semana)"
            week = 1
            for value in self.collected:
                eixo.append(week)
                collected.append(0)
                eixo.append(week)
                collected.append(value)
                eixo.append(week)
                collected.append(0)
                week += 1
            result = plot_to_string(xs=eixo, ys=collected, title=title, lines=True, y_min=0, width=self.width, height=self.height, y_unit="h", x_unit="s")
        else:
            title = " (horas /  dia  )"
            day = 1
            for value in self.collected:
                eixo.append(day)
                collected.append(0)
                eixo.append(day)
                collected.append(value)
                eixo.append(day)
                collected.append(0)
                day += 1

            result = plot_to_string(xs=eixo, ys=collected, title=title, lines=True, y_min=0, width=self.width, height=self.height, y_unit="h", x_unit="d")
        if isinstance(result, str):
            return result.splitlines()
        return result

class Track:
    def __init__(self):
        self.timestamp = ""
        self.files: list[str] = []
        self.result: str = ""

    def set_timestamp(self, timestamp: str):
        self.timestamp = timestamp
        return self
    
    def set_files(self, files: list[str]):
        self.files = [os.path.basename(f) for f in files]
        return self
    
    def set_result(self, result: str):
        self.result = result
        return self
    
    def track_to_column(self):
        return [self.timestamp, self.result, ";".join(self.files)]


class Tracker:

    def __init__(self):
        self._files: list[str] = []
        self._folder: str = ""
        self._result: str = "None"
        self.log_file = "track.csv"
        self.track_folder = ".track"
        self.extension = ".json"

    def set_files(self, files: list[str]):
        self._files = [os.path.abspath(f) for f in files]
        return self
    
    def set_result(self, result: str):
        self._result = result
        return self
    
    def set_percentage(self, percentage: int):
        self._result = "{}%".format(str(percentage).rjust(3, "0"))
        return self

    def get_log_full_path(self):
        return os.path.join(self._folder, self.log_file)

    def set_folder(self, folder: str):
        self._folder = folder
        return self
    
    # in format: YYYY-MM-DD HH:MM:SS
    def get_timestamp(self):
        return datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

    # return timestamp of the last version of the file
    def save_file_with_timestamp_prefix(self, timestamp: str, file: str) -> str:
        filename = os.path.basename(file)
        ph = PatchHistory()
        json_file = os.path.join(self._folder, f"{filename}{self.extension}")
        ph.set_json_file(json_file)
        ph.load_json()

        content = Decoder.load(file)
        last_version = ph.store_version(timestamp, content)
        if last_version == timestamp:
            ph.save_json()
            return timestamp
        return last_version

    def store(self):
        os.makedirs(self._folder, exist_ok=True)
        file_list = os.listdir(self._folder)
        file_list = [f for f in file_list if f.endswith(self.extension)]

        files_in_this_version: list[str] = []
        timestamp = self.get_timestamp()

        for file in self._files:
            stored = self.save_file_with_timestamp_prefix(timestamp, file)
            filename = os.path.basename(file)
            files_in_this_version.append(filename + ":" + stored)

        log_file = self.get_log_full_path()
        track = Track().set_timestamp(timestamp).set_files(files_in_this_version).set_result(self._result)
        with open(log_file, encoding="utf-8", mode="a") as f:
            writer = csv.writer(f)
            writer.writerow(track.track_to_column())

    @staticmethod
    def main():
        parser = argparse.ArgumentParser(description="Track files changes.")
        parser.add_argument("files", metavar="files", type=str, nargs="+", help="files to be tracked.")
        args = parser.parse_args()
        
        tracker = Tracker().set_folder(".track").set_files(args.files)
        tracker.store()


class ConfigParams:
    def __init__(self):
        self.side: bool = False
        self.down: bool = False
        self.images: str | None = None
        self.editor: str | None = None
        self.borders: str | None = None
        self.timeout: int | None = None

    def __str__(self):
        return f"side: {self.side}, down: {self.down}, timeout: {self.timeout}, editor: {self.editor}, borders: {self.borders}, images: {self.images}"

class CmdConfig:
        
    @staticmethod
    def execute(settings: Settings, param: ConfigParams):
        action = False

        if param.borders is not None:
            action = True
            settings.app.set_use_borders(param.borders == "1")
            print("Borders now is: " + str("True" if param.borders == "1" else "False"))
        if param.images is not None:
            action = True
            settings.app.set_use_images(param.images == "1")
            print("Images now is: " + str("True" if param.images == "1" else "False"))
            
        if param.side:
            action = True
            settings.app.set_diff_mode(DiffMode.SIDE)
            print("Diff mode now is: SIDE_BY_SIDE")
        if param.down:
            action = True
            settings.app.set_diff_mode(DiffMode.DOWN)
            print("Diff mode now is: UP_DOWN")
        # if param.lang:
        #     action = True
        #     settings.app._lang_default = param.lang
        #     print("Default language extension now is:", param.lang)
        # if param.ask:
        #     action = True
        #     settings.app._lang_default = ""
        #     print("Language extension will be asked always.")
        
        if param.editor:
            action = True
            settings.app.editor = param.editor
            print(f"Novo comando para abrir arquivos de código: {param.editor}")

        if param.timeout is not None:
            action = True
            settings.app.set_timeout(param.timeout)
            print(f"Novo timeout: {param.timeout}")

        if not action:
            action = True
            print(str(settings))

        settings.save_settings()





def load_html_tags(task: str) -> None | str:
    pattern = r"<!--\s*(.*?)\s*-->"
    match = re.search(pattern, task)
    if not match:
        return None
    return match.group(1).strip()


class Game:
    def __init__(self):
        self.ordered_clusters: List[str] = [] # ordered clusters
        self.clusters: Dict[str, Cluster] = {} 
        self.quests: Dict[str, Quest] = {}  # quests indexed by quest key
        self.tasks: Dict[str, Task] = {}  # tasks indexed by task key

        self.token_level_one = "level_one"
        self.token_level_mult = "level_mult"
        self.level_one: int = 100
        self.level_mult: float = 1.5


    def parse_xp(self, content):
        if content.startswith('---'):
            front_matter = content.split('---')[1].strip()
            yaml_data = yaml.safe_load(front_matter)
            if self.token_level_one in yaml_data:
                self.level_one = int(yaml_data[self.token_level_one])
            if self.token_level_mult in yaml_data:
                self.level_mult = float(yaml_data[self.token_level_mult])

    def get_task(self, key: str) -> Task:
        if key in self.tasks:
            return self.tasks[key]
        raise Warning(f"fail: tarefa '{key}' não encontrada no curso")

    def get_xp_resume(self):
        total = 0
        obtained = 0
        for q in self.quests.values():
            o, t = q.get_xp()
            total += t
            obtained += o
        return obtained, total

    def get_skills_resume(self, avaliable_quests: List[Quest]) -> Tuple[Dict[str, int], Dict[str, int]]:
        total: Dict[str, int] = {}
        obtained: Dict[str, int] = {}
        avaliable_keys = [q.key for q in avaliable_quests]
        for q in self.quests.values():
            reachable = q.key in avaliable_keys
            for t in q.get_tasks():
                for s in t.skills:
                    if s in total:
                        total[s] += t.skills[s]
                        if reachable:
                            obtained[s] += int(t.skills[s] * t.get_ratio())
                        else:
                            obtained[s] += 0
                    else:
                        total[s] = t.skills[s]
                        if reachable:
                            obtained[s] = int(t.skills[s] * t.get_ratio())
                        else:
                            obtained[s] = 0
                for s in t.qskills:
                    if s in total:
                        total[s] += t.qskills[s]
                        if reachable:
                            obtained[s] += int(t.qskills[s] * t.get_ratio())
                        else:
                            obtained[s] += 0
                    else:
                        total[s] = t.qskills[s]
                        if reachable:
                            obtained[s] = int(t.qskills[s] * t.get_ratio())
                        else:
                            obtained[s] = 0
        return total, obtained


    def parse_file_and_folder(self, filename: str, folder: str):
        self.filename = filename
        content = Decoder.load(filename)
        self.parse_xp(content)

        gb = GameBuilder(filename, folder).build_from(content)
        self.ordered_clusters = gb.ordered_clusters
        self.clusters = gb.clusters
        self.quests = gb.collect_quests()
        self.tasks = gb.collect_tasks()
        GameValidator(filename, self.clusters, self.quests, self.tasks).validate()

        # for t in self.tasks.values():
        #     t.get_link(os.path.dirname(filename) + "/")

    @staticmethod
    def is_reachable_quest(q: Quest, cache: Dict[str, bool]):
        if q.key in cache:
            return cache[q.key]

        if len(q.requires_ptr) == 0:
            cache[q.key] = True
            return True
        cache[q.key] = all([r.is_complete() and Game.is_reachable_quest(r, cache) for r in q.requires_ptr])
        return cache[q.key]

    # def __get_reachable_quests(self):
    #     # cache needs to be reseted before each call
    #     cache: Dict[str, bool] = {}
    #     return [q for q in self.quests.values() if Game.__is_reachable_quest(q, cache)]

    def update_reachable_and_available(self):
        for q in self.quests.values():
            q.set_reachable(False)
            q.update_tasks_reachable()
        for c in self.clusters.values():
            c.set_reachable(False)

        cache: Dict[str, bool] = {}
        for c in self.clusters.values():
            for q in c.get_quests():
                if Game.is_reachable_quest(q, cache):
                    q.set_reachable(True)
                    c.set_reachable(True)


    def __str__(self):
        output = []
        for c in self.clusters.values():
            output.append("# " + str(c))
            for q in c.get_quests():
                output.append("  - " + str(q))
                for t in q.get_tasks():
                    output.append("    - " + str(t))
        output.append(100 * "-")
        for q in self.quests.values():
            output.append(str(q))
        output.append(100 * "-")
        for t in self.tasks.values():
            output.append(str(t))
        return "\n".join(output)

class XP:
    token_level_one = "level_one"
    token_level_mult = "level_mult"
    level_one: int = 100
    level_mult: float = 1.5
    
    def __init__(self, game: Game):
        self.game = game
        self.obtained = 0
        self.avaliable = 0
        self.update()
        self.level = self.get_level()
    
    def update(self):
        self.obtained, self.avaliable = self.game.get_xp_resume()

    def get_level(self) -> int:
        return self.calc_level(self.obtained)

    def get_xp_level_current(self) -> int:
        xp_prev = self.calc_xp(self.level)
        atual = self.obtained - xp_prev
        return atual

    def get_xp_level_needed(self) -> int:
        xp_next = self.calc_xp(self.level + 1)
        xp_prev = self.calc_xp(self.level)
        return xp_next - xp_prev

    def get_xp_total_obtained(self) -> int:
        return self.obtained

    def get_xp_total_available(self) -> int:
        return self.avaliable

    def calc_level(self, xp) -> int:
        level = 1
        while self.calc_xp(level) <= xp:
            level += 1
        return level - 1
    
    def calc_xp(self, level: int) -> int:
        total = 0
        for i in range(level - 1):
            total += self.game.level_one * (int(self.game.level_mult) ** i)
        return int(total)






class VplParser:
    @staticmethod
    def finish(text):
        return text if text.endswith("\n") else text + "\n"

    @staticmethod
    def unwrap(text):
        while text.endswith("\n"):
            text = text[:-1]
        if text.startswith("\"") and text.endswith("\""):
            text = text[1:-1]
        return VplParser.finish(text)

    @staticmethod
    class CaseData:
        def __init__(self, case="", inp="", outp="", grade: Optional[int] = None):
            self.case: str = case
            self.input: str = VplParser.finish(inp)
            self.output: str = VplParser.unwrap(VplParser.finish(outp))
            self.grade: Optional[int] = grade

        def __str__(self):
            return "case=" + self.case + '\n' \
                   + "input=" + self.input \
                   + "output=" + self.output \
                   + "gr=" + str(self.grade)

    regex_vpl_basic = r"[cC]ase *= *([ \S]*) *\n *[iI]nput *=([\s\S]*?)^ *[oO]utput *=([\s\S]*?)(?=^ *[cC]ase *=|\Z)"
    regex_grade_reduction = r"([\s\S]*) *[Gg]rade [rR]eduction *= *(.*)%"

    @staticmethod
    def filter_quotes(x):
        return x[1:-2] if x.startswith('"') else x

    @staticmethod
    def parse_vpl(content: str) -> List[CaseData]:
        output: List[VplParser.CaseData] = []
        for m in re.finditer(VplParser.regex_vpl_basic, content, re.MULTILINE):
            str_case = m.group(1)
            str_input = m.group(2)
            str_output = m.group(3)
            grade: int | None = None
            gr = re.match(VplParser.regex_grade_reduction, str_output, re.MULTILINE)
            if gr is not None:
                str_output = gr.group(1)
                grade = int(gr.group(2))
            output.append(VplParser.CaseData(str_case, str_input, str_output, grade))
        return output

    @staticmethod
    def to_vpl(unit: CaseData):
        text = "case=" + unit.case + "\n"
        text += "inserted=" + unit.input
        text += "expected=\"" + unit.output + "\"\n"
        if unit.grade is not None:
            text += "grade reduction=" + str(unit.grade) + "%\n"
        return text


class Loader:
    # regex_tio = r"^ *#INPUT *(.*?)\n(.*?)^ *#OUTPUT *\n(.*?)^ *#END *\n?"
    regex_tio = r"^[ ]*[>]+ ?INSERT[ ]*([^\n]*?)\n([\s\S]*?)^[ ]*[=]+ ?EXPECT[ ]*\n([\s\S]*?)^[ ]*[<]+ ?FINISH*$"
    regex_tio_origin = r"^>>>>>>>> *(.*?)\n(.*?)^======== *\n(.*?)^<<<<<<<<"

    def __init__(self):
        pass

    @staticmethod
    def parse_cio(text, source):
        unit_list = []
        text = "\n" + text

        pattern = r'```.*?\n(.*?)```'  # get only inside code blocks
        code = re.findall(pattern, text, re.MULTILINE | re.DOTALL)
        # join all code blocks found
        text = "\n" + "\n".join(code)

        pieces = []  # header, input, output

        open_case = False
        for line in text.splitlines():
            if line.startswith("#__case") or line.startswith("#TEST_CASE"):
                pieces.append({"header": line, "input": [], "output": []})
                open_case = True
            elif open_case:
                pieces[-1]["output"].append(line)
                if line.startswith("$end"):
                    open_case = False

        # concatenando testes contínuos e finalizando testes sem $end
        for i in range(len(pieces)):
            output = pieces[i]["output"]
            if output[-1] != "$end" and i < len(pieces) - 1:
                pieces[i + 1]["output"] = output + pieces[i + 1]["output"]
                output.append("$end")

        # removendo linhas vazias e criando input das linhas com $
        for piece in pieces:
            piece["input"] = [line[1:] for line in piece["output"] if line.startswith("$")]
            piece["output"] = [line for line in piece["output"] if line != "" and not line.startswith("#")]

        for piece in pieces:
            case = " ".join(piece["header"].split(" ")[1:])
            inp = "\n".join(piece["input"]) + "\n"
            output = "\n".join(piece["output"]) + "\n"
            unit_list.append(Unit(case, inp, output, None, source))

        return unit_list

    @staticmethod
    def parse_tio(text: str, source: str = "") -> List[Unit]:

        # identifica se tem grade e retorna case name e grade
        def parse_case_grade(value: str) -> Tuple[str, Optional[int]]:
            if value.endswith("%"):
                words = value.split(" ")
                last = value.split(" ")[-1]
                _case = " ".join(words[:-1])
                grade_str = last[:-1]           # ultima palavra sem %
                try:
                    _grade = int(grade_str)
                    return _case, _grade
                except ValueError:
                    pass
            return value, None

        matches = re.findall(Loader.regex_tio, text, re.MULTILINE | re.DOTALL)
        if len(matches) == 0:
            matches += re.findall(Loader.regex_tio_origin, text, re.MULTILINE | re.DOTALL)
        unit_list = []
        for m in matches:
            case, grade = parse_case_grade(m[0])
            unit_list.append(Unit(case, m[1], m[2], grade, source))
        return unit_list

    @staticmethod
    def parse_vpl(text: str, source: str = "") -> List[Unit]:
        data_list = VplParser.parse_vpl(text)
        output: List[Unit] = []
        for m in data_list:
            output.append(Unit(m.case, m.input, m.output, m.grade, source))
        return output

    @staticmethod
    def parse_dir(folder) -> List[Unit]:
        pattern_loader = PatternLoader()
        files = sorted(os.listdir(folder))
        matches = pattern_loader.get_file_sources(files)

        unit_list: List[Unit] = []
        try:
            for m in matches:
                unit = Unit()
                unit.source = os.path.join(folder, m.label)
                unit.grade = 100
                input_file = os.path.join(folder, m.input_file)
                value = Decoder.load(input_file)
                unit.inserted = value + ("" if value.endswith("\n") else "\n")
                output_file = os.path.join(folder, m.output_file)
                value = Decoder.load(output_file)
                unit.expected = value + ("" if value.endswith("\n") else "\n")
                unit_list.append(unit)
        except FileNotFoundError as e:
            print(str(e))
        return unit_list

    @staticmethod
    def parse_source(source: str) -> List[Unit]:
        if os.path.isdir(source):
            return Loader.parse_dir(source)
        if os.path.isfile(source):
            #  if PreScript.exists():
            #      source = PreScript.process_source(source)
            content = Decoder.load(source)
            if source.endswith(".vpl") or source.endswith(".cases"):
                return Loader.parse_vpl(content, source)
            elif source.endswith(".tio"):
                return Loader.parse_tio(content, source)
            elif source.endswith(".md"):
                tests = Loader.parse_tio(content, source)
                tests += Loader.parse_cio(content, source)
                return tests
            else:
                print("warning: target format do not supported: " + source)  # make this a raise
        else:
            raise FileNotFoundError('warning: unable to find: ' + source)
        return []


class CompileError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return self.message

class SolverBuilder:
    def __init__(self, solver_list: List[str]):
        self.path_list: List[str] = [os.path.normpath(SolverBuilder.__add_dot_bar(path)) for path in solver_list]

        if len(self.path_list) > 0:
            self.cache_dir = os.path.join(os.path.dirname(self.path_list[0]), ".build")
        else:
            self.cache_dir = tempfile.mkdtemp()
        self.clear_cache()
        self.error_msg: str = ""
        self.__executable: tuple[str, str | None] = ("", None) # executavel e pasta
        self.compile_error: bool = False

    def check_tool(self, name):
        if shutil.which(name) is None:
            self.compile_error = True
            raise CompileError("fail: comando '" + name + "' não foi encontrado")

    def set_main(self, main: str):
        list_main: List[str] = []
        list_other: List[str] = []

        for path in self.path_list:
            if os.path.basename(path) == main:
                list_main.append(path)
            else:
                list_other.append(path)

        self.path_list = list_main + list_other
        return self

    def set_executable(self, executable: str, folder: str | None = None):
        self.__executable = (executable, folder)
        return self

    def clear_cache(self):
        if os.path.exists(self.cache_dir):
            shutil.rmtree(self.cache_dir)
        os.makedirs(self.cache_dir, exist_ok=True)

    def reset(self):
        self.__executable = ("", None)
        self.compile_error = False
        self.error_msg = ""
        self.clear_cache()

    def not_compiled(self):
        cmd, folder = self.__executable
        return cmd == "" and not self.compile_error

    def get_executable(self, force_rebuild=False) -> tuple[str, str | None]:
        if (len(self.path_list) > 0 and self.not_compiled()) or force_rebuild:
            self.prepare_exec()
        cmd, folder = self.__executable
        return (cmd, None if folder == "" else folder)

    def prepare_exec(self, free_run_mode: bool = False) -> None:
        self.set_executable("")
        path = self.path_list[0]
        self.compile_error = False

        if path.endswith(".py"):
            self.set_executable("python " + path)
        elif path.endswith(".yaml"):
            self.__prepare_yaml()
        elif path.endswith(".mk"):
            self.__prepare_make()
        elif path.endswith(".js"):
            self.__prepare_js(free_run_mode)
        elif path.endswith(".ts"):
            self.__prepare_ts(free_run_mode)
        elif path.endswith(".java"):
            self.__prepare_java()
        elif path.endswith(".c") or path.endswith(".h"):
            self.__prepare_c()
        elif path.endswith(".cpp") or path.endswith(".hpp"):
            self.__prepare_cpp()
        elif path.endswith(".go"):
            self.__prepare_go()
        # elif path.endswith(".sql"):
        #     self.__prepare_sql()
        else:
            self.set_executable(path)

    def __prepare_java(self):
        self.check_tool("javac")

        solver = self.path_list[0]

        filename = os.path.basename(solver)
        # tempdir = os.path.dirname(self.path_list[0])

        cmd = ["javac"] + self.path_list + ['-d', self.cache_dir]
        cmdt = " ".join(cmd)
        return_code, stdout, stderr = Runner.subprocess_run(cmdt)
        if return_code != 0:
            self.error_msg = stdout + stderr
            self.compile_error = True
        else:
            self.set_executable("java -cp " + self.cache_dir + " " + filename[:-5])  # removing the .java

    def update_input_function(self, free_run_mode: bool, path_list: list[str], copy_dir: str):
        new_files: list[str] = []
        for origin in self.path_list:
            new_files.append(os.path.join(copy_dir, os.path.basename(origin)))

        for i in range(len(path_list)):
            origin = path_list[i]
            destiny = new_files[i]

            encoding = Decoder.get_encoding(origin)
            with open(origin, "r", encoding=encoding) as f:
                content = f.read()
                lines = content.splitlines(keepends=True)

            io_source = io.StringIO()
            io_target = io.StringIO()

            tag = "function input()"
            tag2 = "constinput=()=>"

            if free_run_mode:
                input_cmd = r'function input(): string { let X: any = input; X.P = X.P || require("readline-sync"); return X.P.question(); }'
                input_tag = 'const input = () => ""; // INTERATIVO\n'
            else:
                input_cmd = r'function input(): string { let X: any = input; X.L = X.L || require("fs").readFileSync(0).toString().split(/\r?\n/); return X.L.shift(); } '
                input_tag = 'const input = () => ""; // MODO_TESTE\n'

            inserted: bool = False
            for line in lines:
                match = False
                if not inserted:
                    filtered = "".join([c for c in line if c != " "])
                    match = filtered.startswith(tag2) or line.startswith(tag)
                if match:
                    inserted = True
                    io_source.write(input_tag)
                    io_target.write(input_cmd)
                else:
                    io_source.write(line)
                    io_target.write(line)

            result = io_source.getvalue()
            if result != content:
                with open(origin, "w", encoding="utf-8") as f:
                    f.write(io_source.getvalue())
            with open(destiny, "w", encoding="utf-8") as f:
                f.write(io_target.getvalue())
            io_source.close()
            io_target.close()
        return new_files

    def __prepare_yaml(self):
        solver = os.path.abspath(self.path_list[0])
        folder = os.path.dirname(solver)
        content = Decoder.load(solver)
        yaml_data = yaml.safe_load(content)

        if "build" in yaml_data and yaml_data["build"] is not None:
            build_cmd = yaml_data["build"]
            return_code, stdout, stderr = Runner.subprocess_run(build_cmd, folder = folder)
            if return_code != 0:
                self.error_msg = stdout + stderr
                self.compile_error = True
                return
        if not "run" in yaml_data:
            raise Warning(Text.format("{r}: Seu arquivo yaml precisa ter um campo {g} ", "Falha", "run:"))
        self.set_executable(yaml_data["run"], folder)

    def __prepare_make(self):
        self.check_tool("make")
        solver = os.path.abspath(self.path_list[0])
        folder = os.path.dirname(solver)
        cmd = "make -s -C {} -f {} build".format(folder, solver)
        return_code, stdout, stderr = Runner.subprocess_run(cmd)
        if return_code != 0:
            self.error_msg = stdout + stderr
            self.compile_error = True
        else:
            self.set_executable("make -s -C {} -f {} run".format(folder, solver))

    def __prepare_js(self, free_run_mode: bool):
        self.check_tool("node")
        solver = self.path_list[0]
        self.set_executable("node " + solver)

    def __prepare_go(self):
        self.check_tool("go")
        self.set_executable("go run " + " ".join(self.path_list))

    # def __prepare_sql(self):
    #     self.check_tool("sqlite3")
    #     self.__executable = "cat " + " ".join(self.path_list) + " | sqlite3"

    def __prepare_ts(self, free_run_mode: bool):
        copy_dir = os.path.join(self.cache_dir, "src")
        # remove the cache dir
        if os.path.exists(copy_dir):
            shutil.rmtree(copy_dir)
        os.makedirs(copy_dir, exist_ok=True)
        new_files = self.update_input_function(free_run_mode, self.path_list, copy_dir)
        transpiler = "npx"
        if os.name == "nt":
            transpiler += ".cmd"

        self.check_tool(transpiler)
        self.check_tool("node")
        transpiler = "npx esbuild"
        cmd = [transpiler] + new_files + ["--outdir=" + self.cache_dir, "--format=cjs", "--log-level=error"]
        return_code, stdout, stderr = Runner.subprocess_run(" ".join(cmd))

        if return_code != 0:
            self.error_msg = stdout + stderr
            self.compile_error = True
        else:
            new_source_list = []
            for source in new_files:
                new_source_list.append(os.path.join(self.cache_dir, os.path.basename(source)[:-2] + "js"))
            self.set_executable("node " + " ".join(new_source_list))  # renaming solver to main

    def __prepare_c_cpp(self, pre_args: List[str], pos_args: List[str]):
        # solver = self.path_list[0]
        tempdir = self.cache_dir
        source_list = [x for x in self.path_list if not x.endswith(".h") and not x.endswith(".hpp")]

        # print("Using the following source files: " + str([os.path.basename(x) for x in source_list]))

        exec_path = os.path.join(tempdir, ".a.out")
        cmd = pre_args + source_list + ["-o", exec_path] + pos_args
        return_code, stdout, stderr = Runner.subprocess_run(" ".join(cmd))
        if return_code != 0:
            self.error_msg = stdout + stderr
            self.compile_error = True
        else:
            self.set_executable(exec_path)

    def __prepare_c(self):
        self.check_tool("gcc")
        pre = ["gcc", "-Wall"]
        pos = ["-lm"]
        self.__prepare_c_cpp(pre, pos)

    def __prepare_cpp(self):
        self.check_tool("g++")
        pre = ["g++", "-std=c++17", "-Wall", "-Wextra", "-Werror", "-Wno-deprecated"]
        pos: List[str] = []
        # fmt_lib = False
        # for path in self.path_list:
        #     if os.path.isfile(path):
        #         content = Decoder.load(path)
        #         if "#include <fmt" in content:
        #             fmt_lib = True
        #             break
        # if fmt_lib:
        #     pos.append("-lfmt")

        self.__prepare_c_cpp(pre, pos)

    @staticmethod
    def __add_dot_bar(solver: str) -> str:
        if os.sep not in solver and os.path.isfile("." + os.sep + solver):
            solver = "." + os.sep + solver
        return solver


class UnitRunner:

    def __init__(self):
        pass

    # run a unit using a solver and return if the result is correct
    @staticmethod
    def run_unit(solver: SolverBuilder, unit: Unit, timeout: Optional[float]=None) -> ExecutionResult:
        if solver.compile_error:
            unit.received = solver.error_msg
            return ExecutionResult.COMPILATION_ERROR
        cmd, folder = solver.get_executable()
        if timeout == 0:
            timeout = None

        return_code, stdout, stderr = Runner.subprocess_run(cmd, unit.inserted, timeout, folder)
        unit.received = stdout + stderr
        if return_code != 0:
            return ExecutionResult.EXECUTION_ERROR
        if unit.received == unit.expected:
            return ExecutionResult.SUCCESS
        return ExecutionResult.WRONG_OUTPUT



class Writer:

    def __init__(self):
        pass

    @staticmethod
    def to_vpl(unit: Unit):
        text = "case=" + unit.case + "\n"
        text += "input=" + unit.inserted
        text += "output=\"" + unit.expected + "\"\n"
        if unit.grade is None:
            text += "\n"
        else:
            text += "grade reduction=" + str(unit.grade).zfill(3) + "%\n"
        return text

    @staticmethod
    def to_tio(unit: Unit):
        text  = ">>>>>>>> INSERT"
        if unit.case != '':
            text += " " + unit.case
        if unit.grade is not None:
            text += " " + str(unit.grade) + "%"
        text += '\n' + unit.inserted
        text += "======== EXPECT\n"
        text += unit.expected
        if unit.expected != '' and unit.expected[-1] != '\n':
            text += '\n'
        text += "<<<<<<<< FINISH\n\n"
        return text

    @staticmethod
    def save_dir_files(folder: str, pattern_loader: PatternLoader, label: str, unit: Unit) -> None:
        file_source = pattern_loader.make_file_source(label)
        with open(os.path.join(folder, file_source.input_file), "w", encoding="utf-8") as f:
            f.write(unit.inserted)
        with open(os.path.join(folder, file_source.output_file), "w", encoding="utf-8") as f:
            f.write(unit.expected)

    @staticmethod
    def save_target(target: str, unit_list: List[Unit], quiet: bool) -> bool:
        def save_dir(_target: str, _unit_list):
            folder = _target
            pattern_loader = PatternLoader()
            number = 0
            for unit in _unit_list:
                Writer.save_dir_files(folder, pattern_loader, str(number).zfill(2), unit)
                number += 1

        def save_file(_target, _unit_list):
            if _target.endswith(".tio"):
                _new = "\n".join([Writer.to_tio(unit) for unit in _unit_list])
            else:
                _new = "\n".join([Writer.to_vpl(unit) for unit in _unit_list])

            file_exists = os.path.isfile(_target)

            if file_exists:
                _old = Decoder.load(_target)
                if _old == _new:
                    if not quiet:
                        print("no changes in test file")
                    return False

            with open(_target, "w", encoding="utf-8") as f:
                f.write(_new)
                if not quiet:
                    print("file " + _target + " wrote")
                return True

        target_type = Identifier.get_type(target)
        if target_type == IdentifierType.OBI:
            save_dir(target, unit_list)
        elif target_type == IdentifierType.TIO or target_type == IdentifierType.VPL:
            save_file(target, unit_list)
        else:
            print("fail: target " + target + " do not supported for build operation\n")
            return False
        return True

class Mark:
    def __init__(self, marker, indent):
        self.marker: str = marker
        self.indent: int = indent

    def __str__(self):
        return f"{self.marker}:{self.indent}"

class Mode:
    ADD = "ADD!"
    COM = "COM!"
    ACT = "ACT!"
    DEL = "DEL!"
    opts = [ADD, COM, ACT, DEL]

def get_comment(filename: str) -> str:
    com = "//"
    if filename.endswith(".py"):
        com = "#"
    elif filename.endswith(".puml"):
        com = "'"
    return com

class Filter:
    def __init__(self, filename):
        self.filename = filename
        self.stack = [Mark(Mode.ADD, 0)]
        self.com = get_comment(filename)

    def get_marker(self) -> str:
        return self.stack[-1].marker

    def get_indent(self) -> int:
        return self.stack[-1].indent

    def outside_scope(self, line):
        stripped = line.strip()
        left_spaces = len(line) - len(line.lstrip())
        return stripped != "" and left_spaces < self.get_indent()

    def has_single_mode_cmd(self, line: str) -> bool:
        stripped = line.strip()
        for marker in Mode.opts:
            if stripped == self.com + " " + marker:
                return True
        return False

    def change_mode(self, line: str):
        with_left = line.rstrip()
        marker = with_left.lstrip()[len(self.com) + 1:]
        len_spaces = len(with_left) - len(self.com + marker + " ")
        while len(self.stack) > 0 and self.stack[-1].indent >= len_spaces:
            self.stack.pop()
        self.stack.append(Mark(marker, len_spaces))

    def search_temp_mode(self, line: str) -> Tuple[str, str]:
        for marker in Mode.opts:
            if line.rstrip().endswith(self.com + " " + marker):
                return marker, line[:-len(self.com + marker + " ")]
        return "---", line

    def __process(self, content: str) -> str:
        lines = content.splitlines()
        output = []
        for line in lines:
            while self.outside_scope(line):
                self.stack.pop()
            if self.has_single_mode_cmd(line):
                self.change_mode(line)
                continue
            marker = self.get_marker()
            pos_marker, line = self.search_temp_mode(line)
            if pos_marker != "---":
                marker = pos_marker

            if marker == Mode.DEL:
                continue
            elif marker == Mode.ADD:
                output.append(line)
            elif marker == Mode.ACT:
                prefix = " " * self.get_indent() + self.com + " "
                if not line.startswith(prefix):
                    prefix = prefix[:-1]
                line = line.replace(prefix, " " * self.get_indent(), 1)
                output.append(line)
            elif marker == Mode.COM:
                line = " " * self.get_indent() + self.com + " " + line[self.get_indent():]
                output.append(line)

        return "\n".join(output) + "\n"
    
    def process(self, content: str) -> str:
        return self.__process(content)

def clean_com(target: str, content: str) -> str:
    com = get_comment(target)
    lines = content.splitlines()
    output = [line for line in lines if not line.lstrip().startswith(com)]
    return "\n".join(output)

class DeepFilter:
    extensions = [".md", ".c", ".cpp", ".h", ".hpp", ".py", ".java", ".js", ".ts", ".hs", ".txt", ".go"]

    def __init__(self):
        self.cheat_mode = False
        self.quiet_mode = False
        self.indent = ""
    
    def print(self, *args, **kwargs):
        if not self.quiet_mode:
            print(self.indent, end="")
            print(*args, **kwargs)

    def set_indent(self, prefix: int):
        self.indent = prefix * " "
        return self

    def set_quiet(self, value):
        self.quiet_mode = (value == True)
        return self
    
    def set_cheat(self, value):
        self.cheat_mode = (value == True)
        return self

    def copy(self, source, destiny, deep: int):
        if deep == 0:
            return
        if os.path.isdir(source):
            chain = source.split(os.sep)
            if len(chain) > 1 and chain[-1].startswith("."):
                return
            if not os.path.isdir(destiny):
                os.makedirs(destiny)
            for file in sorted(os.listdir(source)):
                self.copy(os.path.join(source, file), os.path.join(destiny, file), deep - 1)
        else:
            filename = os.path.basename(source)

            if not any([filename.endswith(ext) for ext in self.extensions]):
                return

            content = Decoder.load(source)

            processed = Filter(filename).process(content)

            if self.cheat_mode:
                if processed != content:
                    cleaned = clean_com(source, content)
                    Decoder.save(destiny, cleaned)
            elif processed != "":
                Decoder.save(destiny, processed)

            line = ""
            if self.cheat_mode:
                if processed != content:
                    line += "(cleaned ): "
                else:
                    line += "(disabled): "
            else:
                if processed == "":
                    line += "(disabled): "
                elif processed != content:
                    line += "(filtered): "
                else:
                    line += "(        ): "
            line += destiny

            self.print(line)

class CodeFilter:
    @staticmethod
    def open_file(path): 
        if os.path.isfile(path):
            file_content = Decoder.load(path)
            return True, file_content
        print("Warning: File", path, "not found")
        return False, "" 

    @staticmethod
    def cf_recursive(target_dir: str, output_dir: str, force: bool, cheat: bool = False, quiet: bool = False, indent: int = 0):
        if output_dir is None:
                print("Error: output is required in recursive mode")
                exit()
        if not os.path.isdir(target_dir):
            print("Error: target must be a folder in recursive mode")
            exit()
        if os.path.exists(output_dir):
            if not force:
                print("Error: output folder already exists")
                exit()
            else:
                # recursive delete all folder content without deleting the folder itself
                for file in os.listdir(output_dir):
                    path = os.path.join(output_dir, file)
                    if os.path.isdir(path):
                        shutil.rmtree(path)
                    else:
                        os.remove(path)

        deep_filter = DeepFilter().set_cheat(cheat).set_quiet(quiet).set_indent(indent)
        deep_filter.copy(target_dir, output_dir, 10)

    @staticmethod
    def cf_single_file(target, output, update, cheat):
        file = target
        success, content = CodeFilter.open_file(file)
        if success:
            if cheat:
                content = clean_com(file, content)
            else:
                content = Filter(file).process(content)

            if output:
                if os.path.isfile(output):
                    old = Decoder.load(output)
                    if old != content:
                        Decoder.save(output, content)
                else:
                    Decoder.save(output, content)
            elif update:
                Decoder.save(file, content)
            else:
                print(content)

def cfmain():
    parser = argparse.ArgumentParser()
    parser.add_argument('target', type=str, help='file or folder to process')
    parser.add_argument('-u', '--update', action="store_true", help='update source file')
    parser.add_argument('-c', '--cheat', action="store_true", help='recursive cheat mode cleaning comments on students files')
    parser.add_argument('-o', '--output', type=str, help='output target')
    parser.add_argument("-r", "--recursive", action="store_true", help="recursive mode")
    parser.add_argument("-f", "--force", action="store_true", help="force mode")
    parser.add_argument("-q", "--quiet", action="store_true", help="quiet mode")
    parser.add_argument("-i", "--indent", type=int, default=0, help="indent using spaces")

    args = parser.parse_args()

    if args.cheat:
        args.recursive = True

    if args.recursive:
        CodeFilter.cf_recursive(args.target, args.output, force=args.force, cheat=args.cheat, quiet=args.quiet, indent=args.indent)
        exit()

    CodeFilter.cf_single_file(args.target, args.output, args.update, args.cheat)




class RemoteLink:
    def __init__(self):
        self.user = ""
        self.repo = ""
        self.branch = ""
        self.folder = ""
        self.file = ""

    def identify_from_url(self, url: str):
        if url.startswith("https://raw.githubusercontent.com"):
            url = url.replace("https://raw.githubusercontent.com/", "")
            elements = url.split("/")
            self.user = elements[0]
            self.repo = elements[1]
            if elements[2] != "refs":
                raise ValueError("Invalid URL")
            if elements[3] != "heads":
                raise ValueError("Invalid URL")
            self.branch = elements[4]
            self.folder = "/".join(elements[5:-1])
            self.file = elements[-1]
        elif url.endswith(".md"):
            url = url.replace("https://github.com/", "")
            elements = url.split("/")
            self.user = elements[0]
            self.repo = elements[1]
            if elements[2] != "blob":
                raise ValueError("Invalid URL")
            self.branch = elements[3]
            self.folder = "/".join(elements[4:-1])
            self.file = elements[-1]
        else:
            url = url.replace("https://github.com/", "")
            elements = url.split("/")
            self.user = elements[0]
            self.repo = elements[1]
            if elements[2] != "tree":
                raise ValueError("Invalid URL")
            self.branch = elements[3]
            self.folder = "/".join(elements[4:])
        return self

class RemoteCfg:
    def __init__(self, target: str):
        self.target = target
        self.remote: RemoteLink = RemoteLink()
        self.cfg_path: str | None = None
        self.__load_cfg_path(target)
        self.__parse_cfg()

    def cfg_exists(self):
        return self.cfg_path is not None

    def get_cfg_path(self):
        if self.cfg_path is None:
            raise Exception("cfg_path not set")
        return self.cfg_path

    def calc_link_for_local_file(self):
        base_cfg_file = os.path.dirname(os.path.abspath(self.get_cfg_path()))
        base_source_file = os.path.dirname(os.path.abspath(self.target))
        if not base_source_file.startswith(base_cfg_file):
            raise Exception("File not match with remote cfg")
        folder = os.path.relpath(base_source_file, base_cfg_file)
        self.remote.folder = folder
        return self.remote

    def __parse_cfg(self):
        if self.cfg_path is None:
            return
        config = configparser.ConfigParser()
        config.read(self.get_cfg_path())

        self.remote.user = config["DEFAULT"]["user"]
        self.remote.repo = config["DEFAULT"]["rep"]
        self.remote.branch = config["DEFAULT"]["branch"]

    def __load_cfg_path(self, target: str):
        # look for the remote.cfg file in the current folder
        # if not found, look for it in the parent folder
        # if not found, look for it in the parent's parent folder ...

        path = os.path.dirname(os.path.abspath(target))
        while path != "/":
            cfg_path = os.path.join(path, "remote.cfg")
            if os.path.isfile(cfg_path):
                self.cfg_path = cfg_path
                break
            path = os.path.dirname(path)


class Absolute:

    # processa o conteúdo trocando os links locais para links absolutos utilizando a url remota
    @staticmethod
    def __replace_remote(content: str, remote_raw: str, remote_view: str, remote_folder: str) -> str:
        if content is None or content == "":
            return ""
        if not remote_raw.endswith("/"):
            remote_raw += "/"
        if not remote_view.endswith("/"):
            remote_view += "/"
        if not remote_folder.endswith("/"):
            remote_folder += "/"

        #trocando todas as imagens com link local
        regex = r"!\[(.*?)\]\((\s*?)([^#:\s]*?)(\s*?)\)"
        subst = r"![\1](" + remote_raw + r"\3)"
        result = re.sub(regex, subst, content, count=0, flags=0)

        regex = r"\[(.+?)\]\((\s*?)([^#:\s]*?)(\s*?/)\)"
        subst = r"[\1](" + remote_folder + r"\3)"
        result = re.sub(regex, subst, result, 0)

        #trocando todos os links locais cujo conteudo nao seja vazio
        regex = r"\[(.+?)\]\((\s*?)([^#:\s]*?)(\s*?)\)"
        subst = r"[\1](" + remote_view + r"\3)"
        result = re.sub(regex, subst, result, 0)

        return result

    @staticmethod
    def relative_to_absolute(content: str, rl: RemoteLink):
        folder = rl.folder
        user_repo = "/".join([rl.user, rl.repo])
        remote_raw    = "/".join(["https://raw.githubusercontent.com", user_repo, rl.branch , folder])
        remote_view    = "/".join(["https://github.com", user_repo, "blob", rl.branch, folder])
        remote_folder = "/".join(["https://github.com", user_repo, "tree", rl.branch, folder])
        return Absolute.__replace_remote(content, remote_raw, remote_view, remote_folder)


    @staticmethod
    def convert_or_copy_or_print(source: str, target: str | None):
        content = Decoder.load(source)
        cfg = RemoteCfg(source)
        if cfg.cfg_exists():
            content = Absolute.relative_to_absolute(content, cfg.calc_link_for_local_file())
        if target is not None:
            Decoder.save(target, content)
        else:
            print(content)
        

def main_remote():
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('target', metavar='T', type=str, help='folders')
    # arg_parser.add_argument("--remote", "-r", action="store_true", help="convert local file to remote file")
    arg_parser.add_argument("--output", "-o", type=str, help="output file")
    args = arg_parser.parse_args()

    Absolute.convert_or_copy_or_print(args.target, args.output)





class RemoteUrl:
    def __init__(self, url: str):
        self.raw_link: str | None = ""
        self.remote: RemoteLink | None = None

        if not url.startswith("https://"):
            raise ValueError("Invalid URL")

        if url.startswith("https://gist.githubusercontent.com"):
            self.raw_link = url
        else:
            try:
                self.remote = RemoteLink().identify_from_url(url)
            except:
                raise Warning("URL inválida para download: {}".format(url))
        self.file = ""

    def get_raw_url(self):
        if self.raw_link:
            return self.raw_link
        if self.remote is None:
            return ""
        return "https://raw.githubusercontent.com/" + self.remote.user + "/" + self.remote.repo + "/" + self.remote.branch + "/" + self.remote.folder + "/" + self.remote.file

    def download_absolute_to(self, filename: str):
        [tempfile, __content] = urllib.request.urlretrieve(self.get_raw_url(), filename)
        content = ""
        content = Decoder.load(tempfile)
        if self.remote is not None:
            content = Absolute.relative_to_absolute(content, self.remote)
        Decoder.save(filename, content)
        return

    def __str__(self):
        return self.get_raw_url()

available_languages = ["c", "cpp", "py", "ts", "java", "go", "yaml"]

class Repository:
    OLD_CFG_FILE = "repository.json" # reprecated
    NEW_CFG_FILE = "repository.yaml"
    LOG_FILE = "history.csv"
    DAILY_FILE = "daily.yaml"
    INDEX_FILE = "Readme.md"
    TRACK_FOLDER = "track"
    CONFIG_FOLDER = ".tko"

    def __init__(self, folder: str):
        self.root_folder: str = folder
        rec_folder = Repository.rec_search_for_repo(folder)
        if rec_folder != "":
            self.root_folder = rec_folder

        self.data: Dict[str, Any] = {}
        self.game = Game()
        self.upgrade_version()

    def upgrade_version(self):
        return self

    @staticmethod
    def rec_search_for_repo(folder: str) -> str:
        folder = os.path.abspath(folder)
        if os.path.exists(os.path.join(folder, Repository.CONFIG_FOLDER, Repository.NEW_CFG_FILE)):
            return folder
        if os.path.exists(os.path.join(folder, Repository.CONFIG_FOLDER, Repository.OLD_CFG_FILE)):
            return folder
        new_folder = os.path.dirname(folder)
        if new_folder == folder: # não encontrou, não tem mais como subir
            return ""
        return Repository.rec_search_for_repo(new_folder)

    def get_key_from_task_folder(self, folder: str) -> str:
        label = os.path.basename(folder)
        task_folder = self.get_task_folder_for_label(label)
        if task_folder == folder:
            return label
        return ""

    def is_task_folder(self, folder: str) -> bool:
        label = os.path.basename(folder)
        task_folder = self.get_task_folder_for_label(label)
        return task_folder == folder

    def get_track_task_folder(self, label: str) -> str:
        return os.path.abspath(os.path.join(self.root_folder, Repository.CONFIG_FOLDER, Repository.TRACK_FOLDER, label))

    def get_task_folder_for_label(self, label: str) -> str:
        return os.path.abspath(os.path.join(self.root_folder, self.get_database_folder(), label))

    def is_local_dir(self, path):
        rep_dir = self.get_rep_dir()
        path = os.path.abspath(path)
        return os.path.commonpath([rep_dir, path]) == rep_dir

    @staticmethod
    def is_web_link(link: str) -> bool:
        return link.startswith("http:") or link.startswith("https:")

    def load_game(self):
        if self.data == {}:
            self.load_config()
        database_folder = os.path.join(self.root_folder, self.get_database_folder())
        cache_or_index = self.load_index_or_cache()
        self.game.parse_file_and_folder(cache_or_index, database_folder)
        self.__load_tasks_from_rep_into_game()
        return self
    
    def __load_tasks_from_rep_into_game(self):
        tasks = self.get_tasks()
        for key, serial in tasks.items():
            if key in self.game.tasks:
                self.game.tasks[key].load_from_db(serial)

    def get_old_config_file(self) -> str:
        return os.path.abspath(os.path.join(self.root_folder, Repository.CONFIG_FOLDER, Repository.OLD_CFG_FILE))

    def get_config_file(self) -> str:
        return os.path.abspath(os.path.join(self.root_folder, Repository.CONFIG_FOLDER, Repository.NEW_CFG_FILE))
    
    def get_history_file(self) -> str:
        return os.path.abspath(os.path.join(self.root_folder, Repository.CONFIG_FOLDER, Repository.LOG_FILE))
    
    def get_daily_file(self) -> str:
        return os.path.abspath(os.path.join(self.root_folder, Repository.CONFIG_FOLDER, Repository.DAILY_FILE))
    
    def get_default_readme_path(self) -> str:
        return os.path.abspath(os.path.join(self.root_folder, Repository.INDEX_FILE))

    def get_rep_dir(self) -> str:
        return os.path.abspath(self.root_folder)

    def __load_local_file(self, source: str) -> str:
        # test if file is inside or outside the repository
        source = os.path.abspath(os.path.join(self.root_folder, self.CONFIG_FOLDER, source))
        if not os.path.exists(source):
            raise Warning(Text.format("{r}: Arquivo fonte do repositório {y} não foi encontrado", "Erro", source))
        return source

    def __is_remote_source(self) -> bool:
        source = self.get_rep_source()
        return source.startswith("http:") or source.startswith("https:")
    
    def down_source_from_remote_url(self):
        source = self.get_rep_source()
        cache_file = self.get_default_readme_path()
        os.makedirs(self.root_folder, exist_ok=True)
        ru = RemoteUrl(source)
        try:
            ru.download_absolute_to(cache_file)
        except urllib.error.URLError:
            print("Não foi possível baixar o arquivo do repositório")
            if os.path.exists(cache_file):
                print("Usando arquivo do cache")
            else:
                raise Warning("fail: Arquivo do cache não encontrado")
        return cache_file

    def load_index_or_cache(self) -> str:
        source = self.get_rep_source()

        if self.__is_remote_source():
            return self.down_source_from_remote_url()
        return self.__load_local_file(source)

    __version = "version"
    __actual_version = "0.0.1"
    __source = "remote"  #remote url or local file or remote file
    __expanded = "expanded"
    __new_items = "new_items"
    __tasks = "tasks"
    __flags = "flags"
    __lang = "lang"
    __selected = "index"
    __database = "database"

    defaults = {
        __version: __actual_version,
        __database: "database",
        __source: "",
        __expanded: [],
        __tasks: {},
        __flags: {},
        __new_items: [],
        __lang: "",
        __selected: ""
    }

    def get_database_folder(self) -> str:
        return self.__get(Repository.__database)

    def set_database_folder(self, value: str):
        self.__set(Repository.__database, value)
        return self

    def get_version(self) -> str:
        return self.__get(Repository.__version)
    
    def set_version(self, value: str):
        self.__set(Repository.__version, value)
        return self

    def get_rep_source(self) -> str:
        return self.__get(Repository.__source)
    
    def set_rep_source(self, value: str):
        self.__set(Repository.__source, value)
        return self

    def get_selected(self) -> str:
        return self.__get(Repository.__selected)

    def get_expanded(self) -> List[str]:
        return self.__get(Repository.__expanded)

    def get_new_items(self) -> List[str]:
        return self.__get(Repository.__new_items)
    
    def get_tasks(self) -> Dict[str, Any]:
        return self.__get(Repository.__tasks)
    
    def get_flags(self) -> Dict[str, Any]:
        return self.__get(Repository.__flags)
    
    def get_lang(self) -> str:
        return self.__get(Repository.__lang)

    def set_expanded(self, value: List[str]):
        return self.__set(Repository.__expanded, value)
    
    def set_new_items(self, value: List[str]):
        return self.__set(Repository.__new_items, value)
    
    def set_tasks(self, value: Dict[str, str]):
        self.__set(Repository.__tasks, value)
        return self
    
    def set_flags(self, value: Dict[str, Any]):
        self.__set(Repository.__flags, value)
        return self
    
    def set_lang(self, value: str):
        self.__set(Repository.__lang, value)
        return self
    
    def set_selected(self, value: str):
        self.__set(Repository.__selected, value)
        return self

    def __get(self, key: str) -> Any:
        if key not in self.defaults:
            raise ValueError(f"Key {key} not found in RepSettings")
        value = self.data.get(key, Repository.defaults[key])
        if type(value) != type(Repository.defaults[key]):
            return Repository.defaults[key]
        return value

    def __set(self, key: str, value: Any):
        self.data[key] = value
        return self

    def create_empty_config_file(self, point_to_local_readme: bool = False):
        if point_to_local_readme:
            self.set_rep_source(self.get_default_readme_path())
        self.save_config()
        return self

    def has_local_config_file(self) -> bool:
        return os.path.exists(self.get_config_file()) or os.path.exists(self.get_old_config_file())

    def load_config(self):
        encoding = Decoder.get_encoding(self.get_config_file())
        if os.path.exists(self.get_old_config_file()):
            try:
                with open(self.get_old_config_file(), encoding=encoding) as f:
                    self.data = json.load(f)
                with open(self.get_config_file(), "w", encoding="utf-8") as f:
                    yaml.dump(self.data, f, default_flow_style=False, allow_unicode=True, sort_keys=False)
                os.remove(self.get_old_config_file())
            except:
                pass
        try:
            with open(self.get_config_file(), encoding=encoding) as f:
                self.data = yaml.safe_load(f)
        except:
            raise Warning(Text.format("O arquivo de configuração do repositório {y} está {r}.\nAbra e corrija o conteúdo ou crie um novo.", self.get_config_file(), "corrompido"))
        return self

    def save_config(self):
        self.set_version(self.__actual_version)
        json_file = self.get_config_file()
        if not os.path.exists(os.path.dirname(json_file)):
            os.makedirs(os.path.dirname(json_file))
        # filter keys that are not in defaults
        for key in list(self.data.keys()):
            if key not in Repository.defaults:
                del self.data[key]

        for key in Repository.defaults:
            if key not in self.data:
                self.data[key] = Repository.defaults[key]

        with open(json_file, "w", encoding="utf-8") as f:
            # f.write(json.dumps(self.data, indent=4))
            yaml.dump(self.data, f, default_flow_style=False, allow_unicode=True, sort_keys=False)
        return self

    def __str__(self) -> str:
        return ( f"data: {self.data}\n" )

class RepStarter:
    def __init__(self, remote: str | None, source: str | None, folder: str | None):
        self.folder: str = ""
        if not self.set_folder(folder, remote):
            return

        rep = self.createRepository()
        if rep is None:
            return
        self.rep = rep

        if source is None and remote is None:
            self.create_empty_rep()
            rep.save_config()
            self.print_end_msg()
            return
        
        if remote is not None:
            self.source: str = ""
            settings = Settings()
            if not settings.has_alias_remote(remote):
                raise Warning("fail: alias remoto não encontrado.")
            self.source = settings.get_alias_remote(remote)
            rep.set_rep_source(self.source)
            rep.save_config()
            self.print_end_msg()
            return
        
        if source is not None:
            self.source = os.path.abspath(source)
            if self.source.startswith(self.folder):
                self.source = os.path.relpath(self.source, os.path.dirname(rep.get_config_file()))
            rep.set_rep_source(self.source)
            rep.save_config()
            self.print_end_msg()
            return
    
    def print_end_msg(self):
        rel_path = os.path.relpath(self.rep.root_folder, os.getcwd())
        print(Text.format("Voce pode acessar o repositório com o comando {g} {y}", "tko open", "<pasta>"))
        print(Text.format("Por exemplo: {g} {y}", "tko open", rel_path))

    def set_folder(self, folder: str | None, remote: str | None) -> bool:
        if folder is not None:
            self.folder = os.path.abspath(folder)
            return True
        
        self.folder = os.path.abspath(os.getcwd())
        if remote is not None:
            self.folder = os.path.join(self.folder, remote)
        print(Text.format("A pasta onde deve ser criada o repositório {r} foi informada.", "não"))
        print(Text.format("Deseja criar o repositório na pasta {y} ? ({g}/{r}): ", self.folder, "s", "n"), end="")
        op = input()
        if op == "n":
            return False
        return True
    
    def createRepository(self) -> Repository | None:
        path_old = Repository.rec_search_for_repo(self.folder)
        if path_old != "":
            self.folder = path_old
            print(Text.format("Já existe um repositório em {r}.", path_old))
            print(Text.format("Deseja sobrescrever as configurações do repositório em {y} ? ({g}/{r}): ", self.folder, "s", "n"), end="")
            op = input()
            if op == "n":
                return None
        return Repository(os.path.abspath(self.folder))
    
    def create_empty_rep(self):
        index = self.rep.get_default_readme_path()
        self.rep.set_rep_source(index)
        print("Nenhuma fonte foi informada, utilizando o arquivo {} como fonte".format(index))
        if not os.path.exists(index):
            content = "# Repositório\n\n## Grupo\n\n### Missão\n\n- [ ] [#google Abra o google](https://www.google.com)\n"
            Decoder.save(index, content)

class TaskGraph:
    def __init__(self, settings: Settings, rep: Repository, task_key: str, width: int, height: int, minutes_mode: bool = False):
        self.settings = settings
        self.rep = rep
        self.task_key = task_key
        self.width = width
        self.height = height
        self.collected: list[float] = []
        self.eixo: list[float] = []
        self.minutes_mode = minutes_mode
        self.__collect()

    def __collect(self):
        logger = Logger.get_instance()
        actions = logger.tasks.key_actions.get(self.task_key, [])
        types = ["TEST", "PROG", "SELF", "FAIL"]
        filtered = [ad for ad in actions if ad.type in types]
        collected: list[float] = [0]
        last = 0
        eixo: list[float] = [0]
        count = 1
        for ad in filtered:
            if ad.coverage != -1:
                last = ad.coverage
                collected.append(last)
            else:
                collected.append(last)
            if self.minutes_mode:
                eixo.append(ad.elapsed.total_seconds() / 60)
            else:
                eixo.append(count)
                count += 1
        self.collected = collected
        self.eixo = eixo
        # self.eixo = list(range(len(collected)))

    def get_graph(self) -> list[str]:
        title = self.task_key
        if self.minutes_mode:
            title += " (% / minutos)"
        else:
            title += " (% / execuções)"
        result = plot_to_string(xs=self.eixo, ys=self.collected, title=title, lines=True, y_max=101, y_min=0, width=self.width, height=self.height)
        
        if isinstance(result, str):
            return result.splitlines()
        return result


class LanguageSetter:
    def __init__(self, rep: Repository, flagsman: FlagsMan, fman: FloatingManager):
        self.flagsman = flagsman
        self.fman = fman
        self.rep = rep


    def set_language(self):
        options: List[FloatingInputData] = []
        for lang in available_languages:
            options.append(FloatingInputData(TextFunctor(lang), SetLangFunctor(self.rep, self.fman, lang)))

        self.fman.add_input(
            FloatingInput("^")
            .set_header(" Escolha a extensão default para os rascunhos ")
            .set_options(options)
            .set_default_index(available_languages.index(self.rep.get_lang()))
            .set_footer(" Pressione Enter para confirmar ")
        )

class TextFunctor:
    def __init__(self, data: str):
        self.value = data
    
    def __call__(self):
        return Text().add(self.value)

class SetLangFunctor:
    def __init__(self, rep: Repository, fman: FloatingManager, lang: str):
        self.rep = rep
        self.fman = fman
        self.value = lang

    def __call__(self):
        self.rep.set_lang(self.value.strip())
        self.rep.save_config()
        self.fman.add_input(
            Floating()
            .put_text("")
            .put_text("Linguagem alterada para " + self.value)
            .put_text("")
            .warning()
        )
# from tko.game.graph import Graph

class TaskResume:
    def __init__(self):
        self.coverage = 0
        self.autonomy = 0
        self.skill = 0
        self.elapsed = 0
        self.attempts = 0

    def set_coverage(self, value: int):
        self.coverage = value
        return self
    
    def set_autonomy(self, value: int):
        self.autonomy = value
        return self
    
    def set_skill(self, value: int):
        self.skill = value
        return self
    
    def set_elapsed(self, value: int):
        self.elapsed = value
        return self
    
    def set_attempts(self, value: int):
        self.attempts = value
        return self

    def to_dict(self):
        return {
            "coverage": self.coverage,
            "autonomy": self.autonomy,
            "skill": self.skill,
            "elapsed": self.elapsed,
            "attempts": self.attempts
        }

    def __str__(self):
        return f"coverage:{self.coverage}, autonomy:{self.autonomy}, skill:{self.skill}, elapsed:{self.elapsed}, attempts:{self.attempts}"

class CmdRep:
    @staticmethod
    def check(args):
        rep = Repository(args.folder).load_config().load_game()
        logger = Logger.get_instance()
        logger.set_log_files(rep.get_history_file())

        output = logger.check_log_file_integrity()
        if len(output) == 0:
            print(f"Arquivo de log do repositório {rep} está íntegro.")
        else:
            print(f"Arquivo de log do repositório {rep} está corrompido.")
            print("Erros:")
            for error in output:
                print(f"- {error}")

    @staticmethod
    def resume(args):
        rep = Repository(args.folder).load_config().load_game()
        logger = Logger.get_instance()
        logger.set_log_files(rep.get_history_file())
        history_resume = logger.tasks.resume()
        repository_tasks: dict[str, Task] = rep.game.tasks

        tasks: dict[str, TaskResume] = {}
        for task in repository_tasks.values():
            if task.coverage != 0:
                tasks[task.key] = TaskResume().set_coverage(task.coverage).set_autonomy(task.autonomy).set_skill(task.skill)

        for key in history_resume:
            entry = history_resume[key]
            elapsed = entry.get_minutes()
            attempts = entry.attempts
            if elapsed > 0 or attempts > 0:
                if key not in tasks:
                    tasks[key] = TaskResume()
                tasks[key].set_elapsed(entry.get_minutes()).set_attempts(entry.attempts)
        
        tasks_str: dict[str, dict[str, int]] = {}
        for key in tasks:
            tasks_str[key] = tasks[key].to_dict()

        print (yaml.dump(tasks_str, sort_keys=False))

    @staticmethod
    def graph(args):
        rep = Repository(args.folder).load_config().load_game()
        logger = Logger.get_instance()
        logger.set_log_files(rep.get_history_file())
        wg = WeekGraph(100, 24, week_mode=True)
        image = wg.get_graph()
        week = wg.get_collected()
        pad = " " * 12
        print(f"{pad}{image[0]}")
        print(f"{pad}{image[1]}")
        image = image[2:]

        for i, line in enumerate(image):
            if i < len(week):
                index = i + 1
                index_pad = str(index).rjust(2, " ")
                print(f"{index_pad} - {week[i]}h ", end="")
            else:
                print(pad, end="")
            print(line)

        # for i in range(len(week)):
        #     print(f"{i} - {week[i]}h")

    @staticmethod
    def upgrade(args):
        folder = args.folder
        if os.path.exists(os.path.join(folder, "rep.json")):
            os.rename(os.path.join(folder, "rep.json"), os.path.join(folder, "repository.json"))
        remote_folder = os.path.join(folder, "remote")
        os.makedirs(remote_folder, exist_ok=True)
        for entry in os.listdir(folder):
            path = os.path.join(folder, entry)
            if entry == "remote":
                continue
            if os.path.isdir(path):
                os.rename(path, os.path.join(remote_folder, entry))
        print(f"Repositório {folder} foi atualizado.")

    @staticmethod
    def list(_args):
        settings = Settings()
        print(f"SettingsFile\n- {settings.settings_file}")
        print(str(settings))

    @staticmethod
    def add(args):
        settings = Settings().set_alias_remote(args.alias, args.value)
        settings.save_settings()

    @staticmethod
    def rm(args):
        sp = Settings()
        if args.alias in sp.dict_alias_remote:
            sp.dict_alias_remote.pop(args.alias)
            sp.save_settings()
        else:
            print("Repository not found.")

    @staticmethod
    def reset(_):
        sp = Settings().reset()
        print(sp.settings_file)
        sp.save_settings()

    # @staticmethod
    # def graph(args):
    #     rep = Repository(args.folder).load_config().load_game()
    #     rep.game.check_cycle()
    #     Graph(rep.game).generate()

class Free:
    @staticmethod
    def free_run(solver: SolverBuilder, show_compilling:bool=True, to_clear: bool=True, wait_input:bool=True, header: Text = Text()) -> bool:

        if to_clear:
            Runner.clear_screen()
        if show_compilling:
            image = random.choice(list(compilling.keys()))
            for line in compilling[image].splitlines():
                print(Text().addf("y", line).center(RawTerminal.get_terminal_size(), Token(" ")))

        if show_compilling:
            Runner.clear_screen()
        solver.prepare_exec(free_run_mode=True)
        if solver.compile_error:
            print(solver.error_msg)
        else:
            cmd, folder = solver.get_executable()
            if folder == "":
                folder = None
            if header.len() == 0:
                print(Text().center(RawTerminal.get_terminal_size(), Token("─")))
            else:
                print(header.center(RawTerminal.get_terminal_size(), Token("─")))
            answer = subprocess.run(cmd, cwd=folder, shell=True, text=True)
            if answer.returncode != 0 and answer.returncode != 1:
                print(Runner.decode_code(answer.returncode))
        solver.reset()
        to_run_again = False
        if wait_input:
            print(Text().center(RawTerminal.get_terminal_size(), Token("─")))
            print(Text.format("Para [recompilar e] reexecutar digite: {y}", "<enter>"))
            print(Text.format("Para voltar para tela anterior digite: {y}", "q<enter>"))
            valor = input()
            if valor != "n" and valor != "q":
                if to_clear:
                    Runner.clear_screen()
                to_run_again = True
        if to_clear:
            Runner.clear_screen()

        return to_run_again

class Title:
    @staticmethod
    def extract_title(readme_file):
        content = Decoder.load(readme_file)
        title = content.splitlines()[0]
        parts = title.split(" ")
        if parts[0].count("#") == len(parts[0]):
            del parts[0]
        title = " ".join(parts)
        return title

class Drafts:
    ts_draft = r"""
const input = () => ""; //essa função será gerada pelo tko na execução
export {};

function main() {
    console.log("qxcode");
}
main();
"""[1:]

    c_draft = r"""
#include <stdio.h>

int main() {
    puts("qxcode");
    return 0;
}

"""[1:]

    cpp_draft = r"""
#include <iostream>

int main() {
    std::cout << "qxcode\n";
}

"""[1:]

    java_draft = r"""
public class draft {
    public static void main(String args[]) {
        System.out.println("qxcode");
    }
}

"""[1:]

    go_draft = (
        r"package main""\n"
        r'import "fmt"'"\n"
        r"func main() {""\n"
        r'    fmt.Println("qxcode")''\n'
        r"}""\n"
    )
    
    yaml_draft = r"""
build: comando para construir o executável
run: comando para rodar o programa
"""[1:]


    drafts = {'c': c_draft, 'cpp': cpp_draft, 'ts': ts_draft, 'java': java_draft, 'go': go_draft, 'yaml': yaml_draft}

    @staticmethod
    def load_drafs(folder: str, lang: str) -> list[str]:
        folder = os.path.normpath(os.path.abspath(folder))
        draft_list: list[str] = []
        allowed = [lang]
        if lang == "c":
            allowed.append("h")
        if lang == "cpp":
            allowed.append("h")
            allowed.append("hpp")
        if not os.path.isdir(folder):
            return []
        for root, _, files in os.walk(folder):
            cut_root = root[len(folder):]
            pieces = cut_root.split(os.sep)
            if any([piece.startswith(".") for piece in pieces]) or any([piece.startswith("_") for piece in pieces]):
                continue
            for file in files:
                if file.endswith(tuple(allowed)):
                    draft_list.append(os.path.join(root, file))
        return draft_list


# from tko.play.grade_message import GradeMessage


class TaskAction:
    BAIXAR   = "Baixar  "
    EXECUTAR = "Escolher"
    VISITAR  = "Visitar "
    EXPANDIR = "Expandir"
    CONTRAIR = "Contrair"
    BLOQUEIO = "Travado"

class TaskTree:

    def __init__(self, settings: Settings, rep: Repository, fman: FloatingManager):
        self.settings = settings
        self.app = settings.app
        self.game = rep.game
        self.rep = rep
        self.fman = fman
        self.style = Border(settings.app)
        self.colors = settings.colors
        self.items: List[TreeItem] = []
        self.all_items: Dict[str, TreeItem] = {}
        self.selected_item: str = ""
        self.index_begin = 0
        self.max_title = 0
        self.search_text = ""
        self.load_all_items()
        self.load_from_rep()
        self.update_tree(admin_mode=Flags.admin, first_loop=True)
        self.reload_sentences()

    def load_all_items(self):
        for c in self.game.clusters.values():
            self.all_items[c.key] = c
            for q in c.get_quests():
                self.all_items[q.key] = q
                for t in q.get_tasks():
                    self.all_items[t.key] = t

    def load_from_rep(self):
        # self.new_items: List[str] = [v for v in self.rep.get_new_items()]
        self.expanded: List[str] = [v for v in self.rep.get_expanded()]
        self.selected_item = self.rep.get_selected()

        # tasks = self.rep.get_tasks()
        # for key, serial in tasks.items():
        #     if key in self.game.tasks:
        #         self.game.tasks[key].load_from_db(serial)

    def save_on_rep(self):
        self.rep.set_expanded(self.expanded)
        # self.rep.set_new_items([x for x in set(self.new_items)])
        self.rep.set_selected(self.selected_item)
        tasks = {}
        for t in self.game.tasks.values():
            if not t.is_db_empty():
                tasks[t.key] = t.save_to_db()
        self.rep.set_tasks(tasks)

    def update_tree(self, admin_mode: bool, first_loop: bool = False):
        if not admin_mode:
            reachable_clusters = [c.key for c in self.game.clusters.values() if c.is_reachable()]
            reachable_quests = [q.key for q in self.game.quests.values() if q.is_reachable()]
            old_reachable = reachable_clusters + reachable_quests

        self.game.update_reachable_and_available()
            
        if not admin_mode:
            reachable_clusters = [c.key for c in self.game.clusters.values() if c.is_reachable()]
            reachable_quests = [q.key for q in self.game.quests.values() if q.is_reachable()]
            reachable_keys = reachable_quests + list(self.game.clusters.keys())
            for key in self.expanded:
                if key not in reachable_keys:
                    self.expanded.remove(key)
            # if not first_loop:
            #     for key in reachable_keys:
            #         if key not in old_reachable and key not in self.new_items:
            #             self.new_items.append(key)

        # remove expanded items from new
        # self.new_items = [item for item in self.new_items if item not in self.expanded]

    def __update_max_title(self):
        min_value = 50
        items = []
        for c in self.game.clusters.values():
            if c.key in self.game.clusters.keys():
                items.append(len(c.title))
                if c.key in self.expanded:
                    for q in c.get_quests():
                        items.append(len(q.get_full_title()) + 2)
                        if q.key in self.expanded:
                            for t in q.get_tasks():
                                items.append(len(t.title) + 6)

        self.max_title = min_value
        if len(items) > 0:
            self.max_title = max(items)
        if self.max_title < min_value:
            self.max_title = min_value

    def __str_task(self, focus_color: str, t: Task, lig_cluster: str, lig_quest: str, quest_reachable: bool) -> Text:
        down_symbol = Token(" ")
        in_focus = focus_color != ""
        down_symbol = symbols.task_to_visit
        if t.link_type == Task.Types.STATIC_FILE:
            down_symbol = symbols.task_local
        if t.link_type == Task.Types.REMOTE_FILE or t.link_type == Task.Types.IMPORT_FILE:
            down_symbol = symbols.task_to_download
            if self.is_downloaded_for_lang(t):
                down_symbol = symbols.task_downloaded
    
        color_aval = "g" if quest_reachable and t.is_reachable() else "r"
        color_lig_task = color_aval
        if self.app.get_show_hidden() == False and not Flags.admin:
            quest = self.game.quests[t.quest_key]
            if quest.prog:
                if t.key != self.game.quests[t.quest_key].get_tasks()[-1].key:
                    if t.get_percent() < 50:
                        color_lig_task = "y"
                    

        output = Text()
        output.add(" ").addf(color_aval, lig_cluster)
        output.add(" ")
        output.addf(color_lig_task, lig_quest)
        output.add(down_symbol).add(" ")
        output.add(t.get_prog_symbol()).add(" ")
        output.add(symbols.approach_list[t.autonomy]).add(" ")
        output.add(symbols.autonomy_list[t.skill])

        if in_focus:
            output.add(self.style.roundL(focus_color))
        else:
            output.add(" ")

        color = ""
        if in_focus:
            color = "k" + focus_color

        for word in t.title.split(" "):
            if word.startswith("@") or word.startswith("#") or word.startswith("!"):
                output.addf(color + "g", word + " ")
            elif word.startswith(":"):
                output.addf(color + "y", word + " ")
            else:
                output.addf(color, word + " ")

        if in_focus:
            output.add(self.style.roundR(focus_color))
        else:
            output.add(" ")

        if Flags.percent:
            output.ljust(self.max_title + 10, Token(" "))
            prog = int(t.get_percent())
            output.addf("y", str(prog).rjust(3, " ") + "%")

        # if Flags.reward:
        #     xp = ""
        #     for s, v in t.skills.items():
        #         xp += f" +{s}:{v}"
        #     output.addf(self.colors.task_skills, xp)
            
        return output

    def __str_quest(self, has_kids: bool, focus_color: str, q: Quest, lig: str) -> Text:
        con = "━─"
        if q.key in self.expanded and has_kids:
            con = "─┯"

        color_reachable = "g" if q.is_reachable() else "r"
        if self.app.get_show_hidden() == False and not Flags.admin:
            for quest in self.game.quests.values():
                if quest.is_reachable() == False:
                    if q.key in quest.requires:
                        color_reachable = "y"
                        break

        output: Text = Text().addf(color_reachable, " " + lig + con)

        in_focus = focus_color != ""

        if focus_color == "":
            item_key = self.selected_item
            if item_key in list(self.game.quests.keys()):
                quest = self.game.quests[item_key]
                if not quest.is_reachable():
                    if q.key in quest.requires:
                        focus_color = "y"
                # elif quest.key in q.requires:
                #     focus_color = "r"

        if in_focus:
            output.add(self.style.roundL(focus_color))
        else:
            output.add(" ")

        # color = ""
        # if in_focus:
        #     color = "k" + focus_color

        title = q.get_full_title()
        title = title.ljust(self.max_title + 3, ".")

        output.addf(focus_color, title)

        # done = color + self.colors.task_text_done
        # todo = color + self.colors.task_text_todo
        # output.add(self.style.build_bar(title, q.get_percent() / 100, len(title), done, todo, round=False))

        if in_focus:
            output.add(self.style.roundR(focus_color))
        else:
            output.add(" ")

        if Flags.percent:
            output.add(" ").add(q.get_resume_by_percent())
        else:
            output.add(" ").add(q.get_resume_by_tasks())

        # if Flags.minimum:
        #     output.add(" ").add(q.get_requirement())

        # if Flags.reward:
        #     xp = ""
        #     for s, v in q.skills.items():
        #         xp += f" +{s}:{v}"
        #     output.addf(self.colors.task_skills, xp)

        # if q.key in self.new_items:
        #     output.addf(self.colors.task_new, " [new]")

        return output

    def __str_cluster(self, has_kids: bool, focus_color: str, cluster: Cluster) -> Text:
        output: Text = Text()
        opening = "━─"
        if cluster.key in self.expanded and has_kids:
            opening = "─┯"
        color_reachable = "g" if cluster.is_reachable() else "r"
        output.addf(color_reachable, opening)

        color = ""
        if focus_color != "":
            color = "k" + focus_color
        title = cluster.title

        title = cluster.title.ljust(self.max_title + 5, ".")
        if focus_color != "":
            output.add(self.style.roundL(focus_color))
        else:
            output.add(" ")

        output.addf(color, title)
        # done = color + self.colors.task_text_done
        # todo = color + self.colors.task_text_todo
        # output.add(self.style.build_bar(title, cluster.get_percent() / 100, len(title), done, todo, round=False))

        if focus_color != "":
            output.add(self.style.roundR(focus_color))
        else:
            output.add(" ")


        if Flags.percent:
            output.add(" ").add(cluster.get_resume_by_percent())
        else:
            output.add(" ").add(cluster.get_resume_by_quests())
        # if cluster.key in self.new_items:
        #     output.addf(self.colors.task_new, " [new]")

        return output

    def __get_focus_color(self, item: Union[Quest, Cluster]) -> str:
        if not item.is_reachable():
            return "R"
        return self.colors.focused_item

    def filter_by_search(self) -> Tuple[Set[str], str | None]:
        matches: Set[str] = set()
        search = SearchAsc(self.search_text)
        first: None | str = None
        for cluster in self.game.clusters.values():
            if search.inside(cluster.title):
                matches.add(cluster.key)
                first = first or cluster.key
            for quest in cluster.get_quests():
                if search.inside(quest.title):
                    first = first or quest.key
                    matches.add(cluster.key)
                    matches.add(quest.key)
                for task in quest.get_tasks():
                    if search.inside(task.title):
                        first = first or task.key
                        matches.add(cluster.key)
                        matches.add(quest.key)
                        matches.add(task.key)
        return (matches, first)

    def __try_add(self, filtered: set[str], matcher: SearchAsc, item: TreeItem):
        if self.search_text == "":
            self.items.append(item)
            return True
        if item.key in filtered:
            pos = matcher.find(item.sentence.get_text())
            found = pos != -1
            if found:
                for i in range(pos, pos + len(self.search_text)):
                    item.sentence.data[i].fmt = "Y"
            self.items.append(item)
            return True
        return False

    def reload_sentences(self):
        self.__update_max_title()
        self.items = []

        filtered, _ = self.filter_by_search()
        matcher = SearchAsc(self.search_text)

        hide = not self.app.get_show_hidden() and not Flags.admin

        clusters = [self.game.clusters[key] for key in self.game.clusters.keys() if key in filtered]
        if hide:
            clusters = [c for c in clusters if c.is_reachable()]

        for cluster in clusters:
            quests = [q for q in cluster.get_quests() if q.key in self.game.quests.keys() if q.key in filtered]
            if hide:
                quests = [q for q in quests if q.is_reachable()]
            focus_color = self.__get_focus_color(cluster) if self.selected_item == cluster.get_key() else ""
            cluster.sentence = self.__str_cluster(len(quests) > 0, focus_color, cluster)

            self.__try_add(filtered, matcher, cluster)

            if cluster.key not in self.expanded:  # adicionou o cluster, mas não adicione as quests
                continue

            for q in quests:
                tasks =[t for t in q.get_tasks() if t.key in filtered]
                if hide:
                    tasks = [t for t in tasks if t.is_reachable()]
                lig = "├" if q != quests[-1] else "╰"
                focus_color = self.__get_focus_color(q) if self.selected_item == q.get_key() else ""
                q.sentence = self.__str_quest(len(tasks) > 0, focus_color, q, lig)

                # self.items.append(Entry(q, sentence))
                self.__try_add(filtered, matcher, q)
                if q.key in self.expanded:
                    for t in tasks:
                        ligc = "│" if q != quests[-1] else " "
                        ligq = "├ " if t != tasks[-1] else "╰ "
                        focus_color = self.__get_focus_color(q) if self.selected_item == t.get_key() else ""
                        t.sentence = self.__str_task(focus_color, t, ligc, ligq, q.is_reachable())
                        self.__try_add(filtered, matcher, t)
        # verifying if has any selected item
        if self.items:
            found = False
            for item in self.items:
                if item.get_key() == self.selected_item:
                    found = True
                    break
            if found == False:
                self.selected_item = self.items[0].get_key()
                self.reload_sentences()

    def process_collapse_all(self):
        if any([q in self.expanded for q in self.game.quests.keys()]):
            self.expanded = [key for key in self.expanded if key not in self.game.quests.keys()]
        else:
            self.expanded = []

    def process_expand_all(self):
        # if any cluster outside expanded
        expand_clusters = False
        for ckey in self.game.clusters.keys():
            if ckey not in self.expanded:
                expand_clusters = True
        if expand_clusters:
            for ckey in self.game.clusters.keys():
                if ckey not in self.expanded:
                    self.expanded.append(ckey)
        else:
            for qkey in self.game.quests.keys():
                if qkey not in self.expanded:
                    self.expanded.append(qkey)

    def get_selected_index(self) -> int:
        for i, item in enumerate(self.items):
            if item.key == self.selected_item:
                return i
        return 0

    def get_selected_throw(self) -> TreeItem:
        if len(self.items) > 0:
            index = self.get_selected_index()
            return self.items[index]
        raise IndexError("No item selected")
            
    def mass_mark(self):
        obj = self.get_selected_throw()
        if isinstance(obj, Cluster):
            cluster: Cluster = obj
            if cluster.key not in self.expanded:
                self.expanded.append(cluster.key)
                return
            full_open = True
            for q in cluster.get_quests():
                if q.key in self.game.quests.keys() and q.key not in self.expanded:
                    self.expanded.append(q.key)
                    full_open = False
            if not full_open:
                return

            value = None
            for q in obj.get_quests():
                for t in q.get_tasks():
                    if value is not None:
                        self.set_grade(t, value[0], value[1], value[2])
                    else:
                        value = (100, 5, 5) if t.get_percent() < 100 else (0, 0, 0)
                        self.set_grade(t, value[0], value[1], value[2])
        elif isinstance(obj, Quest):
            if obj.key not in self.expanded:
                self.expanded.append(obj.key)
            else:
                value = None
                for t in obj.get_tasks():
                    if value is not None:
                        self.set_grade(t, value[0], value[1], value[2])
                    else:
                        value = (100, 5, 5) if t.get_percent() < 100 else (0, 0, 0)
                        self.set_grade(t, value[0], value[1], value[2])
        elif isinstance(obj, Task):
            value = (100, 5, 5) if obj.get_percent() < 100 else (0, 0, 0)
            self.set_grade(obj, value[0], value[1], value[2])

    def set_grade(self, task: Task, coverage: int, autonomy: int, skill: int):
        obj = task
        if isinstance(obj, Task):
            Logger.get_instance().record_self_grade(obj.key, coverage, autonomy, skill)
            obj.set_coverage(coverage)
            obj.set_autonomy(autonomy)
            obj.set_skill(skill)


    def set_selected_by_index(self, index: int):
        if index < 0:
            index = 0
        if index >= len(self.items):
            index = len(self.items) - 1
        self.selected_item = self.items[index].key

    def arrow_right(self):
        index = self.get_selected_index()
        obj = self.items[index]
        if isinstance(obj, Cluster):
            if not self.unfold(obj):
                self.set_selected_by_index(index + 1)
        elif isinstance(obj, Quest):
            if not self.unfold(obj):
                while True:
                    index += 1
                    if index >= len(self.items):
                        break
                    obj = self.items[index]
                    if isinstance(obj, Cluster) or isinstance(obj, Quest):
                        break
                self.set_selected_by_index(index)
        elif isinstance(obj, Task):
            while True:
                obj = self.items[index]
                if isinstance(obj, Quest) or isinstance(obj, Cluster):
                    break
                if index == len(self.items) - 1:
                    break
                index += 1
            self.set_selected_by_index(index)

    def walk_left_on_quest(self, index: int):
        while True:
            if index == 0:
                break
            index -= 1
            obj = self.items[index]
            if isinstance(obj, Cluster) or isinstance(obj, Quest) and obj.key in self.expanded:
                break
            if index == 0:
                break
        self.set_selected_by_index(index)

    def walk_left_on_cluster(self, index: int):
        while True:
            if index == 0:
                break
            index -= 1
            obj = self.items[index]
            if isinstance(obj, Cluster) or isinstance(obj, Quest):
                break
            if index == 0:
                break
        self.set_selected_by_index(index)

    def arrow_left(self):
        index = self.get_selected_index()
        obj = self.items[index]
        if isinstance(obj, Quest):
            if not self.fold(obj):
                self.walk_left_on_quest(index)
            return
        elif isinstance(obj, Cluster):
            if obj.key in self.expanded:
                self.expanded.remove(obj.key)
                for q in obj.get_quests():
                    try:
                        self.expanded.remove(q.key)
                    except ValueError:
                        pass
            else:
                self.walk_left_on_cluster(index)
            return
        elif isinstance(obj, Task):
            while True:
                obj = self.items[index]
                if isinstance(obj, Quest):
                    break
                index -= 1
            self.set_selected_by_index(index)

    def unfold(self, obj: TreeItem) -> bool:
        if isinstance(obj, Quest) and not obj.is_reachable() and not Flags.admin:
            return False
        if isinstance(obj, Quest) or isinstance(obj, Cluster):
            if obj.key not in self.expanded:
                self.expanded.append(obj.key)
                if isinstance(obj, Cluster):
                    cluster: Cluster = obj
                    if len(cluster.get_quests()) == 1:
                        self.expanded.append(cluster.get_quests()[0].key)
                return True
        return False

    def fold(self, obj: TreeItem) -> bool:
        if isinstance(obj, Quest) or isinstance(obj, Cluster):
            if obj.key in self.expanded:
                self.expanded.remove(obj.key)
                if isinstance(obj, Quest):
                    quest: Quest = obj
                    cluster = self.game.clusters[quest.cluster_key]
                    if len(cluster.get_quests()) == 1:
                        self.expanded.remove(cluster.key)
                        self.selected_item = cluster.key
                return True
        return False

    def toggle(self, obj: Union[Quest, Cluster]):
            if not self.fold(obj):
                self.unfold(obj)

    def get_senteces(self, dy):
        index = self.get_selected_index()
        if len(self.items) < dy:
            self.index_begin = 0
        else:
            if index < self.index_begin:  # subiu na tela
                self.index_begin = index
            elif index >= dy + self.index_begin:  # desceu na tela
                self.index_begin = index - dy + 1

        sentences: List[Text] = []
        for i in range(self.index_begin, len(self.items)):
            sentences.append(self.items[i].sentence)
        return sentences

    def move_up(self):
        index = self.get_selected_index()
        self.set_selected_by_index(index - 1)

    def move_down(self):
        index = self.get_selected_index()
        self.set_selected_by_index(min(len(self.items) - 1, index + 1))

    # return a TaskAction
    def get_task_action(self, task: Task) -> tuple[str, str]:
        if task.link_type == Task.Types.VISITABLE_URL:
            return ("B", TaskAction.VISITAR)
        if task.link_type == Task.Types.STATIC_FILE:
            return ("G", TaskAction.EXECUTAR)
        
        if not self.is_downloaded_for_lang(task):
            return ("Y", TaskAction.BAIXAR)
        return ("G", TaskAction.EXECUTAR)
        
    def is_downloaded_for_lang(self, task: Task):
        folder = task.get_folder()
        lang = self.rep.get_lang()
        if folder is None:
            return False
        drafts = Drafts.load_drafs(folder, lang)
        if drafts:
            return True
        return False
        

class Search:
    def __init__(self, tree: TaskTree, fman: FloatingManager):
        self.tree = tree
        self.game = tree.game
        self.fman = fman
        self.search_mode: bool = False
        self.backup_expanded: List[str] = []
        self.backup_index_selected: str = ""
        self.backup_admin_mode: bool = False

    def toggle_search(self):
        self.search_mode = not self.search_mode
        if self.search_mode:
            self.backup_expanded = [v for v in self.tree.expanded]
            self.backup_index_selected = self.tree.selected_item
            self.backup_admin_mode = Flags.admin
            self.tree.update_tree(admin_mode=True)
            self.tree.process_expand_all()
            self.tree.process_expand_all()
            #self.fman.add_input(Floating(">v").warning().put_text("Digite o texto\nNavegue até o elemento desejado\ne aperte Enter"))
    
    def finish_search(self):
        if self.tree.selected_item == "":
            self.cancel_search()
            return

        self.search_mode = False
        self.tree.search_text = ""
        is_admin = Flags.admin.get_value() == "1"
        selected_key = self.tree.selected_item
        item = self.tree.all_items[selected_key]
        reachable = True
        if isinstance(item, Task):
            reachable = self.game.quests[item.quest_key].is_reachable()
        elif isinstance(item, Quest):
            reachable = item.is_reachable()
        if not reachable:
            Flags.admin.set_value("1")
        self.tree.update_tree(Flags.admin) # usa o mode de antes e vê se acha
        self.tree.reload_sentences()
        
        self.tree.expanded = []
        unit = self.tree.all_items[selected_key]

        if isinstance(unit, Task):
            self.tree.expanded = [unit.cluster_key, unit.quest_key]
        elif isinstance(unit, Quest):
            self.tree.expanded = [unit.key, unit.cluster_key]
        self.tree.reload_sentences()

    # update index to match the first item that matches the search
    def update_index(self):
        _, first = self.tree.filter_by_search()
        self.tree.selected_item = first if first is not None else ""

    def cancel_search(self):
            self.search_mode = False
            self.tree.search_text = ""
            self.tree.expanded = [v for v in self.backup_expanded]
            self.tree.selected_item = self.backup_index_selected

    def process_search(self, key):
        if key == InputManager.esc:
            self.cancel_search()
        elif key == ord("\n"):
            self.finish_search()
        elif any([key == x for x in InputManager.up_list]):
            self.tree.move_up()
        elif any([key == x for x in InputManager.down_list]):
            self.tree.move_down()
        elif any([key == x for x in InputManager.backspace_list]):
            self.tree.search_text = self.tree.search_text[:-1]
            self.update_index()
        elif key >= 32 and key < 127:
            self.tree.search_text += chr(key).lower()
            self.update_index()


class Opener:
    def __init__(self, settings: Settings):
        self.settings = settings
        self.fman: Optional[FloatingManager] = None
        self.folders: List[str] = []
        self.language: str = ""

    def set_fman(self, fman: FloatingManager):
        self.fman = fman
        return self
    
    def set_target(self, folders: List[str]):
        self.folders = folders
        return self

    def set_language(self, language: str):
        self.language = language
        return self

    def open_files(self, files_to_open: List[str]):
        files_to_open = list(set(files_to_open))

        cmd = self.settings.app.get_editor()
        folder = os.path.dirname(os.path.abspath(files_to_open[0]));
        aviso = (Floating("v>")
                .warning()
                .put_sentence(Text().add("Pasta: ").addf("g", folder).add(" "))
                .put_text("Abrindo arquivos com o comando")
                )
        files = [os.path.basename(path) for path in files_to_open]
        aviso.put_sentence(Text().addf("g", f"{cmd}").add(" ").addf("g", " ".join(files)).add(" "))
        self.send_floating(aviso)
        fullcmd = "{} {}".format(cmd, " ".join(files_to_open))
        outfile = tempfile.NamedTemporaryFile(delete=False)
        subprocess.Popen(fullcmd, stdout=outfile, stderr=outfile, shell=True)

    def send_floating(self, Floating: Floating):
        if self.fman is not None:
            self.fman.add_input(Floating)

    @staticmethod
    def try_add(files_to_open: List[str], folder: str, file: str):
        path = os.path.join(folder, file)
        if os.path.isfile(path):
            files_to_open.append(path)

    def load_folder(self, folder: str):
        files_to_open: List[str] = []
        Opener.try_add(files_to_open, folder, "Readme.md")
        # Opener.try_add(files_to_open, folder, "cases.tio")
        files_to_open += Drafts.load_drafs(folder, self.language)
        return files_to_open

    def load_folders_and_open(self):
        files_to_open: List[str] = []
        for folder in self.folders:
            files_to_open += self.load_folder(folder)
        if len(files_to_open) != 0:
            self.open_files(files_to_open)

    def __call__(self):
        self.load_folders_and_open()




class Gui:

    def __init__(self, tree: TaskTree, flagsman: FlagsMan, fman: FloatingManager):
        self.rep = tree.rep
        self.game = tree.game
        self.tree = tree
        self.flagsman = flagsman
        self.fman = fman
        self.settings = tree.settings
        self.search = Search(tree=self.tree, fman=self.fman)
        self.style: Border = Border(self.settings.app)
        self.language = LanguageSetter(self.rep, self.flagsman, self.fman)
        self.colors = self.settings.colors

        self.app = Settings().app


    def get_help_fixed(self):
        color = "W"
        try:
            selected = self.tree.get_selected_throw()
            if isinstance(selected, Task):
                color = "Y"
        except IndexError:
            pass
        act_color, act_text = self.get_activate_label()
        help_fixed: List[Text] = [
            Text() + RToken("C", f"{GuiActions.config} [{GuiKeys.palette}]"),
            Text() + RToken(color, f"{GuiActions.grade} [{GuiKeys.grade_play}]"),
            Text() + RToken(act_color, f"{act_text} [↲]"),
            Text() + RToken(color, f"{GuiActions.edit} [{GuiKeys.edit}]"),
            # Text() + RToken("C", f"{GuiActions.navegar} [wasd]")
            Text() + RToken("C", f"{GuiActions.search} [{GuiKeys.search}]")
        ]
        return help_fixed

    def get_activate_label(self) -> tuple[str, str]:
        output: str = GuiActions.activate
        try:
            obj = self.tree.get_selected_throw()
        except IndexError:
            return "R", " Retornar"
        if isinstance(obj, Quest):
            quest: Quest = obj
            if not Flags.admin and not quest.is_reachable():
                output = TaskAction.BLOQUEIO
            elif quest.key in self.tree.expanded:
                output = TaskAction.CONTRAIR
            else:
                output = TaskAction.EXPANDIR
            return "Y", output
        elif isinstance(obj, Cluster):
            cluster: Cluster = obj
            if cluster.key in self.tree.expanded:
                output = TaskAction.CONTRAIR
            else:
                output = TaskAction.EXPANDIR
            return "Y", output
        elif isinstance(obj, Task):
            color, output = self.tree.get_task_action(obj)
            return color, output
        return "R", " ERRO"

    def center_header_footer(self, value: Text, frame: Frame) -> Text:
        half = value.len() // 2
        x = frame.get_x()
        dy, dx = Fmt.get_size()
        color = "r" if Flags.admin else ""
        full = Text().addf(color, "─" * ((dx//2) - x - 2 - half)).add(value)
        return full

    def show_main_bar(self, frame: Frame):
        top = Text()
        alias_color = "R"
        dirname = self.rep.get_rep_dir()
        dirname = os.path.basename(dirname).upper()
        top.add(self.style.border(alias_color, dirname))
        if Flags.admin:
            color = "W" if Flags.admin else "K"
            top.add(self.style.border(color, "ADMIN"))
        top.add(self.style.border("G", self.rep.get_lang().upper()))
        full = self.center_header_footer(top, frame)
        frame.set_header(full, "<")
        
        # if Flags.flags:
        #     value = self.make_flags_bar()
        #     full = self.center_header_footer(value, frame)
        #     frame.set_footer(full, "<")
        frame.draw()

        dy, dx = frame.get_inner()
        for y, sentence in enumerate(self.tree.get_senteces(dy)):
            if sentence.len() > dx:
                sentence.trim_end(dx - 3)
                sentence.addf("r", "...")
            frame.write(y, 0, sentence)



    def show_skills_bar(self, frame_xp):
        dy, dx = frame_xp.get_inner()
        xp = XP(self.game)
        total_perc = int(
            100 * (xp.get_xp_total_obtained() / xp.get_xp_total_available())
        )
        if Flags.percent:
            text = f" XPTotal:{total_perc}%"
        else:
            text = f" XPTotal:{xp.get_xp_total_obtained()}"

        done = self.colors.main_bar_done
        todo = self.colors.main_bar_todo
        total_bar = self.style.build_bar(text, total_perc / 100, dx - 2, done, todo)
        frame_xp.set_header(Text().addf("/", "Skills"), "^", "{", "}")
        frame_xp.set_footer(Text().add(" ").add(" "), "^")
        frame_xp.draw()

        reachable_quests = [q for q in self.game.quests.values() if q.is_reachable()]
        total, obt = self.game.get_skills_resume(reachable_quests)
        elements: List[Text] = []
        for skill, value in total.items():
            if Flags.percent:
                text = f"{skill}:{int(100 * obt[skill] / value)}%"
            else:
                text = f"{skill}:{obt[skill]}/{value}"
            perc = obt[skill] / value
            done = self.colors.progress_skill_done
            todo = self.colors.progress_skill_todo
            skill_bar = self.style.build_bar(text, perc, dx - 2, done, todo)
            elements.append(skill_bar)
            
        elements.append(total_bar)

        line_breaks = dy - len(elements)
        for skill_bar in elements:
            frame_xp.print(1, skill_bar)
            if line_breaks > 0:
                line_breaks -= 1
                frame_xp.print(1, Text())


    def build_list_sentence(self, items: List[Text]) -> List[Text]:
        out: List[Text] = []
        for x in items:
            color_ini = x.data[0].fmt
            color_end = x.data[-1].fmt
            left = self.style.roundL(color_ini)
            right = self.style.roundR(color_end)
            middle = x.clone()
            if x.data[0].text == "!":
                left = self.style.sharpL(color_ini)
                right = self.style.sharpR(color_end)
                middle.data = x.data[1:]
            out.append(Text().add(left).add(middle).add(right))
        return out

    def build_bottom_array(self):
        array: List[Text] = []
        array += self.get_help_fixed()
        return self.build_list_sentence(array)

    def show_bottom_bar(self):
        lines, cols = Fmt.get_size()
        elems = self.build_bottom_array()
        line_main = Text().add(" ").join(elems) # alignment adjust
        Fmt.write(lines - 1, 0, line_main.center(cols))

    def make_xp_button(self, size):
        if self.search.search_mode:
            text = " Busca: " + self.tree.search_text + symbols.cursor.text
            percent = 0.0
            done = "W"
            todo = "W"
            text = text.ljust(size)
        else:
            text, percent = self.build_xp_bar()
            done = self.colors.main_bar_done
            todo = self.colors.main_bar_todo
            text = text.center(size)
        xpbar = self.style.build_bar(text, percent, len(text), done, todo)
        return xpbar

    def show_top_bar(self, frame: Frame):
        lista = [
            Text() + RToken("Y", f"Sair  [q]"),
            Text() + RToken("Y", f"Ajuda [?]"),
        ]
        help = self.build_list_sentence(lista)
        search = help[0]
        evaluate = help[1]

        pre: List[Text] = []
        pre.append(search)

        pos: List[Text] = []
        pos.append(evaluate)

        limit = frame.get_dx()
        size = limit - Text().add(" ").join(pre + pos).len() - 2
        main_label = self.make_xp_button(size)
        info = Text().add(" ").join(pre + [main_label] + pos)
        frame.write(0, 0, info.center(frame.get_dx()))

    def show_help(self):
        # def empty(value):
        #     pass
        _help: Floating = Floating("v>").set_text_ljust()
        self.fman.add_input(_help)

        _help.set_header_text(Text().add(" Ajuda "))
        # _help.put_text(" Movimentação ".center(dx, symbols.hbar.text))
        _help.put_sentence(Text.format("    Ajuda ").addf("r", GuiKeys.key_help).add("  Abre essa tela de ajuda")
        )

        _help.put_sentence(Text.format("  ").addf("r", "Shift + B")
                           .add("  Habilita ").addf("r", "").addf("R", "ícones").addf("r", "").add(" se seu ambiente suportar"))
        _help.put_sentence(Text() + "" + RToken("g", "setas") + ", " + RToken("g", f"{GuiKeys.left}{GuiKeys.down}{GuiKeys.up}{GuiKeys.right}")  + "  Para navegar entre os elementos")
        _help.put_sentence(Text() + f"   {GuiActions.config} " + RToken("r", f"{GuiKeys.palette}") + "  Abre o menu de ações e configurações")
        _help.put_sentence(Text() + f"   {GuiActions.github} " + RToken("r", f"{GuiKeys.github_web}") + "  Abre tarefa em uma aba do browser")
        _help.put_sentence(Text() + f"   {GuiActions.download} " + RToken("r", f"{GuiKeys.down_task}") + "  Baixa tarefa de código para seu dispositivo")
        _help.put_sentence(Text() + f"   {GuiActions.edit} " + RToken("r", f"{GuiKeys.edit}") + "  Abre os arquivos no editor de código")
        _help.put_sentence(Text() + f"   {GuiActions.activate} " + RToken("r", "↲") + "  Interage com o elemento de acordo com o contexto")
        _help.put_sentence(Text() + "             (baixar, visitar, escolher, compactar, expandir)")
        _help.put_sentence(Text() + f"  {GuiActions.grade} " + RToken("r", GuiKeys.grade_play) + "  Abre tela para auto avaliação")
        _help.put_sentence(Text() + f"    {GuiActions.search} " + RToken("r", f"{GuiKeys.search}") + "  Abre a barra de pesquisa")

        _help.put_sentence(Text())
        _help.put_sentence(Text() + "Você pode mudar o editor padrão com o comando")
        _help.put_sentence(Text() + RToken("g", "             tko config --editor <comando>"))


    def build_xp_bar(self) -> Tuple[str, float]:
        xp = XP(self.game)
        available = xp.get_xp_total_available()
        if available > 0 and xp.get_xp_total_obtained() == available:
            text = "Você atingiu o máximo de xp!"
            percent = 100.0
        else:
            # lang = self.rep.get_lang().upper()
            level = xp.get_level()
            percent = float(xp.get_xp_level_current()) / float(xp.get_xp_level_needed())
            if Flags.percent:
                xpobt = int(100 * xp.get_xp_level_current() / xp.get_xp_level_needed())
                text = "Level:{} XP:{}%".format(level, xpobt)
            else:
                xpobt1 = xp.get_xp_level_current()
                xpobt2 = xp.get_xp_level_needed()
                text = "Level:{} XP:{}/{}".format(level, xpobt1, xpobt2)

        return text, percent

    def get_task_graph(self, task_key: str, width: int, height: int) -> tuple[bool, list[str]]:
        minutes_mode = Flags.graph.get_value() == "1"
        tg = TaskGraph(self.settings, self.rep, task_key, width, height, minutes_mode=minutes_mode)
        if len(tg.collected) == 1:
            return False, []
        graph = tg.get_graph()
        # for y, line in enumerate(graph):
        #     frame.write(y, x, Text().addf("g", line))
        return True, graph
    
    def get_week_graph(self, width: int, height: int) -> tuple[bool, list[str]]:
        week_mode = Flags.graph.get_value() == "1"
        tg = WeekGraph(width, height, week_mode)
        if len(tg.collected) == 1:
            return False, []
        graph = tg.get_graph()
        # for y, line in enumerate(graph):
        #     frame.write(y, x, Text().addf("g", line))
        return True, graph

    def show_graphs(self, frame: Frame):
        lines, cols = frame.get_inner()
        
        now = datetime.datetime.now()
        # parrot = random_get(opening, str(now.hour))
        distance = 18
        made = False
        try:
            selected = self.tree.get_selected_throw()
        except IndexError:
            selected = None
        if Flags.graph.get_value() != "0":
            width = cols - self.tree.max_title - distance - 7
            if width < 5:
                width = 5
            height = lines - 5
            if height < 3:
                height = 3
            if isinstance(selected, Task):
                made, list_data = self.get_task_graph(selected.key, width, height)
            elif isinstance(selected, Cluster) or isinstance(selected, Quest):
                made, list_data = self.get_week_graph(width, height)
        if not made:
            list_data = opening["estuda"].splitlines()
        is_task = isinstance(selected, Task)
        op_one = "minutos " if is_task else "h/semana"
        op_two = "execuções" if is_task else "  h/dia  "
        border = Border(self.settings.app)
        view_button = Text().add("  ").add(border.border("C", f"Mudar Visão [{GuiKeys.graph}]"))
        view_value = Flags.graph.get_value()
        view_button.add(" ").addf("M" if view_value == "0" else "Y", f" Nenhum ")
        view_button.add(" ").addf("M" if view_value == "1" else "Y", f" {op_one} ")
        view_button.add(" ").addf("M" if view_value == "2" else "Y", f" {op_two} ")
        frame.write(0, self.tree.max_title + distance, view_button)
        for y, line in enumerate(list_data):
            frame.write(y + 1, self.tree.max_title + distance, Text().addf("g", line))

    def show_items(self):
        border_color = "r" if Flags.admin else ""
        Fmt.clear()
        self.tree.reload_sentences()
        lines, cols = Fmt.get_size()
        main_sx = cols  # tamanho em x livre
        main_sy = lines  # size em y avaliable

        top_y = -1
        top_dy = 1  #quantas linhas o topo usa
        bottom_dy = 1 # quantas linhas o fundo usa
        mid_y = top_dy # onde o meio começa
        mid_sy = main_sy - top_dy - bottom_dy # tamanho do meio
        left_size = 25
        skills_sx = 0
        flags_sx = 0
        if Flags.skills:
            skills_sx = left_size #max(20, main_sx // 4)
        
        task_sx = main_sx - flags_sx - skills_sx

        frame_top = Frame(top_y, 0).set_size(top_dy + 2, cols)
        self.show_top_bar(frame_top)

        # frame_bottom = Frame(lines - bottom_dy - 1, -1).set_size(bottom_dy + 2, cols + 2)
        self.show_bottom_bar()
        if task_sx > 5: 
            frame_main = Frame(mid_y, 0).set_size(mid_sy, task_sx).set_border_color(border_color)
            self.show_main_bar(frame_main)
        self.show_graphs(frame_main)

        if Flags.skills:
            frame_skills = Frame(mid_y, cols - skills_sx).set_size(mid_sy, skills_sx).set_border_color(border_color)
            self.show_skills_bar(frame_skills)



class Wdir:
    def __init__(self):
        self.__autoload = False
        self.__autoload_folder = ""
        self.__solver: Optional[SolverBuilder] = None
        self.__source_list: List[str] = []
        self.__pack_list: List[List[Unit]] = []
        self.__unit_list: List[Unit] = []
        self.__curses = False
        self.__lang = ""

    def has_solver(self) -> bool:
        return not self.__solver is None

    def has_tests(self) -> bool:
        return len(self.__unit_list) != 0

    def get_solver(self) -> SolverBuilder:
        if self.__solver is None:
            raise Warning("fail: Não foi encontrado arquivo de código")
        return self.__solver
    
    def get_unit_list(self) -> List[Unit]:
        return self.__unit_list

    def get_unit(self, index: int) -> Unit:
        return self.__unit_list[index]
    
    def get_source_list(self) -> List[str]:
        return self.__source_list

    def set_curses(self, value: bool):
        self.__curses = value
        return self

    def set_lang(self, lang: str):
        self.__lang = lang
        return self
    
    def is_curses(self) -> bool:
        return self.__curses

    def is_autoload(self) -> bool:
        return self.__autoload

    def get_autoload_folder(self) -> str:
        return self.__autoload_folder

    def set_solver(self, solver_list: List[str]):
        if len(solver_list) > 0:
            self.__solver = SolverBuilder(solver_list)
        return self

    def set_sources(self, source_list: List[str]):
        self.__source_list = source_list
        return self

    def autoload(self):
        folder = self.__autoload_folder
        folder = os.path.normpath(os.path.abspath(folder))

        # loading source list
        files = os.listdir(folder)
        source_list = [target for target in files if target.endswith(".tio") or target.endswith(".vpl") or target.endswith(".cases")]
        if len(source_list) == 0:
            source_list = [target for target in files if target.endswith(".md")]
        source_list = [os.path.join(folder, x) for x in source_list]
        
        solver_list: list[str] = []
        if self.__lang != "":
            solver_list = Drafts.load_drafs(folder, self.__lang)
        solver_list = sorted(solver_list)

        # if not self.__curses:
        #     print("códigos encontrados: [" + ", ".join(solvers) + "]")
        #     print("testes  encontrados: [" + ", ".join(sources) + "]")
        #     print("Para remover um arquivo da lista, renomeie para sua extensão para .txt")
        self.set_solver(solver_list)
        self.set_sources(source_list)
        self.__autoload = True
        return self

    def set_target_list(self, target_list: List[str]):
        target_list = [os.path.normpath(t) for t in target_list]
        if len(target_list) == 0:
            target_list.append(".")
        if len(target_list) == 1 and os.path.isdir(target_list[0]):
            self.__autoload_folder = target_list[0]
            return self.autoload()
                    
        target_list = [t for t in target_list if t != ""]
        for target in target_list:
            if not os.path.exists(target):
                raise Warning(f"fail: {target} não encontrado")

        solvers = [target for target in target_list if Identifier.get_type(target) == IdentifierType.SOLVER]
        sources = [target for target in target_list if Identifier.get_type(target) != IdentifierType.SOLVER]

        self.set_solver(solvers)
        self.set_sources(sources)
        return self

    def build(self):
        loading_failures = 0
        self.__pack_list = []
        for source in self.__source_list:
            try:
                self.__pack_list.append(Loader.parse_source(source))
            except FileNotFoundError as e:
                print(str(e))
                loading_failures += 1
                pass
        if loading_failures > 0 and loading_failures == len(self.__source_list):
            raise FileNotFoundError("failure: nenhum arquivo de teste encontrado")
        self.__unit_list = sum(self.__pack_list, [])
        self.__number_and_mark_duplicated()
        self.__calculate_grade()
        self.__pad()
        return self

    def calc_grade(self) -> int:
        grade = 100
        for case in self.__unit_list:
            if not case.repeated and (case.received is None or case.expected != case.received):
                grade -= case.grade_reduction
        return max(0, grade)

    # put all the labels with the same length
    def __pad(self):
        if len(self.__unit_list) == 0:
            return
        max_case = max([len(x.case) for x in self.__unit_list])
        max_source = max([len(x.source) for x in self.__unit_list])
        for unit in self.__unit_list:
            unit.case_pad = max_case
            unit.source_pad = max_source

    # select a single unit to execute exclusively
    def filter(self, param: Param.Basic):
        index = param.index
        if index is not None:
            if 0 <= index < len(self.__unit_list):
                self.__unit_list = [self.__unit_list[index]]
            else:
                raise ValueError("Índice fora dos limites: " + str(index))
        return self

    # calculate the grade reduction for the cases without grade
    # the grade is proportional to the number of unique cases
    def __calculate_grade(self):
        unique_count = len([x for x in self.__unit_list if not x.repeated])
        for unit in self.__unit_list:
            if unit.grade is None:
                unit.grade_reduction = math.floor(100 / unique_count)
            else:
                unit.grade_reduction = unit.grade

    # number the cases and mark the repeated
    def __number_and_mark_duplicated(self):
        new_list: List[Unit] = []
        index = 0
        for unit in self.__unit_list:
            unit.index = index
            index += 1
            search = [x for x in new_list if x.inserted == unit.inserted]
            if len(search) > 0:
                unit.repeated = search[0].index
            new_list.append(unit)
        self.__unit_list = new_list

    # sort, unlabel ou rename using the param received
    def manipulate(self, param: Param.Manip):
        # filtering marked repeated
        self.__unit_list = [unit for unit in self.__unit_list if unit.repeated is None]
        if param.to_sort:
            self.__unit_list.sort(key=lambda v: len(v.inserted))
        if param.unlabel:
            for unit in self.__unit_list:
                unit.case = ""
        if param.to_number:
            number = 00
            for unit in self.__unit_list:
                unit.case = LabelFactory().label(unit.case).index(number).generate()
                number += 1

    def unit_list_resume(self) -> List[Text]:
        return [unit.str() for unit in self.__unit_list]

    def sources_names(self) -> List[Tuple[str, int]]:
        out: List[Tuple[str, int]] = []
        if len(self.__pack_list) == 0:
            out.append((symbols.failure.text, 0))
        for i in range(len(self.__pack_list)):
            nome: str = self.__source_list[i].split(os.sep)[-1]
            out.append((nome, len(self.__pack_list[i])))
        return out

    def solvers_names(self) -> List[str]:
        path_list = [] if self.__solver is None else self.__solver.path_list
        if self.__solver is not None and len(path_list) == 0:  # free_cmd
            out = ["free cmd"]
        else:
            out = [os.path.basename(path) for path in path_list]
        return out

    def resume(self) -> Text:
        sources = ["{}({})".format(name, str(count).rjust(2, "0")) for name, count in self.sources_names()]
        __sources = Text().add("Testes:").add("[").addf("y", ", ".join(sources)).add("]")

        __solvers = Text().add("Códigos:").add("[").addf("g", ", ".join(self.solvers_names())).add("]")

        return Text().add(__solvers).add(" ").add(__sources)



class SeqMode(enum.Enum):
    intro = 0
    select = 1
    running = 2
    finished = 3

class Tester:
    def __init__(self, settings: Settings, rep: Repository | None, wdir: Wdir, task: Task):
        self.results: List[Tuple[ExecutionResult, int]] = []
        self.wdir = wdir
        self.rep: Repository | None = rep
        self.unit_list = [unit for unit in wdir.get_unit_list()] # unit list to be consumed
        self.exit = False
        self.task = task
        self.diff_first_line = 1000   # index of first line to show
        self.length = 1  # length of diff
        self.space = 0  # dy space for draw
        self.mode: SeqMode = SeqMode.intro

        self.settings = settings
        self.app = settings.app
        self.borders = Border(settings.app)

        self.locked_index: bool = False
        self.focused_index = 0
        self.resumes: List[str] = []

        self.fman = FloatingManager()
        self.opener: Optional[Opener] = None
        self.dummy_unit = Unit()

        Logger.get_instance().record_pick(self.task.key)


    def set_opener(self, opener: Opener):
        self.opener = opener
        self.opener.set_fman(self.fman)
        return self

    def set_autorun(self, value:bool):
        if value:
            self.mode = SeqMode.running
        return self

    def set_exit(self):
        self.exit = True
        return self

    def print_centered_image(self, image: str, color: str, clear=False, align: str = "."):
        dy, dx = Fmt.get_size()
        lines = image.splitlines()[1:]
        init_y = 4
        if align == "v":
            init_y = dy - len(lines) - 1
        for i, line in enumerate(lines):
            info = Text().addf(color, line).center(dx - 2, Token(" ", " "))
            if clear:
                Fmt.write(i + init_y, 1, Text().add(" " * info.len()))
            else:
                Fmt.write(i + init_y, 1, Text().addf(color, line).center(dx - 2, Token(" ", " ")))

    def show_success(self):
        if self.settings.app.get_use_images():
            out = random_get(images, self.get_folder(), "static")
        else:
            out = random_get(success, self.get_folder(), "static")
        self.print_centered_image(out, "g")
        
    def show_compilling(self, clear=False):
        out = random_get(compilling, self.get_folder(), "random")
        self.print_centered_image(out, "y", clear)

    def show_executing(self, clear=False):
        out = executing
        self.print_centered_image(out, "y", clear, "v")

    def get_folder(self) -> str:
        folder = self.task.get_folder()
        if folder is None:
            raise Warning("Folder is None")
    
        return os.path.basename(folder)

    def get_focused_unit(self) -> Unit:
        if not self.wdir.has_tests():
            return self.dummy_unit
        if len(self.results) != 0:
            _, index = self.results[self.focused_index]
            unit = self.wdir.get_unit(index)
            return unit
        return self.wdir.get_unit(self.focused_index)

    def get_token(self, result: ExecutionResult) -> Token:
        if result == ExecutionResult.SUCCESS:
            return Token(ExecutionResult.get_symbol(ExecutionResult.SUCCESS).text, "G")
        elif result == ExecutionResult.WRONG_OUTPUT:
            return Token(ExecutionResult.get_symbol(ExecutionResult.WRONG_OUTPUT).text, "R")
        elif result == ExecutionResult.COMPILATION_ERROR:
            return Token(ExecutionResult.get_symbol(ExecutionResult.UNTESTED).text, "W")
        elif result == ExecutionResult.EXECUTION_ERROR:
            return Token(ExecutionResult.get_symbol(ExecutionResult.EXECUTION_ERROR).text, "Y")
        else:
            return Token(ExecutionResult.get_symbol(ExecutionResult.UNTESTED).text, "W")

    def store_test_track(self, result: int):
        if self.rep is None:
            return
        track_folder = self.rep.get_track_task_folder(self.task.key)
        tracker = Tracker()
        tracker.set_folder(track_folder)
        tracker.set_files(self.wdir.get_solver().path_list)
        tracker.set_percentage(result)
        tracker.store()

    def store_other_track(self, result: str | None = None):
        if self.rep is None:
            return
        track_folder = self.rep.get_track_task_folder(self.task.key)
        tracker = Tracker()
        tracker.set_folder(track_folder)
        tracker.set_files(self.wdir.get_solver().path_list)
        if result is not None:
            tracker.set_result(result)
        tracker.store()

    def process_one(self):

        if self.mode != SeqMode.running:
            return

        solver = self.wdir.get_solver()

        if solver.compile_error:
            Logger.get_instance().record_compilation_execution_error(self.task.key)
            self.store_other_track(ExecutionResult.COMPILATION_ERROR.value)

            self.mode = SeqMode.finished
            while len(self.unit_list) > 0:
                index = len(self.results)
                self.unit_list = self.unit_list[1:]
                self.results.append((ExecutionResult.COMPILATION_ERROR, index))
            return
        
        if self.locked_index or not self.wdir.has_tests():
            self.mode = SeqMode.finished
            unit = self.get_focused_unit()
            unit.result = UnitRunner.run_unit(solver, unit, self.settings.app.timeout)
            return

        if self.wdir.has_tests():
            index = len(self.results)
            unit = self.unit_list[0]
            self.unit_list = self.unit_list[1:]
            unit.result = UnitRunner.run_unit(solver, unit, self.settings.app.get_timeout())
            self.results.append((unit.result, index))
            self.focused_index = index

        if len(self.unit_list) == 0:
            self.mode = SeqMode.finished
            self.focused_index = 0

            done_list: List[Tuple[ExecutionResult, int]] = []
            fail_list: List[Tuple[ExecutionResult, int]] = []
            for data in self.results:
                unit_result, _ = data
                if unit_result != ExecutionResult.SUCCESS:
                    fail_list.append(data)
                else:
                    done_list.append(data)
            self.results = fail_list + done_list
            percent: int = (100 * len(done_list)) // len(self.results)
            self.task.coverage = percent
            Logger.get_instance().record_test_result(self.task.key, percent)
            self.store_test_track(percent)


    def build_top_line_header(self, frame_dx):
        activity_color = "C"
        solver_color = "W"
        sources_color = "Y"
        running_color = "R"

        # building activity
        activity = Text().add(self.borders.border(activity_color, self.get_folder()))

        # building solvers
        solvers = Text()
        if len(self.get_solver_names()) > 1:
            solvers.add(Text().add(self.borders.roundL("R")).addf("R", f"{GuiActions.tab}").add(self.borders.sharpR("R")))
        for i, solver in enumerate(self.get_solver_names()):
            if len(self.get_solver_names()) > 1:
                solvers.add(" ")
            color = solver_color
            if i == self.task.main_idx:
                color = "G"
            solvers.add(self.borders.border(color, solver))
        
        # replacing with count if running
        done = len(self.results)
        full = len(self.wdir.get_unit_list())
        count_missing = Text().add(self.borders.border(running_color, f"({done}/{full})"))
        if self.mode == SeqMode.running:
            if  self.locked_index:
                solvers = Text().add(self.borders.border("R", "Executando atividade travada"))
            else:
                solvers = count_missing

        # building sources
        source_names = Text().add(", ").join([Text().addf(sources_color, f"{name[0]}({name[1]})") for name in self.wdir.sources_names()])
        if self.wdir.has_tests():
            sources = Text().add(self.borders.roundL(sources_color)).add(source_names).add(self.borders.roundR(sources_color))
        else:
            sources = Text().add(self.borders.border("R", "Nenhum teste cadastrado"))

        # merging activity, solvers and sources in header
        delta = frame_dx - solvers.len()
        left = 1
        right = 1
        if delta > 0:
            delta_left = delta // 2
            left = max(1, delta_left - activity.len())
            delta_right = delta - delta_left
            right = max(1, delta_right - sources.len())
        filler = "─" if self.wdir.has_tests() else " "
        return Text().add(activity).add(filler * left).add(solvers).add(filler * right).add(sources)

    def build_unit_list(self, frame: Frame) -> Text:
        done_list = self.results
        if len(done_list) > 0 and self.locked_index:
            _, index = done_list[self.focused_index]
            done_list[self.focused_index] = (self.get_focused_unit().result, index)
        todo_list: List[Tuple[ExecutionResult, int]] = []
        i = len(done_list)
        for _ in self.unit_list:
            if self.locked_index and i == self.focused_index:
                todo_list.append((self.wdir.get_unit(self.focused_index).result, i))
            else:
                todo_list.append((ExecutionResult.UNTESTED, i))
            i += 1

        i = 0
        show_focused_index = not self.wdir.get_solver().compile_error and not self.mode == SeqMode.intro and not self.is_all_right()
        
        output = Text()
        output.add(self.get_fixed_arrow())


        for unit_result, index in done_list + todo_list:
            foco = i == self.focused_index
            token = self.get_token(unit_result)
            extrap = self.borders.roundL(token.fmt)
            extras = self.borders.roundR(token.fmt)
            if foco and show_focused_index:
                # token.fmt = token.fmt.lower() + ""
                extrap = Token("(")
                extras = Token(")")
                # extrap = Token(" ") #self.borders.roundL("")
                # extras = Token(" ") #self.borders.roundR("")
            if self.locked_index and not foco:
                output.add("  ").addf(token.fmt.lower(), str(index).zfill(2)).addf(token.fmt.lower(), token.text).add(" ")
            else:
                output.add(" ").add(extrap).addf(token.fmt, str(index).zfill(2)).add(token).add(extras)
            i += 1

        size = 6
        to_remove = 0
        index = self.focused_index
        dx = frame.get_dx()
        while (index + 4) * size - to_remove >= dx:
            to_remove += size
        output.data = output.data[:3 * 6] + output.data[3 * 6 + to_remove:]
        return output

    def get_fixed_arrow(self) -> Text:
        
        output = Text()
        # diff
        diff_text = self.get_diff_symbol()
        output.addf("B", f" {GuiKeys.diff} {diff_text} ")
        # if self.settings.app.has_borders():
        #     output.addf("Mb", symbols.sharpR.text)
        # else:
        #     output.addf("B", " ")
        # timer
        # timer = symbols.timer.text
        # value = str(self.settings.app.get_timeout())
        # if value == "0":
        #     value = symbols.infinity.text
        # output.addf("M", f"{timer}l {value}  ")
        color = "R" if self.locked_index else "G"
        if self.settings.app.get_use_borders():
            output.addf(color + "b", symbols.sharpR.text)
        else:
            output.addf("B", " ")

        # travar
        free = symbols.locked_free.text
        locked = symbols.locked_locked.text
        symbol = locked if self.locked_index else free
        output.addf(color, f" {GuiKeys.lock} {symbol} ").add(self.borders.sharpR(color))

        return output

    def draw_top_bar_content(self, frame):
        if not self.wdir.has_tests():
            return
        value = self.get_focused_unit()
        info = Text()
        if self.wdir.get_solver().compile_error:
            info = self.borders.border("R", "Erro de compilação")
        elif value is not None and not self.is_all_right() and not self.mode == SeqMode.intro:
            info = value.str(pad = False)
            # if self.locked_index:
            #     info = self.borders.border(focused_unit_color, info.get_text())
        frame.write(0, 0, Text().add(info).center(frame.get_dx()))

    def draw_top_bar(self):
        # construir mais uma solução
        _, cols = Fmt.get_size()
        size = 1
        if self.wdir.has_tests():
            size = 3
        frame = Frame(0, 0).set_size(size, cols)
        if not self.wdir.has_tests():        
            frame.set_border_none()
        frame.set_header(self.build_top_line_header(frame.get_dx()))
        self.draw_top_bar_content(frame)
        frame.set_footer(self.build_unit_list(frame), "")
        frame.draw()

    def get_diff_symbol(self) -> str:
        if self.settings.app.get_diff_mode() == DiffMode.DOWN:
            return symbols.diff_down.text
        return symbols.diff_left.text

    def make_bottom_line(self) -> List[Text]:
        cmds: List[Text] = []
        text = f"{GuiActions.config} [{GuiKeys.palette}]"
        cmds.append(self.borders.border("C", text))

        color ="Y"
        limite = f"{GuiActions.time_limit} {self.get_time_limit_symbol()} [{GuiKeys.limite}]"
        cmds.append(self.borders.border(color, limite))

        # ativar
        cmds.append(self.borders.border("G", f"{GuiActions.evaluate_tester} [{symbols.newline.text}]"))
        #editar
        if self.opener is not None:
            cmds.append(self.borders.border("Y", f"{GuiActions.edit} [{GuiKeys.edit}]"))
        # rodar
        cmds.append(self.borders.border("C", f"{GuiActions.execute_tester} [{GuiKeys.execute_tester}]"))
            
        return cmds

    def show_bottom_line(self):
        lines, cols = Fmt.get_size()
        out = Text().add(" ").join(self.make_bottom_line())
        Fmt.write(lines - 1, 0, out.center(cols, Token(" ")))

    def is_all_right(self):
        if self.locked_index or len(self.results) == 0:
            return False
        if not self.mode == SeqMode.finished:
            return False
        for result, _ in self.results:
            if result != ExecutionResult.SUCCESS:
                return False
        return True

    def draw_main(self):
        unit = self.get_focused_unit()
        lines, cols = Fmt.get_size()
        if self.wdir.has_tests():
            y_out = 2
            self.space = lines - 4
        else:
            y_out = 0
            self.space = lines - 2
        frame = Frame(y_out, -1).set_inner(self.space, cols)

        if self.is_all_right():
            self.show_success()
            return
        
        diff_builder = DiffBuilder(cols)
        diff_builder.set_curses()

        if self.wdir.get_solver().compile_error:
            received = self.wdir.get_solver().error_msg
            line_list = [Text().add(line) for line in received.splitlines()]
        elif self.settings.app.get_diff_mode() == DiffMode.DOWN or not self.wdir.has_tests():
            ud_diff = DownDiff(cols, unit)
            line_list = ud_diff.build_diff()
        else:
            ss_diff = SideDiff(cols, unit)
            line_list = ss_diff.build_diff()

        self.length = max(1, len(line_list))

        if self.length - self.diff_first_line < self.space:
            self.diff_first_line = max(0, self.length - self.space)

        if self.diff_first_line >= self.length:
            self.diff_first_line = self.length - 1

        if self.diff_first_line < self.length:
            line_list = line_list[self.diff_first_line:]
        for i, line in enumerate(line_list):
            frame.write(i, 0, Text().add(line))
        return

    def get_solver_names(self):
        return sorted(self.wdir.solvers_names())
    
    def main(self, scr):
        InputManager.fix_esc_delay()
        curses.curs_set(0)  # Esconde o cursor
        Fmt.init_colors()  # Inicializa as cores
        Fmt.set_scr(scr)  # Define o scr como global
        while not self.exit:

            Fmt.clear()
            if self.mode == SeqMode.running:
                if self.wdir.get_solver().not_compiled():
                    self.draw_top_bar()
                    self.show_bottom_line()
                    self.show_compilling()
                    Fmt.refresh()
                    try:
                        self.wdir.get_solver().prepare_exec()
                    except CompileError as e:
                        self.fman.add_input(Floating("v>").error().put_text(e.message))
                        self.mode = SeqMode.finished
                    Fmt.clear()
                    self.draw_top_bar()
                    self.show_bottom_line()
                    Fmt.refresh()
                self.process_one()
            self.draw_top_bar()

            if self.mode == SeqMode.intro:
                self.print_centered_image(random_get(intro, self.get_folder()), "y")
            else:
                self.draw_main()
            
            self.show_bottom_line()

            if self.fman.has_floating():
                self.fman.draw_warnings()

            if self.mode == SeqMode.running:
                Fmt.refresh()
                continue

            if self.fman.has_floating():
                key = self.fman.get_input()
            else:
                key = Fmt.getch()

            fn_exec = self.process_key(key)
            if fn_exec is not None:
                return fn_exec

    def run_exec_mode(self):
        self.mode = SeqMode.running
        if self.wdir.is_autoload():
            self.wdir.autoload()
            self.wdir.get_solver().set_main(self.get_solver_names()[self.task.main_idx])
        self.mode = SeqMode.finished
        Logger.get_instance().record_freerun(self.task.key)
        self.store_other_track("Execução Livre")
        header = self.build_top_line_header(RawTerminal.get_terminal_size())
        return lambda: Free.free_run(self.wdir.get_solver(), show_compilling=True, to_clear=True, wait_input=True, header=header)

    def run_test_mode(self):
        self.mode = SeqMode.running
        if self.wdir.is_autoload():
            self.wdir.autoload() # reload sources and solvers
        self.wdir.build() # reload cases

        Fmt.clear()

        solver_names = self.get_solver_names()
        solver_size = len(solver_names)
        index = self.task.main_idx
        solver_selected = solver_names[index % solver_size]
        self.wdir.get_solver().set_main(solver_selected).reset() # clear old compilation
        
        if self.locked_index:
            for i in range(len(self.results)):
                _, index = self.results[i]
                self.results[i] = (ExecutionResult.UNTESTED, index)
        else:
            self.focused_index = 0
            self.results = []
            self.unit_list = [unit for unit in self.wdir.get_unit_list()]

    def send_char_not_found(self, key):
        if not Flags.devel:
            return
        self.fman.add_input(Floating("v>").error()
                    .put_text("Tecla")
                    .put_text(f"char {chr(key)}")
                    .put_text(f"code {key}")
                    .put_text("não reconhecida")
                    .put_text("")
                    )

    def go_left(self):
        if self.mode == SeqMode.intro:
            self.mode = SeqMode.select
        if self.mode == SeqMode.finished:
            self.mode = SeqMode.select
        if self.locked_index:
            self.fman.add_input(Floating("v>").warning().put_text("←\nAtividade travada\nAperte {} para destravar".format(GuiKeys.lock)))
            return
        if not self.wdir.get_solver().compile_error:
            self.focused_index = max(0, self.focused_index - 1)
            self.diff_first_line = 1000

    def go_right(self):
        if self.mode == SeqMode.intro:
            self.mode = SeqMode.select
            self.focused_index = 0
            return
        if self.mode == SeqMode.finished:
            self.mode = SeqMode.select
        if self.locked_index:
            self.fman.add_input(Floating("v>").warning().put_text("→\nAtividade travada\nAperte {} para destravar".format(GuiKeys.lock)))
            return
        if not self.wdir.get_solver().compile_error:
            self.focused_index = min(len(self.wdir.get_unit_list()) - 1, self.focused_index + 1)
            self.diff_first_line = 1000

    def go_down(self):
        if self.mode == SeqMode.intro:
            self.mode = SeqMode.select
        self.diff_first_line += 1

    def go_up(self):
        if self.mode == SeqMode.intro:
            self.mode = SeqMode.select
        self.diff_first_line = max(0, self.diff_first_line - 1)

    def change_main(self):
        if len(self.get_solver_names()) == 1:
            self.fman.add_input(
                Floating("v>").warning()
                .put_text("Seu projeto só tem um arquivo de solução")
                .put_text("Essa funcionalidade troca qual dos arquivos")
                .put_text("de solução será o principal.")
            )
            return
        self.task.main_idx = (self.task.main_idx + 1) % len(self.get_solver_names())

    def lock_unit(self):
        self.locked_index = not self.locked_index
        if self.mode == SeqMode.intro:
            self.mode = SeqMode.select
        if self.locked_index:
            for i in range(len(self.results)):
                _, index = self.results[i]
                self.results[i] = (ExecutionResult.UNTESTED, index)

    def get_time_limit_symbol(self):
        if self.settings.app.get_timeout() == 0:
            return symbols.infinity.text
        return str(self.settings.app.get_timeout())

    def change_limit(self):
            valor = self.settings.app.get_timeout()
            if valor == 0:
                valor = 1
            else:
                valor *= 2
            if valor >= 5:
                valor = 0
            self.settings.app.set_timeout(valor)
            self.settings.save_settings()


    def process_key(self, key):
        if key == ord('q') or any([key == x for x in InputManager.backspace_list]):
            self.set_exit()
        elif key == InputManager.esc:
            if self.locked_index:
                self.locked_index = False
            else:
                self.set_exit()
        elif any([key == x for x in InputManager.left_list]) or key == ord(GuiKeys.left):
            self.go_left()
        elif any([key == x for x in InputManager.right_list]) or key == ord(GuiKeys.right):
            self.go_right()
        elif key == curses.KEY_DOWN or key == ord(GuiKeys.down):
            self.go_down()
        elif key == curses.KEY_UP or key == ord(GuiKeys.up):
            self.go_up()
        elif key == ord(GuiKeys.toggle_main):
            self.change_main()
        elif key == ord(GuiKeys.execute_tester):
            return self.run_exec_mode()
        elif key == ord(GuiKeys.evaluate):
            self.run_test_mode()
        elif key == ord(GuiKeys.lock):
            self.lock_unit()
        elif key == ord(GuiKeys.edit):
            if self.opener is not None:
                self.opener.load_folders_and_open()
        elif key == ord(GuiKeys.limite):
            self.change_limit()
            self.settings.save_settings()
        elif key == ord(GuiKeys.diff):
            self.settings.app.toggle_diff()
            self.settings.save_settings()
        elif key == ord(GuiKeys.borders):
            self.settings.app.toggle_borders()
            self.settings.save_settings()
        elif key == ord(GuiKeys.images):
            self.settings.app.toggle_images()
            self.settings.save_settings()
        elif key == ord(GuiKeys.palette):
            self.command_pallete()
        elif key != -1 and key != curses.KEY_RESIZE:
            self.send_char_not_found(key)

    def command_pallete(self):
        options: list[FloatingInputData] = []

        def icon(value: bool):
            return "✓" if value else "✗"
        
        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mudar arquivo {y} de execução", symbols.action, "principal"),
                self.change_main,
                "TAB"
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mudar modo {y}}", self.get_diff_symbol(), "Diff"),
                self.app.toggle_diff,
                GuiKeys.diff
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mudar {y} de tempo de execução: {r}", symbols.action, "Limite", self.get_time_limit_symbol()),
                self.change_limit,
                GuiKeys.limite
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Testar {y} os casos ou apenas o selecionado", icon(not self.locked_index), "Todos"),
                self.lock_unit,
                GuiKeys.lock
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y}", icon(self.app.get_use_borders()), "Bordas"),
                self.app.toggle_borders,
                GuiKeys.borders
            )
        )
        
        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y}", icon(self.app.get_use_images()), "Imagens"),
                self.app.toggle_images, 
                GuiKeys.images
            )
        )

        self.fman.add_input(
            FloatingInput("v").set_text_ljust()
                      .set_header(" Selecione uma ação da lista ")
                      .set_options(options)
                      .set_exit_on_enter(False)
                      .set_footer(" Use Enter para aplicar e Esc para Sair ")
        )

    def run(self):
        while True:
            free_run_fn = curses.wrapper(self.main)
            if free_run_fn == None:
                Logger.get_instance().record_back(self.task.key)
                break
            else:
                while(True):
                    try:
                        repeat = free_run_fn()
                        if repeat == False:
                            break
                    except CompileError as e:
                        self.mode = SeqMode.finished
                        Logger.get_instance().record_compilation_execution_error(self.task.key)
                        self.store_other_track(ExecutionResult.COMPILATION_ERROR.value)
                        print(e)
                        input("Pressione enter para continuar")
                        break




class tkoFilterMode:
    @staticmethod
    def deep_copy_and_change_dir():
        # path to ~/.tko_filter
        filter_path = os.path.join(os.path.expanduser("~"), ".tko_filter")

        CodeFilter.cf_recursive(".", filter_path, force=True)
        os.chdir(filter_path)

class Run:

    def __init__(self, settings: Settings, target_list: List[str], param: Optional[Param.Basic]):
        self.settings = settings
        self.target_list: List[str] = target_list
        if param is None:
            self.param = Param.Basic()
        else:
            self.param = param
        self.wdir: Wdir = Wdir()
        self.wdir_builded = False
        self.rep: Repository | None
        self.__curses_mode: bool = False
        self.__lang = ""
        self.__rep: Repository | None = None
        self.__task: Task | None = None
        self.__track_folder: str = ""
        self.__opener: Opener | None = None
        self.__run_without_ask: bool = True

    def set_curses(self, value:bool=True):
        self.__curses_mode = value
        return self
   
    def set_lang(self, lang:str):
        self.__lang = lang
        return self
    
    def set_opener(self, opener: Opener):
        self.__opener = opener
        return self

    def set_run_without_ask(self, value:bool):
        self.__run_without_ask = value
        return self

    def set_task(self, rep: Repository, task: Task):
        self.__rep = rep
        self.__task = task
        return self
    
    def get_task(self) -> Task:
        if self.__task is None:
            raise Warning("Task não definida")
        return self.__task

    def execute(self):
        if len(self.target_list) == 0:
            self.__try_load_rep(".")
            self.__try_load_task(".")

        elif len(self.target_list) == 1 and os.path.isdir(self.target_list[0]):
            self.__try_load_rep(self.target_list[0])
            self.__try_load_task(self.target_list[0])

        if not self.wdir_builded:
            self.build_wdir()

        if self.__missing_target():
            return
        
        if self.__list_mode():
            return
        
        if self.wdir.has_solver():
            if self.__rep is None:
                solver_path = self.wdir.get_solver().path_list[0]
                dirname = os.path.dirname(os.path.abspath(solver_path))
                self.__try_load_rep(dirname)
                self.__try_load_task(dirname)

            if self.__task is None:
                self.__fill_task()

            if self.__rep is not None:
                logger = Logger.get_instance()
                history_file = self.__rep.get_history_file()
                logger.set_log_files(history_file)

        if self.__free_run():
            return
        self.__show_diff()
        return
    
    def __try_load_rep(self, dirname: str) -> bool:
        repo_path = Repository.rec_search_for_repo(dirname)
        if repo_path == "":
            return False
        rep = Repository(repo_path).load_config().load_game()
        self.__rep = rep
        if rep.get_lang() != "":
            self.__lang = rep.get_lang()
        return True

    def __try_load_task(self, dirname: str) -> bool:
        if self.__rep is None:
            return False
        rep: Repository = self.__rep
        task_key = rep.get_key_from_task_folder(dirname)
        if task_key == "":
            return False
        task = rep.game.tasks.get(task_key)
        if task is None:
            return False
        self.__task = task
        self.__track_folder = rep.get_track_task_folder(task_key)
        return True

    def __remove_duplicates(self):
        # remove duplicates in target list keeping the order
        self.target_list = list(dict.fromkeys(self.target_list))

    def __change_targets_to_filter_mode(self):
        if self.param.filter:
            old_dir = os.getcwd()

            print(Text.format(" Entrando no modo de filtragem ").center(RawTerminal.get_terminal_size(), "═"))
            tkoFilterMode.deep_copy_and_change_dir()  
            # search for target outside . dir and redirect target
            new_target_list = []
            for target in self.target_list:
                if ".." in target:
                    new_target_list.append(os.path.normpath(os.path.join(old_dir, target)))
                elif os.path.exists(target):
                    new_target_list.append(target)
            self.target_list = new_target_list

    def __print_top_line(self):
        if self.wdir is None:
            return

        print(Text().add(symbols.opening).add(self.wdir.resume()), end="")
        print(" [", end="")
        first = True
        for unit in self.wdir.get_unit_list():
            if first:
                first = False
            else:
                print(" ", end="")
            solver = self.wdir.get_solver()
            if solver is None:
                raise Warning("Solver vazio")
            unit.result = UnitRunner.run_unit(solver, unit)
            print(Text() + ExecutionResult.get_symbol(unit.result), end="")
        print("]")

    def __print_diff(self):
        if self.wdir is None or not self.wdir.has_solver():
            return
        
        if self.param.diff_count == DiffCount.QUIET:
            return
        
        if self.wdir.get_solver().compile_error:
            print(self.wdir.get_solver().error_msg)
            return
        
        results = [unit.result for unit in self.wdir.get_unit_list()]
        if ExecutionResult.EXECUTION_ERROR not in results and ExecutionResult.WRONG_OUTPUT not in results:
            return
        
        if not self.param.compact:
            for elem in self.wdir.unit_list_resume():
                print(elem)

        
        if self.param.diff_count == DiffCount.FIRST:
            # printing only the first wrong case
            wrong = [unit for unit in self.wdir.get_unit_list() if unit.result != ExecutionResult.SUCCESS][0]
            if self.param.diff_mode == DiffMode.DOWN:
                ud_diff_builder = DownDiff(RawTerminal.get_terminal_size(), wrong).to_insert_header()
                for line in ud_diff_builder.build_diff():
                    print(line)
            else:
                ss_diff_builder = SideDiff(RawTerminal.get_terminal_size(), wrong).to_insert_header(True)
                for line in ss_diff_builder.build_diff():
                    print(line)
            return

        if self.param.diff_count == DiffCount.ALL:
            for unit in self.wdir.get_unit_list():
                if unit.result != ExecutionResult.SUCCESS:
                    if self.param.diff_mode == DiffMode.DOWN:
                        ud_diff_builder = DownDiff(RawTerminal.get_terminal_size(), unit).to_insert_header()
                        for line in ud_diff_builder.build_diff():
                            print(line)
                    else:
                        ss_diff_builder = SideDiff(RawTerminal.get_terminal_size(), unit).to_insert_header(True)
                        for line in ss_diff_builder.build_diff():
                            print(line)

    def build_wdir(self):
        self.wdir_builded = True
        self.__remove_duplicates()
        self.__change_targets_to_filter_mode()
        try:
            self.wdir = Wdir().set_curses(self.__curses_mode).set_lang(self.__lang).set_target_list(self.target_list).build().filter(self.param)
        except FileNotFoundError as e:
            if self.wdir.has_solver():
                self.wdir.get_solver().error_msg += str(e)
                self.wdir.get_solver().compile_error = True
        return self.wdir

    def __missing_target(self) -> bool:
        if self.wdir is None:
            return False
        if not self.wdir.has_solver() and not self.wdir.has_tests():
            if not self.__curses_mode:
                print(Text().addf("", "fail: ") + "Nenhum arquivo de código ou de teste encontrado.")
            return True
        return False
    
    def __list_mode(self) -> bool:
        if self.wdir is None:
            return False

        # list mode
        if not self.wdir.has_solver() and self.wdir.has_tests():
            print(Text.format("Nenhum arquivo de código encontrado. Listando casos de teste.").center(RawTerminal.get_terminal_size(), Token("╌")), flush=True)
            print(self.wdir.resume())
            for line in self.wdir.unit_list_resume():
                print(line)
            return True
        return False

    def __free_run(self) -> bool:
        if self.wdir is None:
            return False
        if self.wdir.has_solver() and (not self.wdir.has_tests()) and not self.__curses_mode:
            if self.__task is not None:
                Logger.get_instance().record_freerun(self.get_task().key)
            Free.free_run(self.wdir.get_solver(), show_compilling=False, to_clear=False, wait_input=False)
            return True
        return False

    def __create_opener_for_wdir(self) -> Opener:
        opener = Opener(self.settings)
        folders = []
        targets = ["."]
        if self.target_list:
            targets = self.target_list
        for f in targets:
            if os.path.isdir(f) and f not in folders:
                folders.append(f)
            else:
                folder = os.path.dirname(os.path.abspath(f))
                if folder not in folders:
                    folders.append(folder)
        opener.set_target(folders)
        if self.wdir.get_solver().path_list:
            solver_zero = self.wdir.get_solver().path_list[0]
            lang = solver_zero.split(".")[-1]
            opener.set_language(lang)
        return opener

    def __fill_task(self):
        task = Task()
        sources = self.wdir.get_source_list()
        solver = self.wdir.get_solver()
        if len(sources) > 0:
            task.folder = os.path.abspath(sources[0])
        elif solver is not None and solver.path_list:
            task.folder = os.path.abspath(self.wdir.get_solver().path_list[0])
        else:
            task.folder = os.path.abspath(os.getcwd())
        
        if os.path.isfile(task.folder):
            task.folder = os.path.dirname(task.folder)

        self.key = os.path.dirname(task.folder)

        self.__task = task

    def __run_diff_on_curses(self):
        cdiff = Tester(self.settings, self.__rep, self.wdir, self.get_task())
        if self.__opener is not None:
            cdiff.set_opener(self.__opener)
        else:
            cdiff.set_opener(self.__create_opener_for_wdir())
        cdiff.set_autorun(self.__run_without_ask)
        cdiff.run()

    def __run_diff_on_raw_term(self):
        print(Text.format(" Testando o código com os casos de teste ").center(RawTerminal.get_terminal_size(), "═"))
        self.__print_top_line()
        self.__print_diff()
        correct = [unit for unit in self.wdir.get_unit_list() if unit.result == ExecutionResult.SUCCESS]
        percent = (len(correct) * 100) // len(self.wdir.get_unit_list())
        if self.__task is None:
            return
        if self.__track_folder == "":
            return
        Logger.get_instance().record_test_result(self.get_task().key, percent)
        tracker = Tracker()
        tracker.set_folder(self.__track_folder)
        tracker.set_files(self.wdir.get_solver().path_list)
        tracker.set_percentage(percent)
        tracker.store()

    def __show_diff(self):
        if self.wdir is None:
            return
        
        if self.__task is None:
            self.__fill_task()
        
        if self.__curses_mode:
            self.__run_diff_on_curses()
        else:
            self.__run_diff_on_raw_term()


class CmdBuild:

    def __init__(self, target_out: str, source_list: List[str], param: Param.Manip):
        self.target_out = target_out
        self.source_list = source_list
        self.param = param
        self.quiet = False

    def set_quiet(self, value: bool):
        self.quiet = value
        return self

    def execute(self):
        try:
            wdir = Wdir().set_sources(self.source_list).build()
            wdir.manipulate(self.param)
            Writer.save_target(self.target_out, wdir.get_unit_list(), quiet=self.quiet)
        except FileNotFoundError as e:
            print(str(e))
            return False
        return True



class CmdDown:
    def __init__(self, rep: Repository, task_key: str, settings: Settings):
        self.rep = rep
        self.task_key = task_key
        self.settings = settings
        self.game: Game | None = None
        self.language: str | None = None
        self.destiny_folder: str = ""
        self.readme_path: str = ""
        self.cache_url: str = ""
        self.mapi_file: str = ""

    def set_fnprint(self, fnprint: Callable[[str], None]):
        DownProblem.fnprint = fnprint
        return self

    def set_game(self, game: Game):
        self.game = game
        return self
    
    def set_language(self, language: str):
        self.language = language
        return self
    

    def remove_empty_destiny_folder(self):
        if len(os.listdir(self.destiny_folder)) == 0:
                os.rmdir(self.destiny_folder)

    def download_readme(self, readme_remote_url) -> bool:
        try:
            DownProblem.down_readme(self.readme_path, readme_remote_url)
            return True
        except urllib.error.HTTPError:
            DownProblem.fnprint("falha: Arquivo de descrição não encontrado")
            return False
        except urllib.error.URLError:
            DownProblem.fnprint("falha: Não consegui baixar a atividade, verifique sua internet")
            return False

    def download_mapi(self) -> bool:
        try:
            urllib.request.urlretrieve(self.cache_url + "mapi.json", self.mapi_file)
            return True
        except urllib.error.HTTPError:
            return False
        except urllib.error.URLError:
            DownProblem.fnprint("falha: não consegui baixar a atividade, verifique sua internet")
            return False

    def build_cases_from_readme(self, destiny_folder: str):
        cases_tio_target = os.path.join(destiny_folder, "cases.tio")
        param = Param.Manip()
        cb = CmdBuild(cases_tio_target, [self.readme_path], param)
        cb.set_quiet(True)
        cb.execute()

    def download_from_url(self, task_source: str) -> bool:
        readme_remote_url = RemoteUrl(task_source)
        remote_url = readme_remote_url.get_raw_url()
        self.cache_url = os.path.dirname(remote_url) + "/.cache/"
        self.destiny_folder = self.rep.get_task_folder_for_label(self.task_key)
        self.readme_path =  os.path.join(self.destiny_folder, "Readme.md")
        self.mapi_file = os.path.join(self.destiny_folder, "mapi.json")

        folder_created = DownProblem.create_problem_folder(self.destiny_folder)
        if not self.download_readme(readme_remote_url):
            if folder_created:
                self.remove_empty_destiny_folder()
            return False
        
        lang = self.check_and_select_language()
        
        if self.download_mapi():
            encoding = Decoder.get_encoding(self.mapi_file)
            with open(self.mapi_file, encoding=encoding) as f:
                loaded_json = json.load(f)
            os.remove(self.mapi_file)
            if not DownProblem.unpack_json_drafts(loaded_json, self.destiny_folder, lang):
                DownProblem.create_default_draft(self.destiny_folder, lang)
        else:
            self.build_cases_from_readme(self.destiny_folder)
            DownProblem.create_default_draft(self.destiny_folder, lang)
        DownProblem.fnprint("")
        DownProblem.fnprint("Atividade baixada com sucesso")
        return True

    def download_from_external_file(self, task_source: str) -> bool:
        if not os.path.exists(task_source):
            DownProblem.fnprint("Arquivo fonte não encontrado")
        self.cache_url = os.path.join(os.path.dirname(task_source), ".cache")
        self.destiny_folder = self.rep.get_task_folder_for_label(self.task_key)
        self.readme_path =  os.path.join(self.destiny_folder, "Readme.md")
        self.mapi_file = os.path.join(self.cache_url, "mapi.json")
        folder_created = DownProblem.create_problem_folder(self.destiny_folder)
        # Decoder.save(self.readme_path, Decoder.load(task_source))
        DownProblem.compare_and_save(Decoder.load(task_source), self.readme_path)

        lang = self.check_and_select_language()
        
        if os.path.isfile(self.mapi_file):
            encoding = Decoder.get_encoding(self.mapi_file)
            with open(self.mapi_file, encoding=encoding) as f:
                loaded_json = json.load(f)
            if not DownProblem.unpack_json_drafts(loaded_json, self.destiny_folder, lang):
                if not folder_created:
                    DownProblem.create_default_draft(self.destiny_folder, lang)
        else:
            self.build_cases_from_readme(self.destiny_folder)
            DownProblem.create_default_draft(self.destiny_folder, lang)
        DownProblem.fnprint("")
        DownProblem.fnprint("Atividade carregada com sucesso")
        return True

    def execute(self) -> bool:
        task = self.rep.game.get_task(self.task_key)
        if task.link_type == Task.Types.REMOTE_FILE:
            return self.download_from_url(task.link)
        if task.link_type == Task.Types.IMPORT_FILE:
            return self.download_from_external_file(task.link)
        DownProblem.fnprint("falha: link para atividade não possui link para download")
        return False

    def check_and_select_language(self) -> str:
        language_def = self.rep.get_lang()

        if self.language is None:
            if language_def != "":
                self.language = language_def
            else:
                print("Escolha uma extensão para os rascunhos: [{}]: ".format(", ".join(available_languages)), end="")
                self.language = input()
        return self.language

class DownProblem:
    fnprint: Callable[[str], None] = print

    @staticmethod
    def __create_file(content, path, label=""):
        Decoder.save(path, content)
        DownProblem.fnprint(path + " " + label)

    @staticmethod
    def unpack_json_drafts(loaded, destiny, lang: str) -> bool:
        found = False
        if "draft" in loaded:
            if lang in loaded["draft"]:
                for file in loaded["draft"][lang]:
                    path = os.path.join(destiny, file["name"])
                    DownProblem.__create_file(file["contents"], path, "(Rascunho)")
                    found = True

        return found

    @staticmethod
    def  compare_and_save(content: str, path: str):
        if not os.path.exists(path):
            Decoder.save(path, content)
            DownProblem.fnprint(path + " (Novo)")
        else:
            path_content = Decoder.load(path)
            if path_content != content:
                DownProblem.fnprint(path + " (Atualizado)")
                Decoder.save(path, content)
            else:
                DownProblem.fnprint(path + " (Inalterado)")

    @staticmethod
    def down_readme(readme_path: str,  remote_url: RemoteUrl):
        temp_file = tempfile.mktemp()
        remote_url.download_absolute_to(temp_file)
        content = Decoder.load(temp_file)
        DownProblem.compare_and_save(content, readme_path)
    
    @staticmethod
    def create_problem_folder(destiny: str) -> bool:
        if not os.path.exists(destiny):
            os.makedirs(destiny, exist_ok=True)
            return True
        
        DownProblem.fnprint("Pasta do problema "+ destiny + " encontrada, juntando conteúdo.")
        return False

    @staticmethod
    def create_default_draft(destiny: str, language: str):
        filename = "draft."
        draft_path = os.path.join(destiny, filename + language)

        if not os.path.exists(draft_path):
            with open(draft_path, "w", encoding="utf-8") as f:
                if language in Drafts.drafts:
                    f.write(Drafts.drafts[language])
                else:
                    f.write("")
            DownProblem.fnprint(draft_path + " (Vazio)")
        else:
            DownProblem.fnprint(draft_path + " (Não sobrescrito)")
# from tko.game.graph import Graph









class PlayActions:

    def __init__(self, gui: Gui):
        self.app = Settings().app
        self.settings = Settings()
        self.fman = gui.fman
        self.rep = gui.rep
        self.tree = gui.tree
        self.game = gui.game
        self.graph_opened: bool = False
        self.gui = gui

    def gen_graph_path(self) -> str:
        return os.path.join(self.rep.get_rep_dir(), "graph.png")
        

    def open_link_without_stdout_stderr(self, link: str):
        outfile = tempfile.NamedTemporaryFile(delete=False)
        subprocess.Popen("python3 -m webbrowser -t {}".format(link), stdout=outfile, stderr=outfile, shell=True)

    def get_task_folder(self, task: Task) -> str:
        if task.folder is None:
            raise Exception("Folder não encontrado")
        return task.folder

    def open_code(self):
        obj = self.tree.get_selected_throw()
        if isinstance(obj, Task):
            task: Task = obj
            folder = self.rep.get_task_folder_for_label(task.key)
            if os.path.exists(folder):
                opener = Opener(self.settings).set_fman(self.fman)
                opener.set_target([folder]).set_language(self.rep.get_lang())
                opener.load_folders_and_open()
            else:
                self.fman.add_input(
                    Floating("v>")
                    .put_text("\nO arquivo de código não foi encontrado.\n")
                    .error()
                )
        else:
            self.fman.add_input(
                Floating("v>")
                .put_text("\nVocê só pode abrir o código")
                .put_text("de tarefas baixadas.\n")
                .error()
            )

    def open_link(self):
        obj = self.tree.get_selected_throw()
        if isinstance(obj, Task):
            task: Task = obj
            if task.link_type == Task.Types.VISITABLE_URL or task.link_type == Task.Types.REMOTE_FILE:
                try:
                    self.open_link_without_stdout_stderr(task.link)
                except Exception as _:
                    pass
            self.fman.add_input(
                Floating("v>")
                .set_header(" Abrindo link ")
                .put_text("\n " + task.link + " \n")
                .warning()
            )
        elif isinstance(obj, Quest):
            self.fman.add_input(
                Floating("v>")
                .put_text("\nEssa é uma missão.")
                .put_text("\nVocê só pode abrir o link")
                .put_text("de tarefas.\n")
                .error()
            )
        else:
            self.fman.add_input(
                Floating("v>")
                .put_text("\nEsse é um grupo.")
                .put_text("\nVocê só pode abrir o link")
                .put_text("de tarefas.\n")
                .error()
            )

    # def generate_graph(self):
    #     Graph(self.game).set_path(self.gen_graph_path()).set_opt(False).generate()
    #     path = self.gen_graph_path()
    #     if not self.graph_opened:
    #         opener = Opener(self.settings)
    #         opener.open_files([path])
    #         self.graph_opened = True

    def register_action(self, task: Task):
        Logger.get_instance().record_self_grade(task.key, task.coverage, task.autonomy, task.skill)
        
    def evaluate(self):
        obj = self.tree.get_selected_throw()
        
        if isinstance(obj, Task):
            self.fman.add_input(
                FloatingGrade(obj, "").set_exit_fn(
                    lambda: self.register_action(obj)
                )
            )
            return

    def down_remote_task(self):

        obj = self.tree.get_selected_throw()
        
        if isinstance(obj, Quest):
            self.fman.add_input(
                Floating("v>")
                .put_text("\nEssa é uma missão.")
                .put_text("\nVocê só pode baixar tarefas.\n")
                .error()
            )
            return
        if isinstance(obj, Cluster):
            self.fman.add_input(
                Floating("v>")
                .put_text("\nEsse é um grupo.")
                .put_text("\nVocê só pode baixar tarefas.\n")
                .error()
            )
        if not isinstance(obj, Task):
            return
        self.__down_remote_task(obj)
    
    def __down_remote_task(self, task: Task):
        if task.link_type != Task.Types.REMOTE_FILE and task.link_type != Task.Types.IMPORT_FILE:
            self.fman.add_input(
                Floating("v>").put_text("\nEssa não é uma tarefa de baixável.\n").error()
            )
            return
        lang = self.rep.get_lang() 
        down_frame = (
            Floating("v>").warning().set_text_ljust().set_header(" Baixando tarefa ")
        )
        # down_frame.put_text(f"\ntko down {self.rep.alias} {task.key} -l {lang}\n")
        self.fman.add_input(down_frame)

        def fnprint(text):
            down_frame.put_text(" " + text)
            down_frame.draw()
            Fmt.refresh()

        cmd_down = CmdDown(rep=self.rep, task_key=task.key, settings=self.settings)
        cmd_down.set_game(self.game)
        cmd_down.set_fnprint(fnprint)
        cmd_down.set_language(lang)
        result = cmd_down.execute()
        if result:
            Logger.get_instance().record_down(task.key)


    def select_task_action(self, task: Task):
        _, action = self.tree.get_task_action(task)
        if action == TaskAction.BAIXAR:
            return self.__down_remote_task(task)
        elif action == TaskAction.VISITAR:
            return self.open_link()
        elif action == TaskAction.EXECUTAR:
            folder = task.get_folder()
            if not folder:
                raise Warning("Folder não encontrado")
            return self.run_selected_task(task, folder)

    def select_task(self):
        obj = self.tree.get_selected_throw()

        if isinstance(obj, Quest) or isinstance(obj, Cluster):
            self.tree.toggle(obj)
            return

        if isinstance(obj, Task):
            return self.select_task_action(obj)

        raise Exception("Objeto não reconhecido")
        
    def run_selected_task(self, task: Task, task_dir: str):
        folder = task_dir
        run = Run(settings=self.settings, target_list=[folder], param=Param.Basic())
        run.set_lang(self.rep.get_lang())
        opener = Opener(self.settings).set_language(self.rep.get_lang()).set_target([folder])
        run.set_opener(opener)
        run.set_run_without_ask(False)
        run.set_curses(True)
        run.set_task(self.rep, task)

        run.build_wdir()
        
        if not run.wdir.has_solver():
            DownProblem.create_default_draft(task_dir, self.rep.get_lang())
            msg = Floating("v>").warning()
            msg.put_text("\nNenhum arquivo de código na linguagem {} encontrado.".format(self.rep.get_lang()))
            msg.put_text("\nUm arquivo de rascunho foi criado em {}.".format(task_dir))
            self.fman.add_input(msg)
        return run.execute

class PlayPalette:
    def __init__(self, actions: PlayActions):
        self.actions = actions
        self.app = self.actions.settings.app
        self.fman = self.actions.fman
        self.gui = self.actions.gui

    def command_pallete(self):
        options: list[FloatingInputData] = []

        def icon(value: bool):
            return Token("✓", "g") if value else Token("✗", "r")
        
        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Tarefa: {y} para repositório local", symbols.action, "Baixar"),
                self.actions.down_remote_task,
                GuiKeys.down_task
            ).set_exit_on_action(True)
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Tarefa: Abrir {y} com a descrição", symbols.action, "GitHub"),
                self.actions.open_link,
                GuiKeys.github_web
            ).set_exit_on_action(True)
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Tarefa: {y} arquivos na IDE", symbols.action, "Editar"),
                self.actions.open_code,
                GuiKeys.edit
            ).set_exit_on_action(True)
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y}", symbols.action, "Ajuda"),
                self.gui.show_help,
                GuiKeys.key_help
            ).set_exit_on_action(True)
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y}", icon(self.app.get_use_borders()), "Bordas"),
                self.app.toggle_borders,
                GuiKeys.borders
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y}", icon(self.app.get_use_images()), "Imagens"),
                self.app.toggle_images, 
                GuiKeys.images
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar atividades {y}", icon(self.app.get_show_hidden()), "Escondidas"),
                self.app.toggle_hidden, 
                GuiKeys.hidden
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y}", icon(Flags.percent), "Percentual"),
                Flags.percent.toggle, 
                Flags.percent.get_keycode()
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y} para completar a missão", icon(Flags.minimum), "Mínimo"),
                Flags.minimum.toggle,
                Flags.minimum.get_keycode()
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y} das tarefas", icon(Flags.reward), "Recompensa"),
                Flags.reward.toggle, 
                Flags.reward.get_keycode()
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mostrar {y}", icon(Flags.skills), "Skills"),
                Flags.skills.toggle, 
                Flags.skills.get_keycode()
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Modo {y}: Habilitar todas as tarefas", icon(Flags.admin), "Admin"),
                Flags.admin.toggle,
                Flags.admin.get_keycode()
            )
        )

        # options.append(
        #     FloatingInputData(
        #         lambda: Text.format(" {} Gerar {y} de dependências", symbols.action, "Grafo"),
        #         self.actions.generate_graph,
        #         GuiKeys.graph
        #     ).set_exit_on_action(True)
        # )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Mudar {y} de download de rascunhos", symbols.action, "Linguagem"),
                self.gui.language.set_language,
                GuiKeys.set_lang
            ).set_exit_on_action(True)
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Devel: Habilita mensagens de {y}", icon(Flags.devel), "Debug"),
                Flags.devel.toggle,
                ""
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Muda o gráfico {y}", icon(Flags.graph), "Graph"),
                Flags.graph.toggle,
                Flags.graph.get_keycode()
            )
        )

        options.append(
            FloatingInputData(
                lambda: Text.format(" {} Devel: Marcar em {y}", symbols.action, "Massa"),
                self.gui.tree.mass_mark,
                ""
            ).set_exit_on_action(True)
        )

        self.fman.add_input(
            FloatingInput("^").set_text_ljust()
                      .set_header(" Selecione uma ação da lista ")
                      .set_options(options)
                      .set_exit_on_enter(False)
                      .set_footer(" Use Enter para aplicar e Esc para Sair ")
        )




class Open:
    def __init__(self, settings: Settings, rep: Repository):
        self.settings = settings
        self.app = settings.app
        self.rep = rep
        self.game: Game = rep.game

        self.exit = False

        self.flagsman = FlagsMan(self.rep.get_flags())
        Flags.admin.set_value("0")
        self.fman = FloatingManager()
        self.tree = TaskTree(self.settings, rep, self.fman)
        self.gui = Gui(tree=self.tree, flagsman=self.flagsman, fman=self.fman)

        # if len(self.rep.get_tasks()) == 0:
        #     self.gui.show_help()

        self.first_loop = True
        self.graph_ext = ""

        self.actions = PlayActions(self.gui)
        self.play_palette = PlayPalette(self.actions)


    def save_to_json(self):
        self.tree.save_on_rep()
        self.rep.set_flags(self.flagsman.get_data())
        self.settings.save_settings()
        self.rep.save_config()

    def send_quit_msg(self):
        def set_exit():
            self.exit = True

        self.fman.add_input(
            Floating().put_text("\nAté a próxima\n").set_exit_fn(set_exit).warning()
        ),

    def toggle_skills(self):
        Flags.skills.toggle()

    def make_callback(self) -> InputManager:
        cman = InputManager()

        cman.add_str(GuiKeys.key_quit, self.send_quit_msg)
        cman.add_int(InputManager.esc, self.send_quit_msg)
        # cman.add_int(curses.KEY_BACKSPACE, self.send_quit_msg)

        cman.add_str(GuiKeys.up, self.tree.move_up)
        cman.add_int(curses.KEY_UP, self.tree.move_up)
        cman.add_str(GuiKeys.down, self.tree.move_down)
        cman.add_int(curses.KEY_DOWN, self.tree.move_down)
        cman.add_str(GuiKeys.left, self.tree.arrow_left)
        cman.add_int(curses.KEY_LEFT, self.tree.arrow_left)
        cman.add_str(GuiKeys.right, self.tree.arrow_right)
        cman.add_int(curses.KEY_RIGHT, self.tree.arrow_right)
        cman.add_str(GuiKeys.activate, self.actions.select_task)
        cman.add_str(GuiKeys.github_web, self.actions.open_link)
        cman.add_str(GuiKeys.down_task, self.actions.down_remote_task)
        cman.add_str(GuiKeys.edit, lambda: self.actions.open_code())
        cman.add_str(GuiKeys.expand, self.tree.process_expand_all)
        cman.add_str(GuiKeys.collapse, self.tree.process_collapse_all)
        cman.add_str(GuiKeys.borders, self.app.toggle_borders)
        cman.add_str(GuiKeys.images, self.app.toggle_images)
        cman.add_str(GuiKeys.hidden, self.app.toggle_hidden)
        cman.add_str(GuiKeys.set_lang, self.gui.language.set_language)
        # cman.add_str(GuiKeys.graph, self.actions.generate_graph)
        cman.add_int(curses.KEY_BACKSPACE, self.actions.evaluate)
        cman.add_str(GuiKeys.grade_play, self.actions.evaluate)
        if Flags.admin:
            cman.add_str(GuiKeys.mass, self.tree.mass_mark)
    
        cman.add_str(GuiKeys.key_help, self.gui.show_help)
        
        for flag in self.flagsman.flags.values():
            cman.add_str(flag.get_keycode(), FlagFunctor(flag))

        cman.add_str(GuiKeys.search, self.gui.search.toggle_search)
        cman.add_str(GuiKeys.palette, self.play_palette.command_pallete)

        return cman
        
    def send_char_not_found(self, key):
        if not Flags.devel:
            return

        exclude_str = [ord(v) for v in [" ", "a", "d", "\n"]]
        exclude_int = [ -1, InputManager.esc] + InputManager.backspace_list + InputManager.left_list + InputManager.right_list + InputManager.up_list + InputManager.down_list
        if key in exclude_int + exclude_str:
            return
        self.fman.add_input(
            Floating("v")
                .error()
                .put_text(f"Tecla char {chr(key)} code {key} não reconhecida")
        )

    def main(self, scr):
        InputManager.fix_esc_delay()
        curses.curs_set(0)  # Esconde o cursor
        Fmt.init_colors()  # Inicializa as cores
        Fmt.set_scr(scr)  # Define o scr como global

        while True:
            self.tree.update_tree(admin_mode=Flags.admin or self.gui.search.search_mode)
            self.fman.draw_warnings()
            cman = self.make_callback()
            self.gui.show_items()

            if self.fman.has_floating():
                value: int = self.fman.get_input()
            else:
                value = scr.getch()
                value = InputManager.fix_cedilha(scr, value)

            if self.exit:
                break

            if self.gui.search.search_mode:
                self.gui.search.process_search(value)
            elif cman.has_int_key(value):
                callback = cman.exec_call(value)
                if callback is not None:
                    return callback
            else:
                self.send_char_not_found(value)

            self.tree.reload_sentences()
            self.save_to_json()
            if self.first_loop:
                self.first_loop = False

    def check_lang_in_text_mode(self):
        lang = self.rep.get_lang()
        if lang == "":
            options = available_languages
            print("\nLinguagem padrão ainda não foi definida.\n")
            while True:
                print("Escolha entre as opções a seguir ", end="")
                print("[" + ", ".join(options) + "]", ":", end=" ")
                lang = input()
                if lang in options:
                    break
            self.rep.set_lang(lang)


    def play(self):
        self.check_lang_in_text_mode()

        while True:
            output = curses.wrapper(self.main)
            if output is None:
                return
            else:
                output()

class CmdOpen:
    def __init__(self, settings: Settings):
        self.settings = settings
        self.rep: Repository | None = None
        self.folder = ""

    def load_folder(self, folder: str):
        self.folder = folder
        self.rep = Repository(folder)
        if not self.rep.has_local_config_file():
            print(Text.format("{r}: O parâmetro para o comando {g} {y} deve a pasta onde você iniciou o repositório.", "Erro", "tko open", "<pasta>"))
            print(Text.format("{g}: Navegue ou passe o caminho até a pasta do repositório e tente novamente.", "Ação"))
            print(Text.format("{g}: Ou use {y} para criar um novo repositório.", "Ação","tko init --remote [fup|poo|ed]"))
            raise Warning(Text.format("{r}: {y} {}", "Erro:", folder, "não contém um repositório do tko"))
        self.rep.load_config().load_game()
        return self


    def execute(self):
        if self.rep is None:
            raise Warning("Repositório não encontrado")
        
        logger: Logger = Logger.get_instance()
        logger.set_log_files(self.rep.get_history_file())
        logger.record_open()
        play = Open(self.settings, self.rep)
        play.play()
        logger.record_quit()


    # @staticmethod
    # def choose_destiny(rep_alias):
    #     print(Text().add("Repositório local ainda não foi criado, onde você deseja criá-lo?"))
    #     here_cwd = os.path.join(os.getcwd(), rep_alias)
    #     qxcode = os.path.join(os.path.expanduser("~"), "qxcode", rep_alias)

    #     while True:
    #         print(Text().addf("r", "1").add(" - ").add(here_cwd))
    #         print(Text().addf("r", "2").add(" - ").add(qxcode))
    #         print(Text().addf("r", "3").add(" - ").add("Outra pasta"))
    #         print(Text().add("Default ").addf("r", "1").add(": "), end="")
    #         op = input()
    #         if op == "":
    #             op = "1"
    #         if op == "1":
    #             home_qxcode = here_cwd
    #             break
    #         if op == "2":
    #             home_qxcode = qxcode
    #             break
    #         if op == "3":
    #             print(Text().addf("y", "Navegue até o diretório desejado e execute o tko novamente."))
    #             exit(1)

    #     if not os.path.exists(home_qxcode):
    #         os.makedirs(home_qxcode)
    #     return home_qxcode








class Main:
    @staticmethod
    def test(args):
        PatternLoader.pattern = args.pattern
        param = Param.Basic().set_index(args.index)
        if args.quiet:
            param.set_diff_count(DiffCount.QUIET)
        elif args.all:
            param.set_diff_count(DiffCount.ALL)
        else:
            param.set_diff_count(DiffCount.FIRST)

        if args.filter:
            param.set_filter(True)
        if args.compact:
            param.set_compact(True)

        settings = Settings()
        if not args.side and not args.down:
            param.set_diff_mode(settings.app.get_diff_mode())
        elif args.side:
            param.set_diff_mode(DiffMode.SIDE)
        elif args.down:
            param.set_diff_mode(DiffMode.DOWN)
        cmd_run = Run(settings, args.target_list, param)
        cmd_run.execute()

    @staticmethod
    def run(args):
        PatternLoader.pattern = args.pattern
        param = Param.Basic().set_index(args.index)
        settings = Settings()
        param.set_diff_mode(settings.app.get_diff_mode())
        if args.filter:
            param.set_filter(True)
        cmd_run = Run(settings, args.target_list, param)
        cmd_run.set_curses()
        cmd_run.execute()

    @staticmethod
    def build(args):
        PatternLoader.pattern = args.pattern
        manip = Param.Manip().set_unlabel(args.unlabel).set_to_sort(args.sort).set_to_number(args.number)
        build = CmdBuild(args.target, args.target_list, manip)
        build.execute()

    @staticmethod
    def open(args):
        settings = Settings()
        folder = args.folder
        rec_folder = Repository.rec_search_for_repo(folder)
        if rec_folder != "":
            folder = rec_folder
        CmdOpen(settings).load_folder(folder).execute()
        CheckVersion().version_check()

    @staticmethod
    def init(args):
        remote: str | None = args.remote
        source: str | None = args.source
        folder: str | None = args.folder
        RepStarter(remote=remote, source=source, folder=folder)


    @staticmethod
    def config(args):
        settings = Settings()
        param = ConfigParams()
        param.side = args.side
        param.down = args.down
        param.images = args.images
        param.editor = args.editor
        param.borders = args.borders
        param.timeout = args.timeout
        CmdConfig.execute(settings, param)

    @staticmethod
    def list(_args):
        settings = Settings()
        print(str(settings))


class Parser:
    def __init__(self):
        self.parser: argparse.ArgumentParser = argparse.ArgumentParser(prog='tko', description=f'tko version {__version__}')
        self.subparsers = self.parser.add_subparsers(title='subcommands', help='help for subcommand.')

        self.parent_manip = self.create_parent_manip()
        self.parent_basic = self.create_parent_basic()

        self.add_parser_global()
        self.create_parent_basic()
        self.create_parent_manip()
        self.add_parser_run()
        self.add_parser_exec()
        self.add_parser_build()
        self.add_parser_config()
        self.add_parser_rep_tools()
        self.add_parser_rep_actions()


    def add_parser_global(self):
        self.parser.add_argument('-c', metavar='CONFIG_FILE', type=str, help='config json file.')
        self.parser.add_argument('-w', metavar='WIDTH', type=int, help="terminal width.")
        self.parser.add_argument('-v', action='store_true', help='show version.')
        self.parser.add_argument('-m', action='store_true', help='monochromatic.')

    def create_parent_basic(self):
        parent_basic = argparse.ArgumentParser(add_help=False)
        parent_basic.add_argument('--index', '-i', metavar="I", type=int, help='run a specific index.')
        parent_basic.add_argument('--pattern', '-p', metavar="P", type=str, default='@.in @.sol',
                                  help='pattern load/save a folder, default: "@.in @.sol"')
        return parent_basic

    def create_parent_manip(self):
        parent_manip = argparse.ArgumentParser(add_help=False)
        parent_manip.add_argument('--width', '-w', type=int, help="term width.")
        parent_manip.add_argument('--unlabel', '-u', action='store_true', help='remove all labels.')
        parent_manip.add_argument('--number', '-n', action='store_true', help='number labels.')
        parent_manip.add_argument('--sort', '-s', action='store_true', help="sort test cases by input size.")
        parent_manip.add_argument('--pattern', '-p', metavar="@.in @.out", type=str, default='@.in @.sol',
                                  help='pattern load/save a folder, default: "@.in @.sol"')
        return parent_manip

    def add_parser_run(self):
        parser_r = self.subparsers.add_parser('run', parents=[self.parent_basic], help='Run with test cases using curses.')
        parser_r.add_argument('target_list', metavar='T', type=str, nargs='*', help='solvers, test cases or folders.')
        parser_r.add_argument('--filter', '-f', action='store_true', help='filter solver in temp dir before run')
        parser_r.set_defaults(func=Main.run)

    def add_parser_exec(self):
        parser_r = self.subparsers.add_parser('test', parents=[self.parent_basic], help='Run with test cases using raw terminal.')
        parser_r.add_argument('target_list', metavar='T', type=str, nargs='*', help='solvers, test cases or folders.')
        parser_r.add_argument('--filter', '-f', action='store_true', help='filter solver in temp dir before run')
        parser_r.add_argument('--compact', '-c', action='store_true', help='Do not show case descriptions in failures')

        group_n = parser_r.add_mutually_exclusive_group()
        group_n.add_argument('--quiet', '-q', action='store_true', help='quiet mode, do not show any failure.')
        group_n.add_argument('--all', '-a', action='store_true', help='show all failures.')

        # add an exclusive group for diff mode
        group = parser_r.add_mutually_exclusive_group()
        group.add_argument('--down', '-d', action='store_true', help="diff mode up-to-down.")
        group.add_argument('--side', '-s', action='store_true', help="diff mode side-by-side.")
        parser_r.set_defaults(func=Main.test)

    def add_parser_build(self):
        parser_b = self.subparsers.add_parser('build', parents=[self.parent_manip], help='Build a test target.')
        parser_b.add_argument('target', metavar='T_OUT', type=str, help='target to be build.')
        parser_b.add_argument('target_list', metavar='T', type=str, nargs='+', help='input test targets.')
        parser_b.set_defaults(func=Main.build)

    # def add_parser_down(self):
    #     parser_d = self.subparsers.add_parser('down', help='download problem from repository.')
    #     parser_d.add_argument('course', type=str, nargs='?', help=" [ fup | ed | poo ].")
    #     parser_d.add_argument('activity', type=str, nargs='?', help="activity @label.")
    #     parser_d.add_argument('--language', '-l', type=str, nargs='?', help="[ c | cpp | js | ts | py | java ]")
    #     parser_d.set_defaults(func=Main.down)

    def add_parser_config(self):
        parser_cfg = self.subparsers.add_parser('config', help='Settings tool.')
        subpar_repo = parser_cfg.add_subparsers(title='subcommands', help='help for subcommand.')

        cfg_reset = subpar_repo.add_parser('reset', help='reset all repositories, folders and values to factory default.')
        cfg_reset.set_defaults(func=CmdRep.reset)

        cfg_set = subpar_repo.add_parser('set', help='set default config values.')

        g_diff = cfg_set.add_mutually_exclusive_group()
        g_diff.add_argument('--side', action='store_true', help='set side_by_side diff mode.')
        g_diff.add_argument('--down', action='store_true', help='set up_to_down   diff mode.')

        cfg_set.add_argument("--editor", metavar="cmd", type=str, help='set editor command.')
        cfg_set.add_argument("--borders", metavar="[0|1]", type=str, help='enable borders.')
        cfg_set.add_argument("--images", metavar="[0|1]", type=str, help='enable images.')
        cfg_set.add_argument("--timeout", metavar="sec", type=int, help='set timeout.')

        cfg_set.set_defaults(func=Main.config)

        cfg_list = subpar_repo.add_parser('list', help='list default config values.')
        cfg_list.set_defaults(func=Main.list)


    def add_parser_rep_tools(self):

        parser_repo = self.subparsers.add_parser('rep', help='Repository validation tools.')

        subpar_repo = parser_repo.add_subparsers(title='subcommands', help='help for subcommand.')
        repo_log = subpar_repo.add_parser("check", help="validates log of the repository.")
        repo_log.add_argument('folder', type=str, help='folder to be checked.')
        repo_log.set_defaults(func=CmdRep.check)

        repo_resume = subpar_repo.add_parser("resume", help="resume log of the repository.")
        repo_resume.add_argument('folder', type=str, help='folder to be checked.')
        repo_resume.set_defaults(func=CmdRep.resume)

        repo_resume = subpar_repo.add_parser("graph", help="resume log of the repository.")
        repo_resume.add_argument('folder', type=str, help='folder to be checked.')
        repo_resume.set_defaults(func=CmdRep.graph)



    def add_parser_rep_actions(self):
        parser_open = self.subparsers.add_parser('open', help='Open a folder with a repository.')
        parser_open.add_argument('folder', type=str, nargs='?', default='.', help='repository folder.')
        parser_open.set_defaults(func=Main.open)

        parser_play = self.subparsers.add_parser('play', help='Play a folder with a repository.')
        parser_play.add_argument('folder', type=str, nargs='?', default='.', help='repository folder.')
        parser_play.set_defaults(func=Main.open)

        parser_init = self.subparsers.add_parser('init', help='Initialize a repository in a folder.')
        source = parser_init.add_mutually_exclusive_group()
        source.add_argument('--remote', '-r', type=str, help='remote source [fup|ed|poo].')
        source.add_argument('--source', '-s', type=str, help='http url or local file.')
        parser_init.add_argument('--folder', '-f', type=str, help='local directory.')
        parser_init.set_defaults(func=Main.init)


def exec(parser: argparse.ArgumentParser, args):
    settings = Settings()
    if args.w is not None:
        RawTerminal.set_terminal_size(args.w)
    if args.c:
        settings.set_settings_file(args.c)
    settings.load_settings()
    Logger.instance = Logger()

    if args.m:
        AnsiColor.enabled = False
    else:
        AnsiColor.enabled = True
        symbols.set_colors()

    if args.v:
        if args.v:
            print("tko version " + __version__)
    else:
        if "func" in args:
            args.func(args)
        else:
            parser.print_help()

def main():
    try:
        parser = Parser().parser
        args = parser.parse_args()
        exec(parser, args)
        sys.exit(0)
    except KeyboardInterrupt:
        print("\n\nKeyboard Interrupt")
        sys.exit(1)
    except Warning as w:
        print("")
        print(w)
        sys.exit(1)
    # except Exception as e:
    #     print(e)
    #     sys.exit(1)

# NÃO RETIRE ESSA TAG POR CAUSA DO MERGE DO REPLIT
if __name__ == '__main__': # MERGE_INSERT 
    main()

class Compare:
    @staticmethod
    def load_and_save(filename, received):
        folder = "compare"
        if not os.path.isdir(folder):
            os.mkdir(folder)
        rec = os.path.join(folder, filename + ".rec")
        exp = os.path.join(folder, filename + ".exp")
        open(rec, "w").write(received)
        if os.path.isfile(exp):
            expected = open(exp).read()
        else:
            open(exp, "w").write(received)
            expected = received
        return expected, received
    
    @staticmethod
    def text(capsys, file: str, cmd: str):
        Compare.list(capsys, file, cmd.split(" "))

    @staticmethod
    def list(capsys, file: str, cmd_list: list[str]):
        parser = Parser().parser
        args = parser.parse_args(cmd_list)
        exec(parser, args)
        expected, received = Compare.load_and_save(file, capsys.readouterr().out)
        assert expected == received